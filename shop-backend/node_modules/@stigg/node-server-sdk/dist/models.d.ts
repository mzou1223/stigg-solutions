import { PackageEntitlementFragment, PaymentCollection, PaywallConfigurationFragment, SubscriptionQueryFragment, PaywallCurrencyFragment, PageInfoFragment, SubscriptionCancellationAction, SubscriptionFutureUpdateDataFragment, SubscriptionInvoiceFragment, SubscriptionMigrationTime, SubscriptionScheduleStatus, BillingPeriod, SubscriptionCancellationTime, PromotionalEntitlementStatus, SubscriptionStatus, TrialPeriodUnits, BillingModel, PricingType, SubscriptionDecisionStrategy, ExperimentGroupType, Currency, DiscountType, DiscountDurationType, UsageUpdateBehavior, EntitlementResetPeriod, AccessDeniedReason, FeatureType, MeterType, ProvisionSubscriptionStatus, TiersMode, PriceTierFragment, TotalPriceFragment, BillingAddress, MonthlyAccordingTo, WeeklyAccordingTo, CustomerStatisticsFragment, TrialOverrideConfigurationInput, ScheduleStrategy, BillingCadence, ImportSubscriptionInput, PaymentCollectionMethod, BudgetConfigurationInput, SubscriptionCouponInput, PriceOverrideInput, SubscriptionProrationBehavior } from '@stigg/api-client-js/src/generated/sdk';
export * from '@stigg/api-client-js/src/generated/sdk';
export interface Metadata {
    [key: string]: string;
}
export declare type EntitlementFeature = {
    id: string;
    featureType: FeatureType;
    units?: string;
    unitsPlural?: string;
    meterType?: MeterType.Fluctuating | MeterType.Incremental | MeterType.None;
    isMetered?: boolean;
};
export declare type FullEntitlementFeature = {
    id: string;
    featureType: FeatureType;
    displayName: string;
    description?: string;
    units?: string;
    unitsPlural?: string;
    meterType?: MeterType.Fluctuating | MeterType.Incremental | MeterType.None;
    isMetered?: boolean;
    metadata?: Record<string, string>;
};
export declare type BaseEntitlement = {
    hasAccess: boolean;
    isFallback: boolean;
    accessDeniedReason?: AccessDeniedReason;
    feature?: EntitlementFeature;
};
export interface BooleanEntitlement extends BaseEntitlement {
    type: 'BOOLEAN';
}
export interface EnumEntitlement extends BaseEntitlement {
    type: 'ENUM';
    enumValues: string[];
    requestedValues?: string[];
}
export interface NumericEntitlement extends BaseEntitlement {
    type: 'NUMERIC';
    value?: number;
    isUnlimited: boolean;
}
export interface MeteredEntitlement extends BaseEntitlement {
    type: 'METERED';
    usageLimit?: number;
    isUnlimited: boolean;
    hasSoftLimit: boolean;
    currentUsage: number;
    requestedUsage: number;
    resetPeriod?: EntitlementResetPeriod;
    /** The anchor for calculating the usage period for metered entitlements with a reset period configured */
    usagePeriodAnchor?: Date;
    /** The start date of the usage period for metered entitlements with a reset period configured */
    usagePeriodStart?: Date;
    /** The end date of the usage period for metered entitlements with a reset period configured */
    usagePeriodEnd?: Date;
    /** @deprecated renamed to {@link usagePeriodEnd} */
    nextResetDate?: Date;
}
export declare type Entitlement = BooleanEntitlement | NumericEntitlement | MeteredEntitlement | EnumEntitlement;
/** @internal */
export declare const BOOLEAN_DEFAULT_FALLBACK_ENTITLEMENT: BooleanEntitlement;
/** @internal */
export declare const NUMERIC_DEFAULT_FALLBACK_ENTITLEMENT: NumericEntitlement;
/** @internal */
export declare const METERED_DEFAULT_FALLBACK_ENTITLEMENT: MeteredEntitlement;
/** @internal */
export declare const ENUM_DEFAULT_FALLBACK_ENTITLEMENT: EnumEntitlement;
export declare type DependencyAddon = {
    refId: string;
    displayName: string;
    description?: string;
};
export declare type Addon = {
    id: string;
    displayName: string;
    billingId?: string | null;
    description: string;
    entitlements: PackageEntitlement[];
    pricePoints: Price[];
    pricingType?: PricingType | null;
    metadata?: Metadata | null;
    maxQuantity?: number;
    dependencies?: DependencyAddon[];
};
export declare type FullSubscriptionAddon = {
    quantity: number;
    addon: Addon;
};
export declare type FullSubscription = {
    id: string;
    resource: CustomerResource | null;
    payingCustomer: SlimCustomer | null;
    status: SubscriptionStatus;
    plan: Plan;
    /** @deprecated use {@link prices} instead with {@link totalPrice} */
    price: SubscriptionPrice | null;
    prices: Price[];
    totalPrice: TotalPriceFragment | null | undefined;
    pricingType: PricingType;
    addons: FullSubscriptionAddon[];
    billingId?: string;
    billingLinkUrl?: string;
    crmId?: string;
    startDate: Date;
    endDate?: Date;
    trialEndDate?: Date;
    /**
     * The calculated end date after which the subscription will be canceled, which takes trial expiration and scheduled cancellations into consideration
     */
    effectiveEndDate?: Date;
    cancellationDate?: Date;
    currentBillingPeriodEnd?: Date;
    metadata?: Metadata | null;
    experimentInfo?: ExperimentInfo | null;
    latestInvoice?: SubscriptionInvoiceFragment;
    paymentCollection: PaymentCollection;
    paymentCollectionMethod?: PaymentCollectionMethod;
    billingSyncError?: string;
    /** Future updates can be of 2 types {@link SubscriptionScheduleStatus.Scheduled} or {@link SubscriptionScheduleStatus.PendingPayment}  */
    futureUpdates: SubscriptionFutureUpdateDataFragment[];
};
export declare type Subscription = {
    id: string;
    resource: CustomerResource | null;
    status: SubscriptionStatus;
    customerId: string;
    planId: string;
    addonIds: string[];
    addons: SubscriptionAddon[];
    metadata?: Metadata | null;
    billingId?: string;
    billingLinkUrl?: string;
    pricingType: PricingType;
    effectiveEndDate?: Date;
    /** @deprecated use {@link prices} instead with {@link totalPrice} */
    price: SubscriptionPrice | null;
    prices: Price[];
    totalPrice: TotalPriceFragment | null | undefined;
    experimentInfo?: ExperimentInfo | null;
    latestInvoice?: SubscriptionInvoiceFragment;
    paymentCollection: PaymentCollection;
    billingSyncError?: string;
};
export declare type SubscriptionAddon = {
    addonId: string;
    quantity?: number;
};
export declare type UpdateSubscription = {
    subscriptionId: string;
    unitQuantity?: number;
    billableFeatures?: BillableFeature[];
    metadata?: Metadata | null;
    addons?: SubscriptionAddon[];
    billingPeriod?: BillingPeriod;
    awaitPaymentConfirmation?: boolean;
    billingInformation?: SubscriptionBillingInfo;
    subscriptionEntitlements?: SubscriptionEntitlement[];
    trialEndDate?: Date;
    scheduleStrategy?: ScheduleStrategy;
    appliedCoupon?: SubscriptionCouponInput;
    priceOverrides?: PriceOverrideInput[];
};
export declare type CreateSubscription = CreateSubscriptionParams & {
    customerId: string;
};
export declare type CreateSubscriptionParams = {
    resourceId?: string;
    planId: string;
    addons?: SubscriptionAddon[];
    startDate?: Date;
    id?: string;
    billingPeriod?: BillingPeriod;
    unitQuantity?: number;
    billableFeatures?: BillableFeature[];
    skipTrial?: boolean;
    metadata?: Metadata | null;
    awaitPaymentConfirmation?: boolean;
    billingInformation?: SubscriptionBillingInfo;
    promotionCode?: string;
    appliedCoupon?: SubscriptionCouponInput;
    trialOverrideConfiguration?: TrialOverrideConfigurationInput;
    priceOverrides?: PriceOverrideInput[];
};
export declare type Money = {
    amount: number;
    currency: string;
};
export declare type DateRange = {
    start?: Date;
    end?: Date;
};
export declare type SubscriptionPreviewProration = {
    prorationDate: Date;
    credit: Money;
    debit: Money;
    netAmount: Money;
    hasProrations?: boolean;
};
export declare type SubscriptionPreviewInvoice = {
    total: Money;
    subTotal: Money;
    totalExcludingTax: Money;
    tax?: Money;
    discount?: Money;
    taxDetails?: SubscriptionPreviewTaxDetails;
    discountDetails?: SubscriptionPreviewDiscount;
};
export declare type ImmediateSubscriptionPreviewInvoice = SubscriptionPreviewInvoice & {
    proration?: SubscriptionPreviewProration;
    credits?: SubscriptionPreviewCredits;
};
export declare type SubscriptionPreviewCredits = {
    initial: Money;
    used: Money;
    remaining: Money;
};
export declare type SubscriptionPricePreview = {
    subTotal: Money;
    totalExcludingTax: Money;
    total: Money;
    tax: Money;
};
export declare type SubscriptionPreviewDiscount = {
    type: DiscountType;
    value: number;
    durationType: DiscountDurationType;
    durationInMonths?: number;
};
export declare type SubscriptionPreviewTaxDetails = {
    displayName: string;
    percentage: number;
    inclusive: boolean;
};
export interface SubscriptionPreview {
    subTotal: Money;
    totalExcludingTax: Money;
    total: Money;
    tax?: Money;
    taxDetails?: SubscriptionPreviewTaxDetails;
    discount?: SubscriptionPreviewDiscount;
    billingPeriodRange: DateRange;
    proration?: SubscriptionPreviewProration;
    subscription?: SubscriptionPricePreview;
}
export interface SubscriptionPreviewV2 {
    /**
     * The immediate invoice prices that will be generated for the subscription
     * for the previewed subscription \ changes
     */
    immediateInvoice: ImmediateSubscriptionPreviewInvoice;
    /**
     * The recurring invoice prices that will be generated for the subscription
     * for the previewed subscription \ changes, starting from the next billing period
     */
    recurringInvoice?: SubscriptionPreviewInvoice;
    billingPeriodRange: DateRange;
    isPlanDowngrade?: boolean;
    hasScheduledUpdates?: boolean;
}
export declare type EstimateSubscription = {
    customerId: string;
    payingCustomerId?: string;
    resourceId?: string;
    planId: string;
    billingCountryCode?: string;
    addons?: SubscriptionAddon[];
    startDate?: Date;
    billingPeriod?: BillingPeriod;
    unitQuantity?: number;
    billableFeatures?: BillableFeature[];
    billingInformation?: SubscriptionBillingInfo;
    promotionCode?: string;
    appliedCoupon?: SubscriptionCouponInput;
    skipTrial?: boolean;
};
export declare type EstimateSubscriptionUpdate = {
    subscriptionId: string;
    unitQuantity?: number;
    billableFeatures?: BillableFeature[];
    addons?: SubscriptionAddon[];
    promotionCode?: string;
    appliedCoupon?: SubscriptionCouponInput;
};
export declare type PreviewSubscription = {
    customerId: string;
    payingCustomerId?: string;
    planId: string;
    resourceId?: string;
    addons?: SubscriptionAddon[];
    startDate?: Date;
    billingPeriod?: BillingPeriod;
    billingCountryCode?: string;
    unitQuantity?: number;
    billableFeatures?: BillableFeature[];
    billingInformation?: SubscriptionBillingInfo;
    promotionCode?: string;
    appliedCoupon?: SubscriptionCouponInput;
    scheduleStrategy?: ScheduleStrategy;
};
export declare type PreviewNextInvoice = {
    subscriptionId: string;
};
export declare type CancelSubscriptionScheduledUpdates = {
    subscriptionId: string;
    status?: SubscriptionScheduleStatus.Scheduled | SubscriptionScheduleStatus.PendingPayment;
};
export declare type MigrateSubscriptionToLatest = {
    subscriptionId: string;
    subscriptionMigrationTime?: SubscriptionMigrationTime;
};
export declare type ProvisionedCustomer = {
    customer: Customer;
    subscriptionDecisionStrategy: SubscriptionDecisionStrategy;
    subscription?: Subscription;
};
export declare type ProvisionCustomer = CreateCustomer & {
    subscriptionParams: CreateSubscriptionParams | null;
};
export declare type ProvisionSubscriptionResult = {
    provisionStatus: ProvisionSubscriptionStatus;
    subscription?: Subscription;
    checkoutUrl?: string | null;
};
export declare type CheckoutOptions = {
    successUrl: string;
    cancelUrl: string;
    allowPromoCodes?: boolean;
    allowTaxIdCollection?: boolean;
    collectBillingAddress?: boolean;
    referenceId?: string;
    collectPhoneNumber?: boolean;
};
export declare type ApplySubscription = {
    customerId: string;
    planId: string;
    paymentMethodId?: string;
    payingCustomerId?: string;
    resourceId?: string;
    addons?: SubscriptionAddon[];
    startDate?: Date;
    billingId?: string;
    billingPeriod?: BillingPeriod;
    skipTrial?: boolean;
    unitQuantity?: number;
    billableFeatures?: BillableFeature[];
    metadata?: Metadata | null;
    billingInformation?: SubscriptionBillingInfo;
    promotionCode?: string;
    appliedCoupon?: SubscriptionCouponInput;
    billingCountryCode?: string;
    trialOverrideConfiguration?: TrialOverrideConfigurationInput;
    scheduleStrategy?: ScheduleStrategy;
    paymentCollectionMethod?: PaymentCollectionMethod;
    priceOverrides?: PriceOverrideInput[];
};
export declare type ApplySubscriptionResults = {
    subscription?: Subscription;
};
export declare type ImportSubscriptionBulk = {
    subscriptions: ImportSubscription[];
};
export declare type ImportSubscription = Omit<ImportSubscriptionInput, 'additionalMetaData'> & {
    metadata?: Metadata;
};
export declare type BillableFeature = {
    featureId: string;
    quantity: number;
};
export declare type SubscriptionEntitlement = {
    featureId: string;
    hasUnlimitedUsage?: boolean;
    hasSoftLimit?: boolean;
    usageLimit?: number;
    resetPeriod?: EntitlementResetPeriod;
    monthlyResetPeriodConfiguration?: {
        accordingTo: MonthlyAccordingTo;
    };
    weeklyResetPeriodConfiguration?: {
        accordingTo: WeeklyAccordingTo;
    };
};
export declare type ProvisionSubscription = {
    customerId: string;
    payingCustomerId?: string;
    resourceId?: string;
    planId: string;
    addons?: SubscriptionAddon[];
    startDate?: Date;
    id?: string;
    billingId?: string;
    salesforceId?: string;
    billingPeriod?: BillingPeriod;
    skipTrial?: boolean;
    unitQuantity?: number;
    billableFeatures?: BillableFeature[];
    metadata?: Metadata | null;
    awaitPaymentConfirmation?: boolean;
    billingInformation?: SubscriptionBillingInfo;
    checkoutOptions?: CheckoutOptions;
    promotionCode?: string;
    appliedCoupon?: SubscriptionCouponInput;
    billingCountryCode?: string;
    subscriptionEntitlements?: SubscriptionEntitlement[];
    trialOverrideConfiguration?: TrialOverrideConfigurationInput;
    scheduleStrategy?: ScheduleStrategy;
    paymentCollectionMethod?: PaymentCollectionMethod;
    priceOverrides?: PriceOverrideInput[];
};
export declare type SubscriptionBillingInfo = {
    taxRateIds?: string[];
    taxPercentage?: number;
    billingAddress?: BillingAddress;
    metadata?: Metadata | null;
    chargeOnBehalfOfAccount?: string;
    couponId?: string;
    isInvoicePaid?: boolean;
    isBackdated?: boolean;
    integrationId?: string;
    prorationBehavior?: SubscriptionProrationBehavior;
};
export declare type CancelSubscription = {
    subscriptionId: string;
    endDate?: Date;
    subscriptionCancellationTime?: SubscriptionCancellationTime;
    subscriptionCancellationAction?: SubscriptionCancellationAction;
    prorate?: boolean;
    awaitSubscriptionCancellation?: boolean;
};
export declare type GetBooleanEntitlement = {
    customerId: string;
    featureId: string;
    resourceId?: string;
    options?: BooleanEntitlementOptions;
};
export declare type GetNumericEntitlement = {
    customerId: string;
    featureId: string;
    resourceId?: string;
    options?: NumericEntitlementOptions;
};
export declare type GetMeteredEntitlement = {
    customerId: string;
    featureId: string;
    resourceId?: string;
    options?: MeteredEntitlementOptions;
};
export declare type GetEnumEntitlement = {
    customerId: string;
    featureId: string;
    resourceId?: string;
    options?: EnumEntitlementOptions;
};
export declare type GetEntitlement = {
    customerId: string;
    featureId: string;
    resourceId?: string;
    options?: EntitlementOptions;
};
export declare type EntitlementOptions = BooleanEntitlementOptions | NumericEntitlementOptions | MeteredEntitlementOptions | EnumEntitlementOptions;
export declare type ReportUsage = {
    customerId: string;
    resourceId?: string;
    featureId: string;
    value: number;
    updateBehavior?: UsageUpdateBehavior;
    createdAt?: Date;
    dimensions?: Record<string, EventDimensionValue>;
};
export declare type ReportUsageBulk = {
    usages: ReportUsage[];
};
export declare type EventDimensionValue = string | number | boolean;
export declare type ReportEvent = {
    eventName: string;
    customerId: string;
    idempotencyKey: string;
    resourceId?: string;
    dimensions?: Record<string, EventDimensionValue>;
    timestamp?: Date;
};
export declare type ReportUsageAck = {
    measurementId: string;
    featureId: string;
    customerId: string;
    resourceId?: string;
    currentUsage?: number;
    usagePeriodStart?: Date;
    usagePeriodEnd?: Date;
    /** @deprecated renamed to {@link usagePeriodEnd} */
    nextResetDate?: Date;
};
export declare type ImportCustomerBulk = {
    customers: ImportCustomer[];
};
export declare type ImportCustomer = {
    billingId?: string;
    customerId?: string;
    name?: string;
    email?: string;
    paymentMethodId?: string;
    metadata?: Metadata | null;
    updatedAt?: Date;
};
export declare type CreateCustomer = {
    customerId?: string;
    name?: string;
    email?: string;
    billingId?: string;
    salesforceId?: string;
    billingInfo?: BillingInfo;
    couponId?: string;
    metadata?: Metadata | null;
    /** @deprecated not in use anymore - will be removed in future release */
    shouldSyncFree?: boolean;
    excludeFromExperiment?: boolean;
};
export declare type GetSubscription = {
    subscriptionId: string;
};
export declare type GetActiveSubscriptions = {
    customerId: string;
    resourceId?: string | string[];
};
export declare type PaginatedResult<T> = {
    data: T[];
    pageInfo: PageInfoFragment;
};
export declare type GetSubscriptionsResult = PaginatedResult<SubscriptionQueryFragment>;
export declare type GetSubscriptionsParams = {
    customerId?: string;
    resourceId?: string | string[];
    status?: SubscriptionStatus | SubscriptionStatus[];
    productId?: string | string[];
    pagination?: {
        limit?: number;
        startingAfter?: string;
        endingBefore?: string;
    };
};
export declare type UpdateCustomer = {
    customerId: string;
    name?: string;
    email?: string;
    couponId?: string | null;
    billingId?: string;
    salesforceId?: string;
    billingInfo?: BillingInfo;
    metadata?: Metadata | null;
    shouldWaitSync?: boolean;
    integrationId?: string;
};
export declare type BillingInfo = {
    billingAddress?: Address;
    shippingAddress?: Address;
    currency?: Currency;
    timezone?: string;
    language?: string;
    taxIds?: TaxExempt[];
    invoiceCustomFields?: Record<string, string>;
    paymentMethodId?: string;
    customerName?: string;
    metadata?: Metadata | null;
    integrationId?: string;
};
/**
 * @param country - optional country of the address - in a valid ISO 3166-1 alpha-2 format
 */
export declare type Address = {
    country?: string;
    state?: string;
    addressLine1?: string;
    addressLine2?: string;
    city?: string;
    postalCode?: string;
    phoneNumber?: string;
};
export declare type TaxExempt = {
    type: string;
    value: string;
};
export declare type EntitlementsFallback = {
    [featureId: string]: BooleanEntitlementFallback | NumericEntitlementFallback | MeteredEntitlementFallback | EnumEntitlementFallback;
};
export declare type BooleanEntitlementFallback = {
    hasAccess: boolean;
};
export declare type BooleanEntitlementOptions = {
    /** @deprecated not in use anymore */
    shouldTrack?: boolean;
    fallback?: BooleanEntitlementFallback;
};
export declare type NumericEntitlementFallback = {
    hasAccess: boolean;
    value?: number;
    isUnlimited?: boolean;
};
export declare type NumericEntitlementOptions = {
    /** @deprecated not in use anymore */
    shouldTrack?: boolean;
    fallback?: NumericEntitlementFallback;
};
export declare type MeteredEntitlementFallback = {
    hasAccess: boolean;
    usageLimit?: number;
    isUnlimited?: boolean;
};
export declare type MeteredEntitlementOptions = {
    requestedUsage?: number;
    /** @deprecated not in use anymore */
    shouldTrack?: boolean;
    fallback?: MeteredEntitlementFallback;
};
export declare type EnumEntitlementFallback = {
    hasAccess: boolean;
    enumValues?: string[];
};
export declare type EnumEntitlementOptions = {
    requestedValues?: string[];
    shouldTrack?: boolean;
    fallback?: EnumEntitlementFallback;
};
export declare type CreateUsageMeasurement = {
    customerId: string;
    resourceId?: string;
    featureId: string;
    value: number;
    updateBehavior?: UsageUpdateBehavior;
    createdAt?: Date;
    dimensions?: Record<string, EventDimensionValue>;
};
export declare type FullPromotionalEntitlement = {
    usageLimit: number;
    feature: EntitlementFeature;
    hasUnlimitedUsage?: boolean | null;
    hasSoftLimit?: boolean | null;
    status: PromotionalEntitlementStatus;
    expiresAt?: Date;
    hasExpirationDate: boolean;
    isVisible: boolean;
};
export declare type PaymentMethodDetails = {
    expirationMonth?: number | null;
    expirationYear?: number | null;
    last4Digits?: string | null;
};
export declare type CustomerResource = {
    id: string;
};
export declare type SlimCustomer = {
    id: string;
    name?: string;
    email?: string;
    createdAt: Date;
    updatedAt: Date;
    billingId?: string;
    metadata?: Metadata | null;
    awsMarketplaceCustomerId?: string | null;
};
export declare type Customer = SlimCustomer;
export declare type FullCustomer = SlimCustomer & {
    hasPaymentMethod: boolean;
    paymentMethodDetails?: PaymentMethodDetails;
    subscriptions: FullSubscription[];
    promotionalEntitlements: PromotionalEntitlement[];
    coupon?: Coupon;
    experimentInfo?: ExperimentInfo | null;
    alreadyTrialPlans: TrialedPlan[];
    getActivePromotionalEntitlements(): FullPromotionalEntitlement[];
    /** @deprecated use {@link StiggManagementAPI.getActiveSubscriptions} instead with filter for {@link SubscriptionStatus.Active} */
    getActiveSubscriptions(): FullSubscription[];
    /** @deprecated use {@link StiggManagementAPI.getActiveSubscriptions} instead with filter for {@link SubscriptionStatus.InTrial} */
    getActiveTrials(): FullSubscription[];
};
export declare type CustomerState = Omit<FullCustomer, 'getActiveSubscriptions' | 'getActivePromotionalEntitlements' | 'getActiveTrials'>;
export declare type CustomerStatisticsModel = {
    statistics: CustomerStatisticsFragment['statistics'];
};
export declare type PackageEntitlement = {
    usageLimit: number;
    feature: FullEntitlementFeature;
    hasUnlimitedUsage?: boolean | null;
    hasSoftLimit?: boolean | null;
    resetPeriod?: EntitlementResetPeriod | null;
    hiddenFromWidgets?: PackageEntitlementFragment['hiddenFromWidgets'];
    displayNameOverride?: PackageEntitlementFragment['displayNameOverride'];
    isGranted: PackageEntitlementFragment['isGranted'];
};
export declare type PromotionalEntitlement = {
    usageLimit: number;
    feature: FullEntitlementFeature;
    hasUnlimitedUsage?: boolean | null;
    hasSoftLimit?: boolean | null;
    status: PromotionalEntitlementStatus;
    expiresAt?: Date;
    hasExpirationDate: boolean;
    isVisible: boolean;
};
export declare type Price = {
    pricingModel: BillingModel;
    billingPeriod: BillingPeriod;
    billingCadence?: BillingCadence;
    billingId?: string | null;
    amount?: number | null;
    tiers?: PriceTierFragment[] | null | undefined;
    tiersMode: TiersMode | null | undefined;
    currency: Currency;
    minUnitQuantity?: number | null | undefined;
    maxUnitQuantity?: number | null | undefined;
    billingCountryCode?: string | null | undefined;
    feature?: {
        featureId: string;
        units?: string | null | undefined;
        unitsPlural?: string | null | undefined;
        unitQuantity?: number | null;
        displayName: string;
        description?: string | null;
    } | null;
    blockSize?: number | null;
};
export declare type SubscriptionPrice = Price & {
    grossAmount: number;
};
export declare type BasePlan = {
    displayName: string;
    id: string;
};
export declare type CompatiblePackageGroupOptions = {
    minItems?: number;
    freeItems?: number;
};
export declare type CompatiblePackageGroup = {
    packageGroupId: string;
    displayName: string;
    addons: Addon[];
    options?: CompatiblePackageGroupOptions;
};
export declare type Plan = {
    id: string;
    displayName: string;
    billingId?: string | null;
    description?: string | null;
    order: number;
    basePlan?: BasePlan;
    entitlements: PackageEntitlement[];
    inheritedEntitlements: PackageEntitlement[];
    pricePoints: Price[];
    pricingType?: PricingType | null;
    defaultTrialConfig?: DefaultTrialConfig | null;
    compatibleAddons: Addon[];
    compatiblePackageGroups: CompatiblePackageGroup[];
    product: Product;
    metadata?: Metadata | null;
};
export declare type Coupon = {
    id: string;
    name: string;
    description?: string | null;
    discountValue: number;
    percentOff?: number | null;
    amountsOff?: Money[] | null;
    metadata?: Metadata | null;
};
export declare type Product = {
    id: string;
    displayName?: string | null;
    description?: string | null;
    metadata?: Metadata | null;
    downgradePlan?: Pick<Plan, 'id' | 'displayName'>;
};
export declare type DefaultTrialConfig = {
    duration: number;
    units: TrialPeriodUnits;
    budget?: {
        limit: BudgetConfigurationInput['limit'];
    };
};
export declare type GetPaywall = {
    productId?: string;
    customerId?: string;
    resourceId?: string;
    billingCountryCode?: string;
    fetchAllCountriesPrices?: boolean;
    includeHiddenPlans?: boolean;
};
export declare type PaywallConfiguration = Omit<PaywallConfigurationFragment, '__typename'>;
export declare type PaywallCurrency = Omit<PaywallCurrencyFragment, '__typename'>;
export declare type Paywall = {
    plans: Plan[];
    configuration?: PaywallConfiguration | null;
    customer: Customer | null;
    resource: CustomerResource | null;
    activeSubscriptions: FullSubscription[] | null;
    currency: PaywallCurrency;
};
export declare type ExperimentInfo = {
    id: string;
    name: string;
    groupName: string;
    groupType?: ExperimentGroupType | null;
};
export declare type TrialedPlan = {
    planId: string;
    productId: string;
};
export declare type FetchUsageHistory = {
    customerId: string;
    resourceId?: string;
    featureId: string;
    startDate: Date;
    endDate?: Date;
};
export declare type UsageHistoryPoint = {
    date: Date;
    value: number;
    isResetPoint: boolean;
};
/** @hidden */
export declare class CustomerModel implements FullCustomer {
    id: string;
    createdAt: Date;
    updatedAt: Date;
    subscriptions: FullSubscription[];
    promotionalEntitlements: PromotionalEntitlement[];
    hasPaymentMethod: boolean;
    alreadyTrialPlans: TrialedPlan[];
    constructor(state: CustomerState);
    getActiveSubscriptions(): FullSubscription[];
    getActiveTrials(): FullSubscription[];
    getActivePromotionalEntitlements(): PromotionalEntitlement[];
}
