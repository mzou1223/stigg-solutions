import { ApplySubscription, ApplySubscriptionResults, BooleanEntitlement, CancelSubscription, CancelSubscriptionScheduledUpdates, Coupon, CreateCustomer, CreateSubscription, Customer, CustomerStatisticsModel, Entitlement, EstimateSubscription, EstimateSubscriptionUpdate, FetchUsageHistory, FullCustomer, FullSubscription, GetActiveSubscriptions, GetBooleanEntitlement, GetEntitlement, GetMeteredEntitlement, GetNumericEntitlement, GetEnumEntitlement, GetPaywall, GetSubscription, GetSubscriptionsParams, GetSubscriptionsResult, ImportCustomer, ImportCustomerBulk, ImportSubscriptionBulk, MeteredEntitlement, MigrateSubscriptionToLatest, NumericEntitlement, Paywall, PreviewNextInvoice, PreviewSubscription, Product, ProvisionCustomer, ProvisionedCustomer, ProvisionSubscription, ProvisionSubscriptionResult, ReportEvent, ReportUsage, ReportUsageAck, ReportUsageBulk, Subscription, SubscriptionPreview, SubscriptionPreviewV2, UpdateCustomer, UpdateSubscription, UsageHistoryPoint, EnumEntitlement } from './models';
import { ClientConfiguration } from './configuration';
import { EventNames, Events } from './services/eventEmitter';
import { DelegateSubscriptionToCustomerInput, GrantPromotionalEntitlementsInput, PromotionalEntitlementFragment, RevokePromotionalEntitlementInput, SlimSubscriptionFragmentV2Fragment, SubscriptionInvoicePreviewFragment, TransferSubscriptionInput, TransferSubscriptionToResourceInput, UsageHistoryV2Fragment, UsageHistoryV2Input, CreditGrantInput, CreditGrantFragment, GetCreditGrantsInput, CreditsBalanceSummaryFragment, CreditBalanceSummaryInput } from '@stigg/api-client-js/src/generated/sdk';
export interface StiggEntitlementAPI {
    getBooleanEntitlement: (params: GetBooleanEntitlement) => Promise<BooleanEntitlement>;
    getNumericEntitlement: (params: GetNumericEntitlement) => Promise<NumericEntitlement>;
    getMeteredEntitlement: (params: GetMeteredEntitlement) => Promise<MeteredEntitlement>;
    getEnumEntitlement: (params: GetEnumEntitlement) => Promise<EnumEntitlement>;
    getEntitlement: (params: GetEntitlement) => Promise<Entitlement>;
    reportUsage: (params: ReportUsage) => Promise<ReportUsageAck>;
    reportUsageBulk: (params: ReportUsageBulk) => Promise<ReportUsageAck[]>;
    reportEvent: (params: ReportEvent | ReportEvent[]) => Promise<void>;
    addListener: <K extends EventNames>(eventName: K, callback: Events[K]) => void;
}
export interface StiggManagementAPI {
    provisionCustomer: (params: ProvisionCustomer) => Promise<ProvisionedCustomer>;
    /** @deprecated use {@link provisionCustomer} instead to create both customer and subscription in single operation. See {@link provisionCustomer} for more info. */
    createCustomer: (params: CreateCustomer) => Promise<Customer>;
    updateCustomer: (params: UpdateCustomer) => Promise<Customer>;
    detachCustomerPaymentMethod: (customerId: string) => Promise<Customer>;
    getCustomer: (customerId: string) => Promise<FullCustomer>;
    archiveCustomer: (customerId: string) => Promise<string>;
    unarchiveCustomer: (customerId: string) => Promise<Customer>;
    importCustomer: (params: ImportCustomer) => Promise<Customer>;
    importCustomerBulk: (params: ImportCustomerBulk) => Promise<void>;
    importSubscriptionBulk: (params: ImportSubscriptionBulk) => Promise<void>;
    updateSubscription: (updateSubscription: UpdateSubscription) => Promise<Subscription>;
    cancelSubscription: (cancelSubscription: CancelSubscription) => Promise<Subscription>;
    cancelSubscriptionScheduledUpdates: (cancelSubscriptionScheduledUpdates: CancelSubscriptionScheduledUpdates) => Promise<{
        subscriptionId: string;
    }>;
    provisionSubscription: (provisionSubscription: ProvisionSubscription) => Promise<ProvisionSubscriptionResult>;
    /** @deprecated use {@link provisionSubscription} instead to create subscription or checkout session according to customer and subscription payment requirements. See {@link provisionSubscription} for more info. */
    createSubscription: (createSubscription: CreateSubscription) => Promise<Subscription>;
    applySubscription: (params: ApplySubscription) => Promise<ApplySubscriptionResults>;
    getPaywall(params?: GetPaywall): Promise<Paywall>;
    getCoupons(): Promise<Coupon[]>;
    getActiveSubscriptions(params: GetActiveSubscriptions): Promise<FullSubscription[]>;
    getActiveSubscriptionsList(params: GetActiveSubscriptions): Promise<SlimSubscriptionFragmentV2Fragment[]>;
    getSubscriptions(params: GetSubscriptionsParams): Promise<GetSubscriptionsResult>;
    getSubscription(params: GetSubscription): Promise<FullSubscription>;
    getProducts(): Promise<Product[]>;
    estimateSubscription(estimateSubscription: EstimateSubscription): Promise<SubscriptionPreview>;
    estimateSubscriptionUpdate(estimateSubscriptionUpdate: EstimateSubscriptionUpdate): Promise<SubscriptionPreview>;
    previewNextInvoice(previewNextInvoice: PreviewNextInvoice): Promise<SubscriptionInvoicePreviewFragment>;
    previewSubscription(previewSubscription: PreviewSubscription): Promise<SubscriptionPreviewV2>;
    transferSubscription(input: TransferSubscriptionInput): Promise<Subscription>;
    transferSubscriptionToResource(input: TransferSubscriptionToResourceInput): Promise<Subscription>;
    delegateSubscriptionToCustomer(input: DelegateSubscriptionToCustomerInput): Promise<Subscription>;
    grantPromotionalEntitlements(input: GrantPromotionalEntitlementsInput): Promise<PromotionalEntitlementFragment[]>;
    revokePromotionalEntitlements(input: RevokePromotionalEntitlementInput): Promise<{
        id: string;
    }>;
    getCustomerStatistics(customerId: string): Promise<CustomerStatisticsModel>;
    getUsageHistoryV2(input: UsageHistoryV2Input): Promise<UsageHistoryV2Fragment>;
    getCreditBalance(input: CreditBalanceSummaryInput): Promise<CreditsBalanceSummaryFragment>;
    getCreditGrants(input: GetCreditGrantsInput): Promise<CreditGrantFragment[]>;
    grantCredits(input: CreditGrantInput): Promise<CreditGrantFragment | undefined>;
}
/**
 * Stigg Node.js SDK client
 */
export declare class Stigg implements StiggEntitlementAPI, StiggManagementAPI {
    private readonly config;
    private readonly entitlementsService;
    private readonly loggerService;
    private readonly managementApi;
    private readonly sdkConfigurationApi;
    private readonly eventEmitter;
    private readonly modelMapper;
    private readonly initializationStateTracker;
    private readonly errorHandler;
    private constructor();
    waitForInitialization(): Promise<Stigg>;
    /**
     * Add an event listener
     * @param eventName - The event to listen for ('entitlementsUpdated', 'usageUpdated', 'packagePublished', 'cacheHit', 'cacheMiss')
     * @param listener - The callback function to be called when the event occurs
     */
    addListener<K extends EventNames>(eventName: K, listener: Events[K]): void;
    /**
     * Remove an event listener
     * @param eventName - The event to stop listening for
     * @param listener - The callback function to remove
     */
    removeListener<K extends EventNames>(eventName: K, listener: Events[K]): void;
    /**
     * Initialize an instance of the Stigg SDK client.
     * @param {ClientConfiguration} configuration - client configuration object provided by the consumer.
     * @returns {Stigg} stigg SDK instance.
     */
    static initialize(configuration: ClientConfiguration): Stigg;
    /**
     * Discards all network connections, background tasks, and other resources held by the client.
     *
     * Do not attempt to use the client after calling this method.
     */
    close(): void;
    private static initializeStiggInstance;
    private initializeSdk;
    /**
     * Get boolean entitlement of feature for a customer
     *
     * @param {string} customerId
     * @param {string} resourceId
     * @param {string} featureId
     * @param {BooleanEntitlementOptions} options
     * @return {BooleanEntitlement} boolean entitlement.
     */
    getBooleanEntitlement({ customerId, featureId, resourceId, options, }: GetBooleanEntitlement): Promise<BooleanEntitlement>;
    /**
     * Get numeric entitlement of feature for a customer
     * @param {string} customerId
     * @param {string} resourceId
     * @param {string} featureId
     * @param {NumericEntitlementOptions} options
     * @return {NumericEntitlement} numeric entitlement
     */
    getNumericEntitlement({ customerId, featureId, resourceId, options, }: GetNumericEntitlement): Promise<NumericEntitlement>;
    /**
     * Get metered entitlement of feature for a customer
     * @param {string} customerId
     * @param {string} resourceId
     * @param {string} featureId
     * @param {MeteredEntitlementOptions} options
     * @return {MeteredEntitlement} metered entitlement
     */
    getMeteredEntitlement({ customerId, featureId, resourceId, options, }: GetMeteredEntitlement): Promise<MeteredEntitlement>;
    /**
     * Get enum entitlement of feature for a customer
     * @param {string} customerId
     * @param {string} resourceId
     * @param {string} featureId
     * @param {EnumEntitlementOptions} options
     * @return {EnumEntitlement} enum entitlement
     */
    getEnumEntitlement({ customerId, featureId, resourceId, options, }: GetEnumEntitlement): Promise<EnumEntitlement>;
    /**
     * Get generic entitlement of feature for a customer
     * @param {string} customerId
     * @param {string} resourceId
     * @param {string} featureId
     * @param {EntitlementOptions} options
     * @return {Entitlement} generic entitlement
     */
    getEntitlement({ customerId, featureId, resourceId, options }: GetEntitlement): Promise<Entitlement>;
    /**
     * Get entitlements per user
     * @param {string} customerId
     * @param {string} resourceId
     */
    getEntitlements(customerId: string, resourceId?: string): Promise<Entitlement[]>;
    /**
     * Report usage event
     */
    reportEvent(events: ReportEvent | ReportEvent[]): Promise<void>;
    /**
     * Report usage for metered entitlement
     * @param customerId
     * @param resourceId
     * @param featureId
     * @param value - the reported usage value, can be either positive or negative value
     */
    reportUsage({ customerId, resourceId, featureId, value, updateBehavior, createdAt, dimensions, }: ReportUsage): Promise<ReportUsageAck>;
    /**
     * Report bulk of usages for metered entitlement
     * @param usages - array of usages to report
     */
    reportUsageBulk({ usages }: ReportUsageBulk): Promise<ReportUsageAck[]>;
    importCustomerBulk({ customers }: ImportCustomerBulk): Promise<void>;
    /**
     * Import a Customer from billing integration. Private information such as email and name are not imported and needs
     * to be sent in order to be persisted in Stigg. Active billing integration is required for this functionality.
     * @return {Promise<Customer>} Newly created customer. Throw exception on errors.
     * @param billingId - the id of the customer in the billing system.
     * @param customerId - optional customer id, if not provided a random one will be generated.
     * @param email - optional customer email.
     * @param name - optional customer name.
     */
    importCustomer({ billingId, customerId, email, name, metadata, }: Omit<ImportCustomer, 'updatedAt'>): Promise<Customer>;
    importSubscriptionBulk({ subscriptions }: ImportSubscriptionBulk): Promise<void>;
    /**
     * Create a Customer and its first subscription
     * @return {Promise<Customer>} Newly created customer and subscription. Throw exception on errors.
     * @param customerId - optional customer id, if not provided a random one will be generated.
     * @param email - optional customer email
     * @param name - optional customer name
     * @param billingInfo - optional billing info
     * @param couponId - optional coupon
     * @param metadata - optional metadata
     * @param subscriptionParams - first subscription to create for the customer (pass null to skip subscription creation)
     * @param excludeFromExperiment - flag to exclude the customer from experiment (if there is one in progress)
     */
    provisionCustomer({ customerId, email, name, billingInfo, metadata, couponId, subscriptionParams, excludeFromExperiment, billingId, salesforceId, }: ProvisionCustomer): Promise<ProvisionedCustomer>;
    /**
     * Provision a Subscription.
     * @return {Promise<ProvisionSubscriptionResult>} Provision subscription result. Throw exception on errors.
     * @param provisionSubscription
     */
    provisionSubscription(provisionSubscription: ProvisionSubscription): Promise<ProvisionSubscriptionResult>;
    /**
     * Fetch customer usage history of a feature.
     * @return {Promise<UsageHistoryPoint[]>} Array of usage history as data points.
     * @param fetchUsageHistory
     *
     * @deprecated use {@link getUsageHistoryV2} instead.
     */
    fetchUsageHistory(fetchUsageHistory: FetchUsageHistory): Promise<UsageHistoryPoint[] | undefined>;
    /**
     * Get customer usage history of a feature.
     */
    getUsageHistoryV2(input: UsageHistoryV2Input): Promise<UsageHistoryV2Fragment>;
    /**
     * Create a Customer.
     * @return {Promise<Customer>} Newly created customer. Throw exception on errors.
     * @param customerId - optional customer id, if not provided a random one will be generated.
     * @param email - optional customer email
     * @param name - optional customer name
     * @param billingInfo - optional billing info
     * @param couponId - optional coupon
     * @param metadata - optional metadata
     *
     * @deprecated use {@link provisionCustomer} instead to create both customer and subscription in single operation. See {@link provisionCustomer} for more info.
     */
    createCustomer(input: CreateCustomer): Promise<Customer>;
    /**
     * Update a Customer.
     * @return {Promise<Customer>} Updated customer. Throw exception on errors.
     * @param customerId - customer id
     * @param email - optional customer email
     * @param name - optional customer name
     * @param billingId - optional billing ID
     * @param billingInfo - optional billing info
     * @param metadata - optional metadata
     */
    updateCustomer({ customerId, email, name, billingId, billingInfo, metadata, couponId, shouldWaitSync, salesforceId, }: UpdateCustomer): Promise<Customer>;
    /**
     * Detach customer's payment method.
     * @return {Promise<Customer>} Updated customer. Throw exception on errors.
     * @param customerId - customer id
     * */
    detachCustomerPaymentMethod(customerId: string): Promise<Customer>;
    /**
     * Get a Customer.
     * @return {Promise<FullCustomer>} Full customer details.
     * @param customerId - customer id
     */
    getCustomer(customerId: string): Promise<FullCustomer>;
    /**
     * Get Customer Statistics.
     * @return {Promise<CustomerStatisticsModel>} customer statistics.
     * @param customerId - customer id
     */
    getCustomerStatistics(customerId: string): Promise<CustomerStatisticsModel>;
    archiveCustomer(customerId: string): Promise<string>;
    getCreditBalance(input: CreditBalanceSummaryInput): Promise<CreditsBalanceSummaryFragment>;
    grantCredits(input: CreditGrantInput): Promise<CreditGrantFragment | undefined>;
    getCreditGrants(input: GetCreditGrantsInput): Promise<CreditGrantFragment[]>;
    unarchiveCustomer(customerId: string): Promise<Customer>;
    getSubscriptions(params?: GetSubscriptionsParams): Promise<GetSubscriptionsResult>;
    /**
     * Get customer's active subscriptions.
     * @return {Promise<FullSubscription[]>} List of active subscriptions.
     * @param customerId - customer id
     * @param resourceId - optional resource id, if not provided global resources will be fetched.
     */
    getActiveSubscriptions({ customerId, resourceId }: GetActiveSubscriptions): Promise<FullSubscription[]>;
    /**
     * @description Get customer's active subscriptions, for extended subscription data use {@link getSubscription}
     * @return {Promise<SlimSubscriptionFragmentV2Fragment[]>} List of active subscriptions
     * @param customerId - customer id
     * @param resourceId - optional resource id, if not provided global resources will be fetched.
     */
    getActiveSubscriptionsList({ customerId, resourceId, }: GetActiveSubscriptions): Promise<SlimSubscriptionFragmentV2Fragment[]>;
    /**
     * Get subscription
     * @return {Promise<FullSubscription>} the subscription data
     * @param subscriptionId - subscription id
     */
    getSubscription({ subscriptionId }: GetSubscription): Promise<FullSubscription>;
    /**
     * Create a Subscription
     * @return {Promise<Subscription>} Newly created subscription. Throw exception on errors.
     * @param {CreateSubscription} createSubscription
     * @deprecated use {@link provisionSubscription} instead to create subscription or checkout session according to customer and subscription payment requirements. See {@link provisionSubscription} for more info.
     */
    createSubscription(createSubscription: CreateSubscription): Promise<Subscription>;
    /**
     * Update a Subscription
     * @return {Promise<Subscription>} updated subscription. Throw exception on errors.
     * @param {UpdateSubscription} updateSubscription
     */
    updateSubscription(updateSubscription: UpdateSubscription): Promise<Subscription>;
    /**
     * Apply subscription changes for a customer
     * Update\Provision a subscription for a customer according to the given subscription input
     * @param {ApplySubscription} parameters
     * @returns {Promise<ApplySubscriptionResults>}
     */
    applySubscription(applySubscriptionInput: ApplySubscription): Promise<ApplySubscriptionResults>;
    /**
     * Create a Subscription
     * @return {Promise<Subscription>} Canceled subscription. Throw exception on errors.
     * @param cancelSubscription
     */
    cancelSubscription(cancelSubscription: CancelSubscription): Promise<Subscription>;
    /**
     * Get the paywall data
     *
     * @returns {Promise<Paywall>}
     */
    getPaywall({ productId, customerId, resourceId, billingCountryCode, fetchAllCountriesPrices, includeHiddenPlans, }?: GetPaywall): Promise<Paywall>;
    /**
     * Get a list of coupons
     *
     * @returns {Promise<Coupon[]>}
     */
    getCoupons(): Promise<Coupon[]>;
    /**
     * Get a list of products
     *
     * @returns {Promise<Product[]>}
     */
    getProducts(): Promise<Product[]>;
    /**
     * Estimate subscription
     * @return {Promise<SubscriptionPreview>} Preview of the subscription.
     * @param {EstimateSubscription} estimateSubscription
     */
    estimateSubscription(estimateSubscription: EstimateSubscription): Promise<SubscriptionPreview>;
    /**
     * Estimate subscription update
     * @return {Promise<SubscriptionPreview>} Preview of the subscription.
     * @param {EstimateSubscriptionUpdate} estimateSubscriptionUpdate
     */
    estimateSubscriptionUpdate(estimateSubscriptionUpdate: EstimateSubscriptionUpdate): Promise<SubscriptionPreview>;
    /**
     * Preview subscription provisioning\updates
     * @return {Promise<SubscriptionPreviewV2>} Preview of the subscription.
     * @param {PreviewSubscription} previewSubscription
     */
    previewSubscription(previewSubscription: PreviewSubscription): Promise<SubscriptionPreviewV2>;
    /**
     * Preview the subscription next invoice
     * @return {Promise<SubscriptionInvoicePreviewFragment>} Preview of the next invoice.
     * @param {PreviewNextInvoice} previewNextInvoice
     */
    previewNextInvoice(previewNextInvoice: PreviewNextInvoice): Promise<SubscriptionInvoicePreviewFragment>;
    /**
     * Cancel a subscription scheduled updates
     * @return {Promise<string>} The subscription id
     * @param {CancelSubscriptionScheduledUpdates} cancelSubscriptionScheduledUpdates
     */
    cancelSubscriptionScheduledUpdates(cancelSubscriptionScheduledUpdates: CancelSubscriptionScheduledUpdates): Promise<{
        subscriptionId: string;
    }>;
    /**
     * Migrate subscription to latest plan and addons version and pricing.
     * using {@link SubscriptionMigrationTime.EndOfBillingPeriod} is possible only if Stripe integration is enabled and will
     * migrate the subscription in the end of the current billing period. Using Immediate will perform the migration
     * immediately. Default, migration will happen immediately.
     * @return {Promise<string>} The subscription id
     * @param {MigrateSubscriptionToLatest} migrateSubscriptionToLatest
     */
    migrateSubscriptionToLatest(migrateSubscriptionToLatest: MigrateSubscriptionToLatest): Promise<{
        subscriptionId: string;
    }>;
    /**
     * @deprecated use {@link transferSubscriptionToResource} instead
     * Transfer paid subscription from sourceResourceId to destinationResourceId.
     * sourceResourceId must have a paid active subscription.
     * destinationResourceId must have a free active subscription.
     * @return {Promise<subscription>} The subscription connected to destinationResource.
     * @param {TransferSubscriptionInput} input
     */
    transferSubscription(input: TransferSubscriptionInput): Promise<Subscription>;
    /**
     * Transfers a subscription to a different resource.
     * @return {Promise<subscription>} The subscription connected to destinationResource.
     * @param {TransferSubscriptionInput} input
     */
    transferSubscriptionToResource(input: TransferSubscriptionToResourceInput): Promise<Subscription>;
    /**
     * Delegates a subscription to a different customer (the paying customer of the subscription will not change)
     * @return {Promise<subscription>} The subscription connected to destinationResource.
     * @param {DelegateSubscriptionToCustomerInput} input
     */
    delegateSubscriptionToCustomer(input: DelegateSubscriptionToCustomerInput): Promise<Subscription>;
    grantPromotionalEntitlements(input: GrantPromotionalEntitlementsInput): Promise<PromotionalEntitlementFragment[]>;
    revokePromotionalEntitlements(input: RevokePromotionalEntitlementInput): Promise<{
        id: string;
    }>;
    /**
     * Reload entitlements of a customer or customer resource.
     * Note: this method skips the Edge API, so use it only when you need "read-after-write" consistency after entitlements presumably have changed.
     * @param {string} customerId
     * @param {string} resourceId
     */
    reloadEntitlements(customerId: string, resourceId?: string): Promise<{
        entitledEntityExists: boolean;
    }>;
}
