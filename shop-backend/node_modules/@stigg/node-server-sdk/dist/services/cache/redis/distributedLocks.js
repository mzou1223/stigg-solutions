"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DistributedLocks = void 0;
const redlock_1 = __importStar(require("redlock"));
const LOCK_DURATION = 5000;
const LOCK_NO_RETRY_SETTINGS = { retryCount: 0 };
class DistributedLocks {
    constructor(redisClient, loggerService, cacheInstrumentation) {
        this.redisClient = redisClient;
        this.loggerService = loggerService;
        this.redlock = new redlock_1.default([redisClient]);
        this.redlock.on('clientError', (err) => {
            this.loggerService.error('Redis client error: ', err);
            cacheInstrumentation.trackRedisClientError({ error: err, clientName: 'redlock' });
        });
    }
    async usingSingleAttempt(lockKey, handler) {
        return this.redlock.using([lockKey], LOCK_DURATION, LOCK_NO_RETRY_SETTINGS, handler);
    }
    async using(lockKey, handler) {
        try {
            // first - try to acquire the lock without retrying in order to identify
            // cases that the redis instance is read-only
            return await this.usingSingleAttempt(lockKey, handler);
        }
        catch (error) {
            // if first attempt failed on redis instance is read-only,
            // then we don't want to wait for it
            if (await this.isReadOnlyReplicaError(error)) {
                throw new Error(`Redis is read-only. Cannot acquire distributed lock`);
            }
            // if the lock is acquired, now wait for it to be available
            if (this.isLockTakenByAnotherClientError(error)) {
                return this.redlock.using([lockKey], LOCK_DURATION, handler);
            }
            throw error;
        }
    }
    isLockTakenByAnotherClientError(err) {
        return err instanceof redlock_1.ExecutionError && err.message.includes('unable to achieve a quorum');
    }
    async isReadOnlyReplicaError(err) {
        var _a;
        if (!(err instanceof redlock_1.ExecutionError)) {
            return false;
        }
        const { votesAgainst } = await err.attempts[0];
        const message = (_a = votesAgainst.get(this.redisClient)) === null || _a === void 0 ? void 0 : _a.message;
        return message && message.includes(`You can't write against a read only replica`);
    }
    async cleanup() {
        await this.redlock.quit();
    }
}
exports.DistributedLocks = DistributedLocks;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlzdHJpYnV0ZWRMb2Nrcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9zZXJ2aWNlcy9jYWNoZS9yZWRpcy9kaXN0cmlidXRlZExvY2tzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtREFBNEQ7QUFLNUQsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDO0FBQzNCLE1BQU0sc0JBQXNCLEdBQXNCLEVBQUUsVUFBVSxFQUFFLENBQUMsRUFBRSxDQUFDO0FBRXBFLE1BQWEsZ0JBQWdCO0lBRzNCLFlBQ21CLFdBQWtCLEVBQ2xCLGFBQTRCLEVBQzdDLG9CQUEwQztRQUZ6QixnQkFBVyxHQUFYLFdBQVcsQ0FBTztRQUNsQixrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQUc3QyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksaUJBQU8sQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7UUFFMUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDckMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsc0JBQXNCLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDdEQsb0JBQW9CLENBQUMscUJBQXFCLENBQUMsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDO1FBQ3BGLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELEtBQUssQ0FBQyxrQkFBa0IsQ0FBSSxPQUFlLEVBQUUsT0FBeUI7UUFDcEUsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLGFBQWEsRUFBRSxzQkFBc0IsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN2RixDQUFDO0lBRUQsS0FBSyxDQUFDLEtBQUssQ0FBSSxPQUFlLEVBQUUsT0FBeUI7UUFDdkQsSUFBSTtZQUNGLHdFQUF3RTtZQUN4RSw2Q0FBNkM7WUFDN0MsT0FBTyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDeEQ7UUFBQyxPQUFPLEtBQUssRUFBRTtZQUNkLDBEQUEwRDtZQUMxRCxvQ0FBb0M7WUFDcEMsSUFBSSxNQUFNLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDNUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO2FBQ3hFO1lBRUQsMkRBQTJEO1lBQzNELElBQUksSUFBSSxDQUFDLCtCQUErQixDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUMvQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBQzlEO1lBRUQsTUFBTSxLQUFLLENBQUM7U0FDYjtJQUNILENBQUM7SUFFRCwrQkFBK0IsQ0FBQyxHQUFRO1FBQ3RDLE9BQU8sR0FBRyxZQUFZLHdCQUFjLElBQUksR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsNEJBQTRCLENBQUMsQ0FBQztJQUM3RixDQUFDO0lBRUQsS0FBSyxDQUFDLHNCQUFzQixDQUFDLEdBQVE7O1FBQ25DLElBQUksQ0FBQyxDQUFDLEdBQUcsWUFBWSx3QkFBYyxDQUFDLEVBQUU7WUFDcEMsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUNELE1BQU0sRUFBRSxZQUFZLEVBQUUsR0FBRyxNQUFNLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0MsTUFBTSxPQUFPLEdBQUcsTUFBQSxZQUFZLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsMENBQUUsT0FBTyxDQUFDO1FBQzVELE9BQU8sT0FBTyxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsNkNBQTZDLENBQUMsQ0FBQztJQUNwRixDQUFDO0lBRUQsS0FBSyxDQUFDLE9BQU87UUFDWCxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDNUIsQ0FBQztDQUNGO0FBekRELDRDQXlEQyJ9