"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedisSingleExecutionService = void 0;
const cacheKeysHelpers_1 = require("../../../utils/cacheKeysHelpers");
const lodash_1 = require("lodash");
const ReuseOngoingExecution_1 = require("../../../utils/decorators/ReuseOngoingExecution");
const RedisSingleExecution_utils_1 = require("./RedisSingleExecution.utils");
/**
 * This class manages the execution of operations in a distributed environment (using Redis).
 * It ensures that an operation is executed only once across multiple processes, and handles notifications between processes.
 */
class RedisSingleExecutionService {
    constructor(operationName, environmentPrefix, 
    // This timeout duration should be slightly longer than the total
    // elapsed time of all retry attempts for the API data fetch request.
    notificationTimeoutMs, redisClient, distributedLocks, loggerService, cacheInstrumentation) {
        this.operationName = operationName;
        this.environmentPrefix = environmentPrefix;
        this.notificationTimeoutMs = notificationTimeoutMs;
        this.redisClient = redisClient;
        this.distributedLocks = distributedLocks;
        this.loggerService = loggerService;
        this.cacheInstrumentation = cacheInstrumentation;
        this.pendingNotifications = new Map();
        this.subscribeClient = redisClient.duplicate();
        this.subscribeClient.on('error', (err) => {
            this.loggerService.error('Redis subscribe client error: ', err);
            this.cacheInstrumentation.trackRedisClientError({ error: err, clientName: 'subscribe' });
        });
        this.subscribeClient.on('connect', () => this.loggerService.log('Redis subscribe client connected!'));
        this.subscribeClient.on('close', () => this.loggerService.log('Redis subscribe client disconnected!'));
        this.subscribeClient.on('message', this.onEventNotification.bind(this));
    }
    async executeOnceAcrossMultipleProcesses(context) {
        const { customerId, resourceId, reloadFromApi } = context;
        const notificationContext = await this.subscribeForNotification(context);
        const { notify, cancelNotificationSubscription } = notificationContext;
        const lockKey = (0, cacheKeysHelpers_1.buildLockKey)(this.environmentPrefix, customerId, resourceId, this.operationName);
        try {
            const response = await this.distributedLocks.usingSingleAttempt(lockKey, async () => {
                // At this point, this process has the responsibility to fetch data from
                // the API, cache it, and then notify other clients to continue their execution.
                // no need to listen anymore as this process is the one who will notify later
                await cancelNotificationSubscription();
                // perform the operation
                return reloadFromApi();
            });
            // notify other clients that the data is ready
            await notify();
            return response;
        }
        catch (err) {
            if (await this.distributedLocks.isReadOnlyReplicaError(err)) {
                throw new Error(`Redis is read-only. Cannot ${this.operationName}`);
            }
            if (this.distributedLocks.isLockTakenByAnotherClientError(err)) {
                // At this point, another process is responsible for fetching data from
                // the API and caching it. This process waits until the data fetching and
                // caching is complete, then retrieves the data from the cache.
                return this.waitForNotificationAndLoadFromCache(context, notificationContext);
            }
            await notify(err.message);
            throw err;
        }
    }
    async waitForNotificationAndLoadFromCache({ customerId, resourceId, reloadFromApi, loadFromCache }, { cancelNotificationSubscription, notificationPromise }) {
        try {
            await notificationPromise;
            return loadFromCache();
        }
        catch (err) {
            await cancelNotificationSubscription();
            if (err instanceof RedisSingleExecution_utils_1.TimeoutError) {
                this.loggerService.error(`Timeout while waiting for notification via Redis for ${this.operationName} - refetching from API`, {
                    customerId,
                    resourceId,
                });
                return reloadFromApi();
            }
            throw err;
        }
    }
    async subscribeForNotification(context) {
        const { customerId, resourceId } = context;
        const notificationChannel = (0, lodash_1.compact)([this.environmentPrefix, this.operationName, customerId, resourceId]).join(':');
        const existingCallbackList = this.pendingNotifications.get(notificationChannel);
        let callbackList;
        if (existingCallbackList) {
            callbackList = existingCallbackList;
        }
        else {
            callbackList = [];
            this.pendingNotifications.set(notificationChannel, callbackList);
            await this.subscribeClient.subscribe(notificationChannel);
        }
        const { notificationPromise, cancelNotificationSubscription } = this.createNotificationPromise(notificationChannel, callbackList);
        const notify = async (error) => {
            try {
                const payload = { error };
                this.loggerService.debug(`Publish notification`, { payload });
                await this.redisClient.publish(notificationChannel, JSON.stringify(payload));
            }
            catch (err) {
                this.loggerService.error('Error while publishing notification', err);
            }
        };
        return { notificationPromise, notify, cancelNotificationSubscription };
    }
    createNotificationPromise(notificationChannel, callbackList) {
        let resolveNotificationPromise;
        let timeoutId;
        const notificationPromise = new Promise((resolve, reject) => {
            resolveNotificationPromise = resolve;
            timeoutId = setTimeout(() => reject(new RedisSingleExecution_utils_1.TimeoutError()), this.notificationTimeoutMs);
            callbackList.push((payload) => {
                clearTimeout(timeoutId);
                if (payload.error) {
                    reject(new RedisSingleExecution_utils_1.RemoteExecutionError(payload.error));
                }
                else {
                    resolve();
                }
            });
        });
        const cancelNotificationSubscription = async () => {
            clearTimeout(timeoutId);
            resolveNotificationPromise();
            await this.unsubscribeChannel(notificationChannel);
        };
        // The promise will be awaited at a later stage. If it gets rejected before
        // that, Node.js will issue an UnhandledPromiseRejectionWarning. To prevent
        // this, we create an orphan promise chain.
        notificationPromise.catch(() => {
            /* ignore */
        });
        return {
            notificationPromise,
            cancelNotificationSubscription,
        };
    }
    async unsubscribeChannel(channel) {
        await this.subscribeClient.unsubscribe(channel);
        const list = this.pendingNotifications.get(channel);
        if (!list) {
            return [];
        }
        this.pendingNotifications.delete(channel);
        return list;
    }
    async onEventNotification(channel, message) {
        try {
            const payload = JSON.parse(message);
            this.loggerService.debug(`Received notification`, { payload });
            const list = await this.unsubscribeChannel(channel);
            for (const callback of list) {
                try {
                    callback(payload);
                }
                catch (err) {
                    this.loggerService.error('Error while executing notification callback', err);
                }
            }
        }
        catch (err) {
            this.loggerService.error('Error while handling notification event', err);
        }
    }
    async cleanup() {
        await this.subscribeClient.quit();
        this.pendingNotifications.clear();
    }
}
__decorate([
    (0, ReuseOngoingExecution_1.ReuseOngoingExecution)(({ customerId, resourceId }) => (0, lodash_1.compact)([customerId, resourceId]).join(':'))
], RedisSingleExecutionService.prototype, "executeOnceAcrossMultipleProcesses", null);
exports.RedisSingleExecutionService = RedisSingleExecutionService;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVkaXNTaW5nbGVFeGVjdXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvc2VydmljZXMvY2FjaGUvUmVkaXNTaW5nbGVFeGVjdXRpb25TZXJ2aWNlL1JlZGlzU2luZ2xlRXhlY3V0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUVBLHNFQUErRDtBQUMvRCxtQ0FBaUM7QUFDakMsMkZBQXdGO0FBQ3hGLDZFQU9zQztBQUl0Qzs7O0dBR0c7QUFDSCxNQUFhLDJCQUEyQjtJQUl0QyxZQUNtQixhQUFxQixFQUNyQixpQkFBeUI7SUFDMUMsaUVBQWlFO0lBQ2pFLHFFQUFxRTtJQUNwRCxxQkFBNkIsRUFDN0IsV0FBa0IsRUFDbEIsZ0JBQWtDLEVBQ2xDLGFBQTRCLEVBQzVCLG9CQUEwQztRQVIxQyxrQkFBYSxHQUFiLGFBQWEsQ0FBUTtRQUNyQixzQkFBaUIsR0FBakIsaUJBQWlCLENBQVE7UUFHekIsMEJBQXFCLEdBQXJCLHFCQUFxQixDQUFRO1FBQzdCLGdCQUFXLEdBQVgsV0FBVyxDQUFPO1FBQ2xCLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7UUFDbEMsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDNUIseUJBQW9CLEdBQXBCLG9CQUFvQixDQUFzQjtRQVg1Qyx5QkFBb0IsR0FBRyxJQUFJLEdBQUcsRUFBNkIsQ0FBQztRQWEzRSxJQUFJLENBQUMsZUFBZSxHQUFHLFdBQVcsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUMvQyxJQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUN2QyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxnQ0FBZ0MsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUNoRSxJQUFJLENBQUMsb0JBQW9CLENBQUMscUJBQXFCLENBQUMsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVB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