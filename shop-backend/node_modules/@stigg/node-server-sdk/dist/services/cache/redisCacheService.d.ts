import { CacheService, UpdateFeatureUsagePayload } from './cacheService';
import CachedEntitlement from './cachedEntitlement';
import { LoggerService } from '../loggerService';
import { ClientConfiguration } from '../../configuration';
import { RedisSingleExecutionService } from './RedisSingleExecutionService';
import { EntitlementResponse, EntitlementsResponse } from '../entitlementsService.utils';
import { CacheInstrumentation } from '../cacheInstrumentation';
export declare class RedisCacheService implements CacheService {
    private readonly loggerService;
    private readonly cacheInstrumentation;
    private readonly environmentPrefix;
    private readonly ttl;
    private readonly redisClient;
    private readonly distributedLocks;
    readonly distributedRefetchEntitlementsService: RedisSingleExecutionService | undefined;
    constructor(options: Required<ClientConfiguration>, loggerService: LoggerService, cacheInstrumentation: CacheInstrumentation);
    /**
     * Waits for Redis client to be ready for use.
     * Returns immediately if already connected, otherwise waits for 'ready' or 'error' events
     * with a timeout fallback to prevent indefinite waiting.
     */
    waitForInitialization(): Promise<void>;
    isClientConnected(): boolean;
    updateFeatureUsage(params: UpdateFeatureUsagePayload): Promise<boolean>;
    private getFeatureUsageItemToUpdate;
    setCustomer(customerId: string, customerEntitlements: Map<string, CachedEntitlement>, resourceId: string | undefined, entitlementsTimestamp: number, featureIdToUsageTimestamp: Map<string, number>): Promise<void>;
    private extractFeatureUsagesToUpdate;
    getCustomerEntitlementsWithoutUsage(customerId: string, resourceId: string | undefined): Promise<EntitlementsResponse>;
    private isGlobalCustomerMissingInCache;
    getCustomerEntitlements(customerId: string, resourceId: string | undefined): Promise<EntitlementsResponse>;
    private getFeaturesUsage;
    clearCache(): void | Promise<void>;
    private updateCacheItems;
    private getKeysLatestTimestamp;
    private parseTimestamp;
    cleanup(): Promise<void>;
    getCustomerEntitlement(featureId: string, customerId: string, resourceId: string | undefined): Promise<EntitlementResponse>;
    private mergeEntitlementWithUsage;
    private executeSafely;
}
