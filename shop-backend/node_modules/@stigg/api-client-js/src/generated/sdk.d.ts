import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
export declare type Maybe<T> = T | null;
export declare type InputMaybe<T> = Maybe<T>;
export declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export declare type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export declare type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    /** Cursor for paging through collections */
    ConnectionCursor: any;
    /** A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format. */
    DateTime: any;
    /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
    JSON: any;
    /** A field whose value is a generic Universally Unique Identifier: https://en.wikipedia.org/wiki/Universally_unique_identifier. */
    UUID: any;
};
/** DenyReason of get access policy */
export declare enum AccessDeniedReason {
    /** The customer has exceeded their usage budget for the feature. */
    BudgetExceeded = "BudgetExceeded",
    /** The customer is archived and no longer eligible for entitlements. */
    CustomerIsArchived = "CustomerIsArchived",
    /** The customer making the request could not be found. */
    CustomerNotFound = "CustomerNotFound",
    /** The resource associated with the customer could not be found. */
    CustomerResourceNotFound = "CustomerResourceNotFound",
    /** The requested feature does not exist or is not defined in the current environment. */
    FeatureNotFound = "FeatureNotFound",
    /** The requested entitlement type does not match the feature type */
    FeatureTypeMismatch = "FeatureTypeMismatch",
    /** The customer does not have enough credits to access the feature. */
    InsufficientCredits = "InsufficientCredits",
    /** The customer does not have any active subscription linked to the feature. */
    NoActiveSubscription = "NoActiveSubscription",
    /** The current subscription does not include entitlement to the requested feature. */
    NoFeatureEntitlementInSubscription = "NoFeatureEntitlementInSubscription",
    /** The customers usage request exceeds their entitled limit. */
    RequestedUsageExceedingLimit = "RequestedUsageExceedingLimit",
    /** The requested values do not match the expected values for the feature. */
    RequestedValuesMismatch = "RequestedValuesMismatch",
    /** Entitlement access was revoked */
    Revoked = "Revoked",
    /** The access denial occurred for an unknown or unexpected reason. */
    Unknown = "Unknown"
}
/** different methods to control how new users can join an account */
export declare enum AccountAccessMethod {
    /** when a user with the same email-domain as the account authorized domain is registered, it will be automatically added to this account (an accountEmailDomain need to be configured) */
    AuthorizedDomain = "AUTHORIZED_DOMAIN",
    /** new users can only be added to the account if they are invited */
    InviteOnly = "INVITE_ONLY",
    /** an identity provider will be used to provide new users access to this account (an accountEmailDomain need to be configured) */
    Sso = "SSO"
}
/** Account access role of the user */
export declare enum AccountAccessRole {
    /** User can view and manage environments they have been granted access to */
    Member = "MEMBER",
    /** User has full ownership and control over the account */
    Owner = "OWNER"
}
/** Account status */
export declare enum AccountStatus {
    /** The account is active and in use */
    Active = "ACTIVE",
    /** The account is blocked and cannot be used */
    Blocked = "BLOCKED"
}
export declare type AddCompatibleAddonsToPlanInput = {
    /** The id of the record. */
    id: Scalars['UUID'];
    /** The ids of the relations. */
    relationIds: Array<Scalars['UUID']>;
};
/** Archive addon input */
export declare type AddonArchiveInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Addon id */
    refId: Scalars['String'];
};
/** Query associated entities input */
export declare type AddonAssociatedEntitiesInput = {
    /** The unique identifier for the environment */
    environmentId: Scalars['String'];
    /** Addon refId */
    refId: Scalars['String'];
};
/** Input for creating an addon */
export declare type AddonCreateInput = {
    /** The additional meta data of the package */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** The AWS marketplace plan dimension of the package */
    awsMarketplacePlanDimension?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the entity in the billing provider */
    billingId?: InputMaybe<Scalars['String']>;
    /** List of addon ids this addon should be dependant on */
    dependencies?: InputMaybe<Array<Scalars['String']>>;
    /** The description of the package */
    description?: InputMaybe<Scalars['String']>;
    /** The display name of the package */
    displayName: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** List of hidden widgets of the package */
    hiddenFromWidgets?: InputMaybe<Array<WidgetType>>;
    /** The maximum quantity of this addon that can be added to a subscription */
    maxQuantity?: InputMaybe<Scalars['Float']>;
    /** The pricing type of the package */
    pricingType?: InputMaybe<PricingType>;
    /** The product id of the package */
    productId: Scalars['String'];
    /** The unique identifier for the entity */
    refId?: InputMaybe<Scalars['String']>;
    /** The status of the package */
    status?: InputMaybe<PackageStatus>;
};
export declare type AddonFilter = {
    and?: InputMaybe<Array<AddonFilter>>;
    billingId?: InputMaybe<StringFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    description?: InputMaybe<StringFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    isLatest?: InputMaybe<BooleanFieldComparison>;
    or?: InputMaybe<Array<AddonFilter>>;
    pricingType?: InputMaybe<PricingTypeFilterComparison>;
    productId?: InputMaybe<StringFieldComparison>;
    refId?: InputMaybe<StringFieldComparison>;
    status?: InputMaybe<PackageStatusFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
    versionNumber?: InputMaybe<IntFieldComparison>;
};
export declare type AddonSort = {
    direction: SortDirection;
    field: AddonSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum AddonSortFields {
    BillingId = "billingId",
    CreatedAt = "createdAt",
    Description = "description",
    DisplayName = "displayName",
    EnvironmentId = "environmentId",
    Id = "id",
    IsLatest = "isLatest",
    PricingType = "pricingType",
    ProductId = "productId",
    RefId = "refId",
    Status = "status",
    UpdatedAt = "updatedAt",
    VersionNumber = "versionNumber"
}
/** Un-archive addon input */
export declare type AddonUnArchiveInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Add-on ID to unarchive */
    id: Scalars['String'];
};
export declare type AddonUpdateInput = {
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    billingId?: InputMaybe<Scalars['String']>;
    /** List of addon ids this addon should be dependant on */
    dependencies?: InputMaybe<Array<Scalars['String']>>;
    description?: InputMaybe<Scalars['String']>;
    displayName?: InputMaybe<Scalars['String']>;
    hiddenFromWidgets?: InputMaybe<Array<WidgetType>>;
    id: Scalars['UUID'];
    /** The maximum quantity of this addon that can be added to a subscription */
    maxQuantity?: InputMaybe<Scalars['Float']>;
    status?: InputMaybe<PackageStatus>;
};
/** Customers address */
export declare type Address = {
    /** Address line 1 */
    addressLine1?: InputMaybe<Scalars['String']>;
    /** Address line 2 */
    addressLine2?: InputMaybe<Scalars['String']>;
    /** City */
    city?: InputMaybe<Scalars['String']>;
    /** Country */
    country?: InputMaybe<Scalars['String']>;
    /** Phone number */
    phoneNumber?: InputMaybe<Scalars['String']>;
    /** Postal code */
    postalCode?: InputMaybe<Scalars['String']>;
    /** State */
    state?: InputMaybe<Scalars['String']>;
};
/** Input parameters for aggregating events by customer */
export declare type AggregatedEventsByCustomerInput = {
    /** Meter aggregation */
    aggregation: MeterAggregation;
    /** Customer id */
    customerId?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId: Scalars['UUID'];
    /** List of event filters */
    filters: Array<MeterFilterDefinitionInput>;
};
/** Aggregation function */
export declare enum AggregationFunction {
    /** Average value */
    Avg = "AVG",
    /** Count of the values */
    Count = "COUNT",
    /** Maximum value */
    Max = "MAX",
    /** Minimum value */
    Min = "MIN",
    /** Sum of the values */
    Sum = "SUM",
    /** Unique values */
    Unique = "UNIQUE"
}
/** Alignment */
export declare enum Alignment {
    /** Align content to the horizontal center of the container. */
    Center = "CENTER",
    /** Align content to the left edge of the container. */
    Left = "LEFT",
    /** Align content to the right edge of the container. */
    Right = "RIGHT"
}
export declare type ApiKeyFilter = {
    and?: InputMaybe<Array<ApiKeyFilter>>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<ApiKeyFilter>>;
};
export declare type ApiKeySort = {
    direction: SortDirection;
    field: ApiKeySortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum ApiKeySortFields {
    Id = "id"
}
/** The type of API key */
export declare enum ApiKeyType {
    /** Client-side API key */
    Client = "CLIENT",
    /** Salesforce API key */
    Salesforce = "SALESFORCE",
    /** Server-side API key */
    Server = "SERVER",
    /** Workflow API key */
    Workflow = "WORKFLOW"
}
/** Apply subscription changes input */
export declare type ApplySubscriptionInput = {
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    addons?: InputMaybe<Array<SubscriptionAddonInput>>;
    /** Coupon input */
    appliedCoupon?: InputMaybe<SubscriptionCouponInput>;
    awaitPaymentConfirmation?: InputMaybe<Scalars['Boolean']>;
    billableFeatures?: InputMaybe<Array<BillableFeatureInput>>;
    billingCountryCode?: InputMaybe<Scalars['String']>;
    billingId?: InputMaybe<Scalars['String']>;
    billingInformation?: InputMaybe<SubscriptionBillingInfo>;
    billingPeriod?: InputMaybe<BillingPeriod>;
    /** Budget configuration */
    budget?: InputMaybe<BudgetConfigurationInput>;
    /** Customer ID */
    customerId: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The minimum spend configuration */
    minimumSpend?: InputMaybe<SubscriptionMinimumSpendValueInput>;
    /** Paying customer ID */
    payingCustomerId?: InputMaybe<Scalars['String']>;
    /** Subscription payment collection method */
    paymentCollectionMethod?: InputMaybe<PaymentCollectionMethod>;
    /** Payment method ID */
    paymentMethodId?: InputMaybe<Scalars['String']>;
    planId: Scalars['String'];
    /** Override the price of the subscription */
    priceOverrides?: InputMaybe<Array<PriceOverrideInput>>;
    promotionCode?: InputMaybe<Scalars['String']>;
    resourceId?: InputMaybe<Scalars['String']>;
    salesforceId?: InputMaybe<Scalars['String']>;
    scheduleStrategy?: InputMaybe<ScheduleStrategy>;
    /** Should skip trial */
    skipTrial?: InputMaybe<Scalars['Boolean']>;
    startDate?: InputMaybe<Scalars['DateTime']>;
    subscriptionEntitlements?: InputMaybe<Array<SubscriptionEntitlementInput>>;
    trialOverrideConfiguration?: InputMaybe<TrialOverrideConfigurationInput>;
    unitQuantity?: InputMaybe<Scalars['Float']>;
};
/** Archive a coupon input */
export declare type ArchiveCouponInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The unique identifier for the entity */
    refId: Scalars['String'];
};
export declare type ArchiveCustomerInput = {
    /** Customer slug */
    customerId: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
};
/** Input for archiving an environment */
export declare type ArchiveEnvironmentInput = {
    /** Unique identifier for the entity */
    id?: InputMaybe<Scalars['String']>;
    /** A unique identifier for the environment */
    slug?: InputMaybe<Scalars['String']>;
};
/** Input for archiving a feature group */
export declare type ArchiveFeatureGroupInput = {
    /** The unique identifier for the environment */
    environmentId: Scalars['UUID'];
    /** The feature group id */
    featureGroupId: Scalars['String'];
};
/** Input for archiving a feature */
export declare type ArchiveFeatureInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Unique identifier for the entity */
    id: Scalars['String'];
};
/** The input type for archiving a package group */
export declare type ArchivePackageGroup = {
    /** The unique identifier for the environment */
    environmentId: Scalars['String'];
    /** The id of the package group */
    packageGroupId: Scalars['String'];
};
/** Input for archiving a plan */
export declare type ArchivePlanInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Plan ID to archive */
    id: Scalars['String'];
};
/** Input for attaching a payment method to a customer */
export declare type AttachCustomerPaymentMethodInput = {
    /** The currency to use for this payment method (only used for Zuora) */
    billingCurrency?: InputMaybe<Currency>;
    /** Customer slug */
    customerId?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The billing integration to use for this payment method */
    integrationId?: InputMaybe<Scalars['String']>;
    /** Billing provider payment method id */
    paymentMethodId: Scalars['String'];
    /** Customer slug */
    refId?: InputMaybe<Scalars['String']>;
    /** The integration type to attach the payment method to */
    vendorIdentifier: VendorIdentifier;
};
/** Auth0 application type */
export declare enum Auth0ApplicationType {
    /** Both individual and organization Auth0 application types */
    Both = "BOTH",
    /** Individual Auth0 application type */
    Individual = "INDIVIDUAL",
    /** Organization Auth0 application type */
    Organization = "ORGANIZATION"
}
/** Input configuration for Auth0 integration */
export declare type Auth0CredentialsInput = {
    /** ID of the Auth0 application */
    applicationId: Scalars['String'];
    /** Name of the Auth0 application */
    applicationName: Scalars['String'];
    /** Type of the Auth0 application */
    applicationType: Auth0ApplicationType;
    /** Domain of the Auth0 client */
    clientDomain: Scalars['String'];
    /** ID of the Auth0 client */
    clientId: Scalars['String'];
    /** Secret of the Auth0 client */
    clientSecret: Scalars['String'];
    /** Initial plan ID for individual subscriptions */
    individualInitialPlanId?: InputMaybe<Scalars['String']>;
    /** Setup for starting individual subscriptions */
    individualSubscriptionStartSetup?: InputMaybe<SubscriptionStartSetup>;
    /** Initial plan ID for organization subscriptions */
    organizationInitialPlanId?: InputMaybe<Scalars['String']>;
    /** Setup for starting organization subscriptions */
    organizationSubscriptionStartSetup?: InputMaybe<SubscriptionStartSetup>;
};
/** Input for auto cancellation rule */
export declare type AutoCancellationRuleInput = {
    /** ID of the source plan */
    sourcePlanId: Scalars['String'];
    /** ID of the target plan */
    targetPlanId: Scalars['String'];
};
/** AWS Marketplace integration configuration for SaaS contract pricing model */
export declare type AwsMarketplaceCredentialsInput = {
    /** AWS IAM role ARN with StiggAWSMarketplaceAccess policy attached */
    awsRoleArn: Scalars['String'];
};
/** Input configuration for Google BigQuery integration */
export declare type BigQueryCredentialsInput = {
    /** JSON credentials for Google BigQuery */
    credentialsJson: Scalars['String'];
    /** ID of the BigQuery dataset */
    datasetId: Scalars['String'];
    /** Location of the BigQuery dataset */
    datasetLocation: Scalars['String'];
    /** Name of the Google Cloud Storage bucket */
    gcsBucketName: Scalars['String'];
    /** Path within the Google Cloud Storage bucket */
    gcsBucketPath: Scalars['String'];
    /** Access ID for the HMAC key */
    hmacKeyAccessId: Scalars['String'];
    /** Secret for the HMAC key */
    hmacKeySecret: Scalars['String'];
    /** ID of the Google Cloud project */
    projectId: Scalars['String'];
};
export declare type BillableFeatureInput = {
    featureId: Scalars['String'];
    quantity: Scalars['Float'];
};
export declare type BillingAddress = {
    city?: InputMaybe<Scalars['String']>;
    country?: InputMaybe<Scalars['String']>;
    line1?: InputMaybe<Scalars['String']>;
    line2?: InputMaybe<Scalars['String']>;
    postalCode?: InputMaybe<Scalars['String']>;
    state?: InputMaybe<Scalars['String']>;
};
/** Billing anchor for subscription billing */
export declare enum BillingAnchor {
    /** Billing will be anchored to the start of the month */
    StartOfTheMonth = "START_OF_THE_MONTH",
    /** Subscriptions will consolidate billing to the start of the month */
    SubscriptionsConsolidateBilling = "SUBSCRIPTIONS_CONSOLIDATE_BILLING",
    /** Billing will be anchored to the start of the subscription */
    SubscriptionStart = "SUBSCRIPTION_START"
}
/** Billing Cadence */
export declare enum BillingCadence {
    /** One off */
    OneOff = "ONE_OFF",
    /** Recurring */
    Recurring = "RECURRING"
}
export declare type BillingCadenceFilterComparison = {
    eq?: InputMaybe<BillingCadence>;
    gt?: InputMaybe<BillingCadence>;
    gte?: InputMaybe<BillingCadence>;
    iLike?: InputMaybe<BillingCadence>;
    in?: InputMaybe<Array<BillingCadence>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<BillingCadence>;
    lt?: InputMaybe<BillingCadence>;
    lte?: InputMaybe<BillingCadence>;
    neq?: InputMaybe<BillingCadence>;
    notILike?: InputMaybe<BillingCadence>;
    notIn?: InputMaybe<Array<BillingCadence>>;
    notLike?: InputMaybe<BillingCadence>;
};
/** Billing model */
export declare enum BillingModel {
    /** Credit based */
    CreditBased = "CREDIT_BASED",
    /** Flat fee */
    FlatFee = "FLAT_FEE",
    /** Minimum spend */
    MinimumSpend = "MINIMUM_SPEND",
    /** Per unit */
    PerUnit = "PER_UNIT",
    /** Usage based */
    UsageBased = "USAGE_BASED"
}
export declare type BillingModelFilterComparison = {
    eq?: InputMaybe<BillingModel>;
    gt?: InputMaybe<BillingModel>;
    gte?: InputMaybe<BillingModel>;
    iLike?: InputMaybe<BillingModel>;
    in?: InputMaybe<Array<BillingModel>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<BillingModel>;
    lt?: InputMaybe<BillingModel>;
    lte?: InputMaybe<BillingModel>;
    neq?: InputMaybe<BillingModel>;
    notILike?: InputMaybe<BillingModel>;
    notIn?: InputMaybe<Array<BillingModel>>;
    notLike?: InputMaybe<BillingModel>;
};
/** Billing period */
export declare enum BillingPeriod {
    /** Annually */
    Annually = "ANNUALLY",
    /** Monthly */
    Monthly = "MONTHLY"
}
export declare type BillingPeriodFilterComparison = {
    eq?: InputMaybe<BillingPeriod>;
    gt?: InputMaybe<BillingPeriod>;
    gte?: InputMaybe<BillingPeriod>;
    iLike?: InputMaybe<BillingPeriod>;
    in?: InputMaybe<Array<BillingPeriod>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<BillingPeriod>;
    lt?: InputMaybe<BillingPeriod>;
    lte?: InputMaybe<BillingPeriod>;
    neq?: InputMaybe<BillingPeriod>;
    notILike?: InputMaybe<BillingPeriod>;
    notIn?: InputMaybe<Array<BillingPeriod>>;
    notLike?: InputMaybe<BillingPeriod>;
};
/** Billing vendor identifiers */
export declare enum BillingVendorIdentifier {
    /** Stripe */
    Stripe = "STRIPE"
}
export declare type BooleanFieldComparison = {
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
};
/** Budget configuration input */
export declare type BudgetConfigurationInput = {
    /** Indicates the behavior of the budget when the limit is exceeded. If true, the limit is a soft limit, if false, the limit is a hard limit. Default is false. */
    hasSoftLimit: Scalars['Boolean'];
    /** The maximum spending limit */
    limit: Scalars['Float'];
};
/** Change type enum */
export declare enum ChangeType {
    /** Added */
    Added = "ADDED",
    /** Deleted */
    Deleted = "DELETED",
    /** Modified */
    Modified = "MODIFIED",
    /** Reordered */
    Reordered = "REORDERED"
}
/** Input for triggering an immediate usage charge for a subscription */
export declare type ChargeSubscriptionUsageInput = {
    /** The id of the subscriptions environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The subscription reference id to charge usage for */
    subscriptionId: Scalars['String'];
    /** The end date until which to calculate the usage */
    untilDate?: InputMaybe<Scalars['DateTime']>;
};
/** Input for setting up the checkout widget’s design. */
export declare type CheckoutConfigurationInput = {
    /** Additional content settings such as form fields. */
    content?: InputMaybe<CheckoutContentInput>;
    /** Custom styles to override default checkout appearance. */
    customCss?: InputMaybe<Scalars['String']>;
    /** Color palette settings for the checkout process. */
    palette?: InputMaybe<CheckoutPaletteInput>;
    /** Typography options for headings and text in checkout. */
    typography?: InputMaybe<TypographyConfigurationInput>;
};
/** Input for content customization in the checkout process. */
export declare type CheckoutContentInput = {
    /** Indicates whether the checkout form should ask for a phone number. */
    collectPhoneNumber?: InputMaybe<Scalars['Boolean']>;
};
export declare type CheckoutOptions = {
    allowPromoCodes?: InputMaybe<Scalars['Boolean']>;
    allowTaxIdCollection?: InputMaybe<Scalars['Boolean']>;
    cancelUrl: Scalars['String'];
    collectBillingAddress?: InputMaybe<Scalars['Boolean']>;
    collectPhoneNumber?: InputMaybe<Scalars['Boolean']>;
    referenceId?: InputMaybe<Scalars['String']>;
    successUrl: Scalars['String'];
};
/** Input for customizing checkout color scheme. */
export declare type CheckoutPaletteInput = {
    /** Background color of the widget. */
    backgroundColor?: InputMaybe<Scalars['String']>;
    /** Color applied to widget borders or separators. */
    borderColor?: InputMaybe<Scalars['String']>;
    /** Primary accent color used throughout the widget. */
    primary?: InputMaybe<Scalars['String']>;
    /** Background color for the order summary section during checkout. */
    summaryBackgroundColor?: InputMaybe<Scalars['String']>;
    /** Default color used for text content. */
    textColor?: InputMaybe<Scalars['String']>;
};
/** Checkout state input */
export declare type CheckoutStateInput = {
    /** The billing country code of the customer to checkout */
    billingCountryCode?: InputMaybe<Scalars['String']>;
    /** Customer ID */
    customerId: Scalars['String'];
    /** The plan ID to checkout */
    planId: Scalars['String'];
    /** The Plan Product ID to checkout */
    productId?: InputMaybe<Scalars['String']>;
    /** The resource ID to checkout */
    resourceId?: InputMaybe<Scalars['String']>;
};
/** Input for clearing a customers persistent cache. */
export declare type ClearCustomerPersistentCacheInput = {
    /** The unique identifier of the customer whose cache should be cleared. */
    customerId: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The resource ID scoped to the customer. */
    resourceId?: InputMaybe<Scalars['String']>;
};
/** Condition operation */
export declare enum ConditionOperation {
    /** Equals operation */
    Equals = "EQUALS",
    /** Greater than operation */
    GreaterThan = "GREATER_THAN",
    /** Greater than or equal operation */
    GreaterThanOrEqual = "GREATER_THAN_OR_EQUAL",
    /** Is not null operation */
    IsNotNull = "IS_NOT_NULL",
    /** Is null operation */
    IsNull = "IS_NULL",
    /** Less than operation */
    LessThan = "LESS_THAN",
    /** Less than or equal operation */
    LessThanOrEqual = "LESS_THAN_OR_EQUAL",
    /** Not equals operation */
    NotEquals = "NOT_EQUALS"
}
export declare type CouponFilter = {
    and?: InputMaybe<Array<CouponFilter>>;
    billingId?: InputMaybe<StringFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    customers?: InputMaybe<CouponFilterCustomerFilter>;
    description?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    name?: InputMaybe<StringFieldComparison>;
    or?: InputMaybe<Array<CouponFilter>>;
    refId?: InputMaybe<StringFieldComparison>;
    source?: InputMaybe<CouponSourceFilterComparison>;
    status?: InputMaybe<CouponStatusFilterComparison>;
    type?: InputMaybe<CouponTypeFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
export declare type CouponFilterCustomerFilter = {
    and?: InputMaybe<Array<CouponFilterCustomerFilter>>;
    billingId?: InputMaybe<StringFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    crmHubspotCompanyId?: InputMaybe<StringFieldComparison>;
    crmHubspotCompanyUrl?: InputMaybe<StringFieldComparison>;
    crmId?: InputMaybe<StringFieldComparison>;
    customerId?: InputMaybe<StringFieldComparison>;
    deletedAt?: InputMaybe<DateFieldComparison>;
    email?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    name?: InputMaybe<StringFieldComparison>;
    or?: InputMaybe<Array<CouponFilterCustomerFilter>>;
    refId?: InputMaybe<StringFieldComparison>;
    salesforceId?: InputMaybe<StringFieldComparison>;
    searchQuery?: InputMaybe<CustomerSearchQueryFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
export declare type CouponSort = {
    direction: SortDirection;
    field: CouponSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum CouponSortFields {
    BillingId = "billingId",
    CreatedAt = "createdAt",
    Description = "description",
    EnvironmentId = "environmentId",
    Id = "id",
    Name = "name",
    RefId = "refId",
    Source = "source",
    Status = "status",
    Type = "type",
    UpdatedAt = "updatedAt"
}
/** The source of the coupon */
export declare enum CouponSource {
    /** Stigg */
    Stigg = "STIGG",
    /** Stigg adhoc */
    StiggAdhoc = "STIGG_ADHOC",
    /** Stripe */
    Stripe = "STRIPE"
}
export declare type CouponSourceFilterComparison = {
    eq?: InputMaybe<CouponSource>;
    in?: InputMaybe<Array<CouponSource>>;
};
/** The status of the coupon */
export declare enum CouponStatus {
    /** Active */
    Active = "ACTIVE",
    /** Archived */
    Archived = "ARCHIVED"
}
export declare type CouponStatusFilterComparison = {
    eq?: InputMaybe<CouponStatus>;
    gt?: InputMaybe<CouponStatus>;
    gte?: InputMaybe<CouponStatus>;
    iLike?: InputMaybe<CouponStatus>;
    in?: InputMaybe<Array<CouponStatus>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<CouponStatus>;
    lt?: InputMaybe<CouponStatus>;
    lte?: InputMaybe<CouponStatus>;
    neq?: InputMaybe<CouponStatus>;
    notILike?: InputMaybe<CouponStatus>;
    notIn?: InputMaybe<Array<CouponStatus>>;
    notLike?: InputMaybe<CouponStatus>;
};
/** The type of the coupon */
export declare enum CouponType {
    /** Fixed */
    Fixed = "FIXED",
    /** Percentage */
    Percentage = "PERCENTAGE"
}
export declare type CouponTypeFilterComparison = {
    eq?: InputMaybe<CouponType>;
    gt?: InputMaybe<CouponType>;
    gte?: InputMaybe<CouponType>;
    iLike?: InputMaybe<CouponType>;
    in?: InputMaybe<Array<CouponType>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<CouponType>;
    lt?: InputMaybe<CouponType>;
    lte?: InputMaybe<CouponType>;
    neq?: InputMaybe<CouponType>;
    notILike?: InputMaybe<CouponType>;
    notIn?: InputMaybe<Array<CouponType>>;
    notLike?: InputMaybe<CouponType>;
};
/** Create a new coupon input */
export declare type CreateCouponInput = {
    /** Metadata associated with the entity */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** Fixed amount discounts in different currencies */
    amountsOff?: InputMaybe<Array<MoneyInputDto>>;
    /** Description of the coupon */
    description?: InputMaybe<Scalars['String']>;
    /** Discount value of the coupon (deprecated) */
    discountValue?: InputMaybe<Scalars['Float']>;
    /** Duration of the coupon validity in months */
    durationInMonths?: InputMaybe<Scalars['Float']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Name of the coupon */
    name: Scalars['String'];
    /** Percentage discount off the original price */
    percentOff?: InputMaybe<Scalars['Float']>;
    /** The unique identifier for the entity */
    refId: Scalars['String'];
    /** Type of the coupon (percentage or fixed amount) */
    type?: InputMaybe<CouponType>;
};
/** Input for creating a new environment */
export declare type CreateEnvironment = {
    /** The color used to distinguish this environment in the UI */
    color?: InputMaybe<Scalars['String']>;
    /** The timestamp when the environment was created */
    createdAt?: InputMaybe<Scalars['DateTime']>;
    /** Optional description of the environment */
    description?: InputMaybe<Scalars['String']>;
    /** The name of the environment that will be displayed in the UI */
    displayName?: InputMaybe<Scalars['String']>;
    /** Whether client-side security hardening is enabled for this environment */
    hardenClientAccessEnabled?: InputMaybe<Scalars['Boolean']>;
    /** Unique identifier for the entity */
    id?: InputMaybe<Scalars['String']>;
    /** The current provisioning status of the environment */
    provisionStatus?: InputMaybe<EnvironmentProvisionStatus>;
    /** A unique identifier for the environment */
    slug?: InputMaybe<Scalars['String']>;
    /** The type of environment (production or non-production) */
    type?: InputMaybe<EnvironmentType>;
};
/** Additional options for environment creation */
export declare type CreateEnvironmentOptions = {
    /** Whether to automatically create a default product in the new environment */
    createDefaultProduct?: InputMaybe<Scalars['Boolean']>;
};
/** Input parameters for creating a new experiment */
export declare type CreateExperimentInput = {
    /** Name for the control group */
    controlGroupName: Scalars['String'];
    /** Description of the experiements */
    description?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Name of the experiment */
    name: Scalars['String'];
    /** Internal identifier for the product experiment is associated with */
    productId: Scalars['String'];
    /** Product settings for the variant group */
    productSettings?: InputMaybe<ProductSettingsInput>;
    /** Name for the variant group */
    variantGroupName: Scalars['String'];
    /** Percentage of users in the variant group */
    variantPercentage: Scalars['Float'];
};
/** Input for creating a feature group */
export declare type CreateFeatureGroupInput = {
    /** The description of the feature group */
    description?: InputMaybe<Scalars['String']>;
    /** The display name of the feature group */
    displayName: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId: Scalars['UUID'];
    /** The feature group id */
    featureGroupId: Scalars['String'];
    /** The features in the feature group */
    features: Array<Scalars['String']>;
};
export declare type CreateHook = {
    /** A JSON containing the configuration for each event log type */
    configuration?: InputMaybe<Scalars['JSON']>;
    /** Timestamp of when the record was created */
    createdAt?: InputMaybe<Scalars['DateTime']>;
    /** Webhook description */
    description?: InputMaybe<Scalars['String']>;
    /** The Webhook endpoint URL */
    endpoint?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The event types that the webhook will be triggered on */
    eventLogTypes?: InputMaybe<Array<EventLogType>>;
    /** Unique identifier for the entity */
    id?: InputMaybe<Scalars['UUID']>;
    /** Secret key for the webhook */
    secretKey?: InputMaybe<Scalars['String']>;
    /** The status of the webhook */
    status?: InputMaybe<HookStatus>;
};
/** Create integration input */
export declare type CreateIntegrationInput = {
    /** Auth0 integration configuration */
    auth0Credentials?: InputMaybe<Auth0CredentialsInput>;
    /** Amazon Web Services Marketplace integration configuration */
    awsMarketplaceCredentials?: InputMaybe<AwsMarketplaceCredentialsInput>;
    /** Google BigQuery integration configuration */
    bigQueryCredentials?: InputMaybe<BigQueryCredentialsInput>;
    /** The unique identifier for the environment */
    environmentId: Scalars['String'];
    /** HubSpot integration configuration */
    hubspotCredentials?: InputMaybe<HubspotCredentialsInput>;
    /** The reference ID for the integration */
    integrationId?: InputMaybe<Scalars['String']>;
    /** Whether the integration is the default integration */
    isDefault?: InputMaybe<Scalars['Boolean']>;
    /** OpenFGA integration configuration */
    openFGACredentials?: InputMaybe<OpenFgaCredentialsInput>;
    /** Salesforce integration configuration */
    salesforceCredentials?: InputMaybe<SalesforceCredentialsInput>;
    /** Snowflake integration configuration */
    snowflakeCredentials?: InputMaybe<SnowflakeCredentialsInput>;
    /** Stripe integration configuration */
    stripeCredentials?: InputMaybe<StripeCredentialsInput>;
    /** The vendor identifier of integration */
    vendorIdentifier: VendorIdentifier;
    /** Zuora integration configuration */
    zuoraCredentials?: InputMaybe<ZuoraCredentialsInput>;
};
export declare type CreateManyPackageEntitlementsInput = {
    /** Array of records to create */
    packageEntitlements: Array<PackageEntitlementInput>;
};
export declare type CreateManyPromotionalEntitlementsInput = {
    /** Array of records to create */
    promotionalEntitlements: Array<PromotionalEntitlementInput>;
};
/** A meter configuration that tracks and measures usage-based functionality */
export declare type CreateMeter = {
    /** Configuration specifying how to aggregate the meter data */
    aggregation: MeterAggregation;
    /** List of filters that will be applied to the data */
    filters: Array<MeterFilterDefinitionInput>;
};
/** Input for creating a single environment */
export declare type CreateOneEnvironmentInput = {
    /** The environment configuration details */
    environment: CreateEnvironment;
    /** Additional options for environment creation */
    options?: InputMaybe<CreateEnvironmentOptions>;
};
export declare type CreateOneHookInput = {
    /** The record to create */
    hook: CreateHook;
};
export declare type CreateOneIntegrationInput = {
    /** The record to create */
    integration: CreateIntegrationInput;
};
/** Input for creating a single product */
export declare type CreateOneProductInput = {
    /** Record to create */
    product: ProductCreateInput;
};
/** Create or update AWS Marketplace product input */
export declare type CreateOrUpdateAwsMarketplaceProductInput = {
    /** Additional metadata for the product */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** Auto cancellation rules */
    autoCancellationRules?: InputMaybe<Array<AutoCancellationRuleInput>>;
    /** Mapping between AWS dimensions and Stigg plans for entitlements */
    awsDimensionsMapping: Array<DimensionsMappingInput>;
    /** AWS Marketplace product identifier */
    awsProductId?: InputMaybe<Scalars['String']>;
    /** Description of the product */
    description?: InputMaybe<Scalars['String']>;
    /** Display name of the product */
    displayName?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Indicates if multiple subscriptions to this product are allowed */
    multipleSubscriptions?: InputMaybe<Scalars['Boolean']>;
    /** Stigg product ID to be mapped to AWS Marketplace */
    productId?: InputMaybe<Scalars['String']>;
    /** Settings for the product */
    productSettings?: InputMaybe<ProductSettingsInput>;
    /** The unique identifier for the entity */
    refId?: InputMaybe<Scalars['String']>;
    /** Usage reset cutoff rule */
    usageResetCutoffRule?: InputMaybe<SubscriptionUpdateUsageResetCutoffRuleInput>;
};
/** The input type for creating a package group */
export declare type CreatePackageGroup = {
    /** The description of the package group */
    description?: InputMaybe<Scalars['String']>;
    /** The display name of the package group */
    displayName: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The id of the package group */
    packageGroupId: Scalars['String'];
    /** The id of the related product */
    productId: Scalars['String'];
};
/** Create workflow trigger input */
export declare type CreateWorkflowTriggerInput = {
    /** A JSON containing the configuration for each event log type */
    configuration?: InputMaybe<Scalars['JSON']>;
    /** Workflow trigger endpoint */
    endpoint: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Event log types */
    eventLogTypes: Array<EventLogType>;
    /** Workflow trigger id */
    triggerId?: InputMaybe<Scalars['String']>;
};
/** Input for retrieving credit balance */
export declare type CreditBalanceSummaryInput = {
    /** The custom currency ID of the credit grant */
    currencyId?: InputMaybe<Scalars['String']>;
    /** The customer ID of the credit grant */
    customerId: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The resource ID of the credit grant */
    resourceId?: InputMaybe<Scalars['String']>;
};
/** Input for creating a credit grant */
export declare type CreditGrantInput = {
    /** Metadata associated with the entity */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** The amount of the credit grant */
    amount: Scalars['Float'];
    /** The comment for the credit grant */
    comment?: InputMaybe<Scalars['String']>;
    /** The fiat cost of the credit grant */
    cost?: InputMaybe<MoneyInputDto>;
    /** The custom currency ID of the credit grant */
    currencyId: Scalars['String'];
    /** The customer ID of the credit grant */
    customerId: Scalars['String'];
    /** The display name of the credit grant */
    displayName: Scalars['String'];
    /** The effective date of the credit grant */
    effectiveAt?: InputMaybe<Scalars['DateTime']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The expiration date of the credit grant */
    expireAt?: InputMaybe<Scalars['DateTime']>;
    /** The type of the credit grant */
    grantType: CreditGrantType;
    /** The priority of the credit grant */
    priority?: InputMaybe<Scalars['Float']>;
    /** The resource ID of the credit grant */
    resourceId?: InputMaybe<Scalars['String']>;
};
/** The type of credit grant */
export declare enum CreditGrantType {
    /** Paid credit grant */
    Paid = "PAID",
    /** Promotional credit grant */
    Promotional = "PROMOTIONAL"
}
/** The type of the ledger event */
export declare enum CreditLedgerEventType {
    /** Credits consumed */
    CreditsConsumed = "CREDITS_CONSUMED",
    /** Credits expired */
    CreditsExpired = "CREDITS_EXPIRED",
    /** Credits granted */
    CreditsGranted = "CREDITS_GRANTED"
}
/** Input for retrieving credit ledger */
export declare type CreditLedgerInput = {
    /** The customer ID of the credit ledger */
    customerId: Scalars['String'];
    /** The environment ID of the credit ledger */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The resource ID of the credit ledger */
    resourceId?: InputMaybe<Scalars['String']>;
};
/** Credit Rate Input */
export declare type CreditRateInput = {
    /** The credit rate amount */
    amount: Scalars['Float'];
    /** The custom currency ID for the credit rate */
    customCurrencyId: Scalars['UUID'];
};
/** Currency */
export declare enum Currency {
    /** UAE Dirham */
    Aed = "AED",
    /** Lek */
    All = "ALL",
    /** Armenian Dram */
    Amd = "AMD",
    /** Netherlands Antillean Guilder */
    Ang = "ANG",
    /** Australian Dollar */
    Aud = "AUD",
    /** Aruban Florin */
    Awg = "AWG",
    /** Azerbaijanian Manat */
    Azn = "AZN",
    /** Convertible Mark */
    Bam = "BAM",
    /** Barbados Dollar */
    Bbd = "BBD",
    /** Taka */
    Bdt = "BDT",
    /** Bulgarian Lev */
    Bgn = "BGN",
    /** Burundi Franc */
    Bif = "BIF",
    /** Bermudian Dollar */
    Bmd = "BMD",
    /** Brunei Dollar */
    Bnd = "BND",
    /** Brazilian Real */
    Brl = "BRL",
    /** Bahamian Dollar */
    Bsd = "BSD",
    /** Pula */
    Bwp = "BWP",
    /** Belarusian Ruble */
    Byn = "BYN",
    /** Belize Dollar */
    Bzd = "BZD",
    /** Canadian Dollar */
    Cad = "CAD",
    /** Congolese Franc */
    Cdf = "CDF",
    /** Swiss Franc */
    Chf = "CHF",
    /** Chilean Peso */
    Clp = "CLP",
    /** Yuan Renminbi */
    Cny = "CNY",
    /** Czech Koruna */
    Czk = "CZK",
    /** Djibouti Franc */
    Djf = "DJF",
    /** Danish Krone */
    Dkk = "DKK",
    /** Dominican Peso */
    Dop = "DOP",
    /** Algerian Dinar */
    Dzd = "DZD",
    /** Egyptian Pound */
    Egp = "EGP",
    /** Ethiopian Birr */
    Etb = "ETB",
    /** Euro */
    Eur = "EUR",
    /** Fiji Dollar */
    Fjd = "FJD",
    /** Pound Sterling */
    Gbp = "GBP",
    /** Lari */
    Gel = "GEL",
    /** Gibraltar Pound */
    Gip = "GIP",
    /** Dalasi */
    Gmd = "GMD",
    /** Guinea Franc */
    Gnf = "GNF",
    /** Guyana Dollar */
    Gyd = "GYD",
    /** Hong Kong Dollar */
    Hkd = "HKD",
    /** Kuna */
    Hrk = "HRK",
    /** Gourde */
    Htg = "HTG",
    /** Rupiah */
    Idr = "IDR",
    /** New Israeli Sheqel */
    Ils = "ILS",
    /** Indian Rupee */
    Inr = "INR",
    /** Iceland Krona */
    Isk = "ISK",
    /** Jamaican Dollar */
    Jmd = "JMD",
    /** Yen */
    Jpy = "JPY",
    /** Kenyan Shilling */
    Kes = "KES",
    /** Som */
    Kgs = "KGS",
    /** Riel */
    Khr = "KHR",
    /** Comoro Franc */
    Kmf = "KMF",
    /** Won */
    Krw = "KRW",
    /** Cayman Islands Dollar */
    Kyd = "KYD",
    /** Tenge */
    Kzt = "KZT",
    /** Lebanese Pound */
    Lbp = "LBP",
    /** Sri Lanka Rupee */
    Lkr = "LKR",
    /** Liberian Dollar */
    Lrd = "LRD",
    /** Loti */
    Lsl = "LSL",
    /** Moroccan Dirham */
    Mad = "MAD",
    /** Moldovan Leu */
    Mdl = "MDL",
    /** Malagasy Ariary */
    Mga = "MGA",
    /** Denar */
    Mkd = "MKD",
    /** Kyat */
    Mmk = "MMK",
    /** Tugrik */
    Mnt = "MNT",
    /** Pataca */
    Mop = "MOP",
    /** Ouguiya */
    Mro = "MRO",
    /** Rufiyaa */
    Mvr = "MVR",
    /** Malawi Kwacha */
    Mwk = "MWK",
    /** Mexican Peso */
    Mxn = "MXN",
    /** Malaysian Ringgit */
    Myr = "MYR",
    /** Mozambique Metical */
    Mzn = "MZN",
    /** Namibia Dollar */
    Nad = "NAD",
    /** Naira */
    Ngn = "NGN",
    /** Norwegian Krone */
    Nok = "NOK",
    /** Nepalese Rupee */
    Npr = "NPR",
    /** New Zealand Dollar */
    Nzd = "NZD",
    /** Kina */
    Pgk = "PGK",
    /** Philippine Peso */
    Php = "PHP",
    /** Pakistan Rupee */
    Pkr = "PKR",
    /** Zloty */
    Pln = "PLN",
    /** Guarani */
    Pyg = "PYG",
    /** Qatari Rial */
    Qar = "QAR",
    /** Romanian Leu */
    Ron = "RON",
    /** Serbian Dinar */
    Rsd = "RSD",
    /** Russian Ruble */
    Rub = "RUB",
    /** Rwanda Franc */
    Rwf = "RWF",
    /** Saudi Riyal */
    Sar = "SAR",
    /** Solomon Islands Dollar */
    Sbd = "SBD",
    /** Seychelles Rupee */
    Scr = "SCR",
    /** Swedish Krona */
    Sek = "SEK",
    /** Singapore Dollar */
    Sgd = "SGD",
    /** Unknown or special currency code */
    Sle = "SLE",
    /** Leone */
    Sll = "SLL",
    /** Somali Shilling */
    Sos = "SOS",
    /** Lilangeni */
    Szl = "SZL",
    /** Baht */
    Thb = "THB",
    /** Somoni */
    Tjs = "TJS",
    /** Paanga */
    Top = "TOP",
    /** Turkish Lira */
    Try = "TRY",
    /** Trinidad and Tobago Dollar */
    Ttd = "TTD",
    /** Tanzanian Shilling */
    Tzs = "TZS",
    /** Hryvnia */
    Uah = "UAH",
    /** Uganda Shilling */
    Ugx = "UGX",
    /** US Dollar */
    Usd = "USD",
    /** Uzbekistan Sum */
    Uzs = "UZS",
    /** Dong */
    Vnd = "VND",
    /** Vatu */
    Vuv = "VUV",
    /** Tala */
    Wst = "WST",
    /** CFA Franc BEAC */
    Xaf = "XAF",
    /** East Caribbean Dollar */
    Xcd = "XCD",
    /** CFA Franc BCEAO */
    Xof = "XOF",
    /** CFP Franc */
    Xpf = "XPF",
    /** Yemeni Rial */
    Yer = "YER",
    /** Rand */
    Zar = "ZAR",
    /** Zambian Kwacha */
    Zmw = "ZMW"
}
export declare type CursorPaging = {
    /** Paginate after opaque cursor */
    after?: InputMaybe<Scalars['ConnectionCursor']>;
    /** Paginate before opaque cursor */
    before?: InputMaybe<Scalars['ConnectionCursor']>;
    /** Paginate first */
    first?: InputMaybe<Scalars['Int']>;
    /** Paginate last */
    last?: InputMaybe<Scalars['Int']>;
};
/** Input for creating a custom currency */
export declare type CustomCurrencyInput = {
    /** Metadata associated with the entity */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** The unique identifier for the custom currency */
    currencyId: Scalars['String'];
    /** Description of the currency */
    description?: InputMaybe<Scalars['String']>;
    /** The name of the custom currency */
    displayName: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The symbol of the custom currency */
    symbol?: InputMaybe<Scalars['String']>;
    /** Units for the currency (singular and plural) */
    units?: InputMaybe<UnitsInput>;
};
/** Update customer billing information */
export declare type CustomerBillingInfo = {
    /** Customer billing address */
    billingAddress?: InputMaybe<Address>;
    /** Customers selected currency */
    currency?: InputMaybe<Currency>;
    /** Customer name */
    customerName?: InputMaybe<Scalars['String']>;
    /** The billing integration to use for this customer */
    integrationId?: InputMaybe<Scalars['String']>;
    /** Invoice custom fields */
    invoiceCustomFields?: InputMaybe<Scalars['JSON']>;
    /** Language to use for this customer */
    language?: InputMaybe<Scalars['String']>;
    /** Additional metadata */
    metadata?: InputMaybe<Scalars['JSON']>;
    /** Billing provider payment method id, attached to this customer */
    paymentMethodId?: InputMaybe<Scalars['String']>;
    /** Customer shipping address */
    shippingAddress?: InputMaybe<Address>;
    /** Tax IDs */
    taxIds?: InputMaybe<Array<TaxExempt>>;
    /** Timezone to use for this customer */
    timezone?: InputMaybe<Scalars['String']>;
};
export declare type CustomerFilter = {
    and?: InputMaybe<Array<CustomerFilter>>;
    billingId?: InputMaybe<StringFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    crmHubspotCompanyId?: InputMaybe<StringFieldComparison>;
    crmHubspotCompanyUrl?: InputMaybe<StringFieldComparison>;
    crmId?: InputMaybe<StringFieldComparison>;
    customerId?: InputMaybe<StringFieldComparison>;
    deletedAt?: InputMaybe<DateFieldComparison>;
    email?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    name?: InputMaybe<StringFieldComparison>;
    or?: InputMaybe<Array<CustomerFilter>>;
    promotionalEntitlements?: InputMaybe<CustomerFilterPromotionalEntitlementFilter>;
    refId?: InputMaybe<StringFieldComparison>;
    salesforceId?: InputMaybe<StringFieldComparison>;
    searchQuery?: InputMaybe<CustomerSearchQueryFilterComparison>;
    subscriptions?: InputMaybe<CustomerFilterCustomerSubscriptionFilter>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
export declare type CustomerFilterCustomerSubscriptionFilter = {
    and?: InputMaybe<Array<CustomerFilterCustomerSubscriptionFilter>>;
    billingCycleAnchor?: InputMaybe<DateFieldComparison>;
    billingId?: InputMaybe<StringFieldComparison>;
    cancelReason?: InputMaybe<SubscriptionCancelReasonFilterComparison>;
    cancellationDate?: InputMaybe<DateFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    crmId?: InputMaybe<StringFieldComparison>;
    crmLinkUrl?: InputMaybe<StringFieldComparison>;
    currentBillingPeriodEnd?: InputMaybe<DateFieldComparison>;
    currentBillingPeriodStart?: InputMaybe<DateFieldComparison>;
    customerId?: InputMaybe<UuidFilterComparison>;
    effectiveEndDate?: InputMaybe<DateFieldComparison>;
    endDate?: InputMaybe<DateFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    oldBillingId?: InputMaybe<StringFieldComparison>;
    or?: InputMaybe<Array<CustomerFilterCustomerSubscriptionFilter>>;
    payingCustomerId?: InputMaybe<UuidFilterComparison>;
    paymentCollection?: InputMaybe<PaymentCollectionFilterComparison>;
    pricingType?: InputMaybe<PricingTypeFilterComparison>;
    refId?: InputMaybe<StringFieldComparison>;
    resourceId?: InputMaybe<UuidFilterComparison>;
    salesforceId?: InputMaybe<StringFieldComparison>;
    startDate?: InputMaybe<DateFieldComparison>;
    status?: InputMaybe<SubscriptionStatusFilterComparison>;
    subscriptionId?: InputMaybe<StringFieldComparison>;
    trialEndDate?: InputMaybe<DateFieldComparison>;
};
export declare type CustomerFilterPromotionalEntitlementFilter = {
    and?: InputMaybe<Array<CustomerFilterPromotionalEntitlementFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<CustomerFilterPromotionalEntitlementFilter>>;
    status?: InputMaybe<PromotionalEntitlementStatusFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
/** Create a new customer */
export declare type CustomerInput = {
    /** Additional metadata */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** The AWS Marketplace integration id */
    awsMarketplaceCustomerId?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the entity in the billing provider */
    billingId?: InputMaybe<Scalars['String']>;
    /** Customer billing information */
    billingInformation?: InputMaybe<CustomerBillingInfo>;
    /** Customer level coupon */
    couponRefId?: InputMaybe<Scalars['String']>;
    /** Timestamp of when the record was created */
    createdAt?: InputMaybe<Scalars['DateTime']>;
    /** The unique identifier for the customer in Hubspot integration */
    crmId?: InputMaybe<Scalars['String']>;
    /** Customer slug */
    customerId?: InputMaybe<Scalars['String']>;
    /** The email of the customer */
    email?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The name of the customer */
    name?: InputMaybe<Scalars['String']>;
    /** Customer slug */
    refId?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the customer in Salesforce integration */
    salesforceId?: InputMaybe<Scalars['String']>;
    /** Wether or not to sync free subscriptions to the billing provider */
    shouldSyncFree?: InputMaybe<Scalars['Boolean']>;
};
/** Input for customizing customer portal color palette. */
export declare type CustomerPortalColorsPaletteInput = {
    /** Background color of the widget. */
    backgroundColor?: InputMaybe<Scalars['String']>;
    /** Color applied to widget borders or separators. */
    borderColor?: InputMaybe<Scalars['String']>;
    /** Background color for the customer’s current plan section in the paywall. */
    currentPlanBackground?: InputMaybe<Scalars['String']>;
    /** Color used for icons in the customer portal. */
    iconsColor?: InputMaybe<Scalars['String']>;
    /** Background color for embedded paywall sections inside the customer portal. */
    paywallBackgroundColor?: InputMaybe<Scalars['String']>;
    /** Primary accent color used throughout the widget. */
    primary?: InputMaybe<Scalars['String']>;
    /** Default color used for text content. */
    textColor?: InputMaybe<Scalars['String']>;
};
/** Input for configuring the customer portal appearance. */
export declare type CustomerPortalConfigurationInput = {
    /** Custom CSS rules to override default styling in the portal. */
    customCss?: InputMaybe<Scalars['String']>;
    /** Color palette customization for the portal UI. */
    palette?: InputMaybe<CustomerPortalColorsPaletteInput>;
    /** Font styling settings for the customer portal. */
    typography?: InputMaybe<TypographyConfigurationInput>;
};
/** Optional explanation or context for why this portal session is being initialized. */
export declare type CustomerPortalInput = {
    /** Unique identifier of the customer. */
    customerId: Scalars['String'];
    /** The ID of the product context under which the portal is rendered. */
    productId?: InputMaybe<Scalars['String']>;
    /** Unique identifier of a resource if the subscription or entitlements are scoped to a specific resource. */
    resourceId?: InputMaybe<Scalars['String']>;
};
export declare type CustomerResourceFilter = {
    and?: InputMaybe<Array<CustomerResourceFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    customer?: InputMaybe<CustomerResourceFilterCustomerFilter>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<CustomerResourceFilter>>;
    resourceId?: InputMaybe<StringFieldComparison>;
    subscriptions?: InputMaybe<CustomerResourceFilterCustomerSubscriptionFilter>;
};
export declare type CustomerResourceFilterCustomerFilter = {
    and?: InputMaybe<Array<CustomerResourceFilterCustomerFilter>>;
    billingId?: InputMaybe<StringFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    crmHubspotCompanyId?: InputMaybe<StringFieldComparison>;
    crmHubspotCompanyUrl?: InputMaybe<StringFieldComparison>;
    crmId?: InputMaybe<StringFieldComparison>;
    customerId?: InputMaybe<StringFieldComparison>;
    deletedAt?: InputMaybe<DateFieldComparison>;
    email?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    name?: InputMaybe<StringFieldComparison>;
    or?: InputMaybe<Array<CustomerResourceFilterCustomerFilter>>;
    refId?: InputMaybe<StringFieldComparison>;
    salesforceId?: InputMaybe<StringFieldComparison>;
    searchQuery?: InputMaybe<CustomerSearchQueryFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
export declare type CustomerResourceFilterCustomerSubscriptionFilter = {
    and?: InputMaybe<Array<CustomerResourceFilterCustomerSubscriptionFilter>>;
    billingCycleAnchor?: InputMaybe<DateFieldComparison>;
    billingId?: InputMaybe<StringFieldComparison>;
    cancelReason?: InputMaybe<SubscriptionCancelReasonFilterComparison>;
    cancellationDate?: InputMaybe<DateFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    crmId?: InputMaybe<StringFieldComparison>;
    crmLinkUrl?: InputMaybe<StringFieldComparison>;
    currentBillingPeriodEnd?: InputMaybe<DateFieldComparison>;
    currentBillingPeriodStart?: InputMaybe<DateFieldComparison>;
    customerId?: InputMaybe<UuidFilterComparison>;
    effectiveEndDate?: InputMaybe<DateFieldComparison>;
    endDate?: InputMaybe<DateFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    oldBillingId?: InputMaybe<StringFieldComparison>;
    or?: InputMaybe<Array<CustomerResourceFilterCustomerSubscriptionFilter>>;
    payingCustomerId?: InputMaybe<UuidFilterComparison>;
    paymentCollection?: InputMaybe<PaymentCollectionFilterComparison>;
    pricingType?: InputMaybe<PricingTypeFilterComparison>;
    refId?: InputMaybe<StringFieldComparison>;
    resourceId?: InputMaybe<UuidFilterComparison>;
    salesforceId?: InputMaybe<StringFieldComparison>;
    startDate?: InputMaybe<DateFieldComparison>;
    status?: InputMaybe<SubscriptionStatusFilterComparison>;
    subscriptionId?: InputMaybe<StringFieldComparison>;
    trialEndDate?: InputMaybe<DateFieldComparison>;
};
export declare type CustomerResourceSort = {
    direction: SortDirection;
    field: CustomerResourceSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum CustomerResourceSortFields {
    CreatedAt = "createdAt",
    EnvironmentId = "environmentId",
    ResourceId = "resourceId"
}
export declare type CustomerSearchQueryFilterComparison = {
    iLike?: InputMaybe<Scalars['String']>;
};
export declare type CustomerSort = {
    direction: SortDirection;
    field: CustomerSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum CustomerSortFields {
    BillingId = "billingId",
    CreatedAt = "createdAt",
    CrmHubspotCompanyId = "crmHubspotCompanyId",
    CrmHubspotCompanyUrl = "crmHubspotCompanyUrl",
    CrmId = "crmId",
    CustomerId = "customerId",
    DeletedAt = "deletedAt",
    Email = "email",
    EnvironmentId = "environmentId",
    Id = "id",
    Name = "name",
    RefId = "refId",
    SalesforceId = "salesforceId",
    SearchQuery = "searchQuery",
    UpdatedAt = "updatedAt"
}
export declare type CustomerSubscriptionFilter = {
    addons?: InputMaybe<CustomerSubscriptionFilterSubscriptionAddonFilter>;
    and?: InputMaybe<Array<CustomerSubscriptionFilter>>;
    billingCycleAnchor?: InputMaybe<DateFieldComparison>;
    billingId?: InputMaybe<StringFieldComparison>;
    cancelReason?: InputMaybe<SubscriptionCancelReasonFilterComparison>;
    cancellationDate?: InputMaybe<DateFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    crmId?: InputMaybe<StringFieldComparison>;
    crmLinkUrl?: InputMaybe<StringFieldComparison>;
    currentBillingPeriodEnd?: InputMaybe<DateFieldComparison>;
    currentBillingPeriodStart?: InputMaybe<DateFieldComparison>;
    customer?: InputMaybe<CustomerSubscriptionFilterCustomerFilter>;
    customerId?: InputMaybe<UuidFilterComparison>;
    effectiveEndDate?: InputMaybe<DateFieldComparison>;
    endDate?: InputMaybe<DateFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    oldBillingId?: InputMaybe<StringFieldComparison>;
    or?: InputMaybe<Array<CustomerSubscriptionFilter>>;
    payingCustomer?: InputMaybe<CustomerSubscriptionFilterCustomerFilter>;
    payingCustomerId?: InputMaybe<UuidFilterComparison>;
    paymentCollection?: InputMaybe<PaymentCollectionFilterComparison>;
    plan?: InputMaybe<CustomerSubscriptionFilterPlanFilter>;
    prices?: InputMaybe<CustomerSubscriptionFilterSubscriptionPriceFilter>;
    pricingType?: InputMaybe<PricingTypeFilterComparison>;
    refId?: InputMaybe<StringFieldComparison>;
    resource?: InputMaybe<CustomerSubscriptionFilterCustomerResourceFilter>;
    resourceId?: InputMaybe<UuidFilterComparison>;
    salesforceId?: InputMaybe<StringFieldComparison>;
    startDate?: InputMaybe<DateFieldComparison>;
    status?: InputMaybe<SubscriptionStatusFilterComparison>;
    subscriptionEntitlements?: InputMaybe<CustomerSubscriptionFilterSubscriptionEntitlementFilter>;
    subscriptionId?: InputMaybe<StringFieldComparison>;
    trialEndDate?: InputMaybe<DateFieldComparison>;
};
export declare type CustomerSubscriptionFilterCustomerFilter = {
    and?: InputMaybe<Array<CustomerSubscriptionFilterCustomerFilter>>;
    billingId?: InputMaybe<StringFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    crmHubspotCompanyId?: InputMaybe<StringFieldComparison>;
    crmHubspotCompanyUrl?: InputMaybe<StringFieldComparison>;
    crmId?: InputMaybe<StringFieldComparison>;
    customerId?: InputMaybe<StringFieldComparison>;
    deletedAt?: InputMaybe<DateFieldComparison>;
    email?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    name?: InputMaybe<StringFieldComparison>;
    or?: InputMaybe<Array<CustomerSubscriptionFilterCustomerFilter>>;
    refId?: InputMaybe<StringFieldComparison>;
    salesforceId?: InputMaybe<StringFieldComparison>;
    searchQuery?: InputMaybe<CustomerSearchQueryFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
export declare type CustomerSubscriptionFilterCustomerResourceFilter = {
    and?: InputMaybe<Array<CustomerSubscriptionFilterCustomerResourceFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<CustomerSubscriptionFilterCustomerResourceFilter>>;
    resourceId?: InputMaybe<StringFieldComparison>;
};
export declare type CustomerSubscriptionFilterPlanFilter = {
    and?: InputMaybe<Array<CustomerSubscriptionFilterPlanFilter>>;
    billingId?: InputMaybe<StringFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    description?: InputMaybe<StringFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    isLatest?: InputMaybe<BooleanFieldComparison>;
    or?: InputMaybe<Array<CustomerSubscriptionFilterPlanFilter>>;
    pricingType?: InputMaybe<PricingTypeFilterComparison>;
    productId?: InputMaybe<StringFieldComparison>;
    refId?: InputMaybe<StringFieldComparison>;
    status?: InputMaybe<PackageStatusFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
    versionNumber?: InputMaybe<IntFieldComparison>;
};
export declare type CustomerSubscriptionFilterSubscriptionAddonFilter = {
    and?: InputMaybe<Array<CustomerSubscriptionFilterSubscriptionAddonFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<CustomerSubscriptionFilterSubscriptionAddonFilter>>;
    quantity?: InputMaybe<NumberFieldComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
export declare type CustomerSubscriptionFilterSubscriptionEntitlementFilter = {
    and?: InputMaybe<Array<CustomerSubscriptionFilterSubscriptionEntitlementFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<CustomerSubscriptionFilterSubscriptionEntitlementFilter>>;
    subscriptionId?: InputMaybe<StringFieldComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
export declare type CustomerSubscriptionFilterSubscriptionPriceFilter = {
    and?: InputMaybe<Array<CustomerSubscriptionFilterSubscriptionPriceFilter>>;
    billingModel?: InputMaybe<BillingModelFilterComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    featureId?: InputMaybe<StringFieldComparison>;
    hasSoftLimit?: InputMaybe<BooleanFieldComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<CustomerSubscriptionFilterSubscriptionPriceFilter>>;
    updatedAt?: InputMaybe<DateFieldComparison>;
    usageLimit?: InputMaybe<NumberFieldComparison>;
};
export declare type CustomerSubscriptionSort = {
    direction: SortDirection;
    field: CustomerSubscriptionSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum CustomerSubscriptionSortFields {
    BillingCycleAnchor = "billingCycleAnchor",
    BillingId = "billingId",
    CancelReason = "cancelReason",
    CancellationDate = "cancellationDate",
    CreatedAt = "createdAt",
    CrmId = "crmId",
    CrmLinkUrl = "crmLinkUrl",
    CurrentBillingPeriodEnd = "currentBillingPeriodEnd",
    CurrentBillingPeriodStart = "currentBillingPeriodStart",
    CustomerId = "customerId",
    EffectiveEndDate = "effectiveEndDate",
    EndDate = "endDate",
    EnvironmentId = "environmentId",
    Id = "id",
    OldBillingId = "oldBillingId",
    PayingCustomerId = "payingCustomerId",
    PaymentCollection = "paymentCollection",
    PricingType = "pricingType",
    RefId = "refId",
    ResourceId = "resourceId",
    SalesforceId = "salesforceId",
    StartDate = "startDate",
    Status = "status",
    SubscriptionId = "subscriptionId",
    TrialEndDate = "trialEndDate"
}
export declare type DateFieldComparison = {
    between?: InputMaybe<DateFieldComparisonBetween>;
    eq?: InputMaybe<Scalars['DateTime']>;
    gt?: InputMaybe<Scalars['DateTime']>;
    gte?: InputMaybe<Scalars['DateTime']>;
    in?: InputMaybe<Array<Scalars['DateTime']>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    lt?: InputMaybe<Scalars['DateTime']>;
    lte?: InputMaybe<Scalars['DateTime']>;
    neq?: InputMaybe<Scalars['DateTime']>;
    notBetween?: InputMaybe<DateFieldComparisonBetween>;
    notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};
export declare type DateFieldComparisonBetween = {
    lower: Scalars['DateTime'];
    upper: Scalars['DateTime'];
};
/** Input type for default SSO roles */
export declare type DefaultSsoRolesInput = {
    /** Account level access of the user */
    accountRole: AccountAccessRole;
    /** Environment level access of the user */
    nonProductionRole: EnvironmentAccessRole;
    /** Environment level access of the user */
    productionRole: EnvironmentAccessRole;
};
/** Default configuration for a trial */
export declare type DefaultTrialConfigInputDto = {
    /** Budget configuration */
    budget?: InputMaybe<BudgetConfigurationInput>;
    /** The duration of the trial in the specified units */
    duration?: InputMaybe<Scalars['Float']>;
    /** Trial end behavior */
    trialEndBehavior?: InputMaybe<TrialEndBehavior>;
    /** The time unit for the trial duration (days or months) */
    units?: InputMaybe<TrialPeriodUnits>;
};
/** The input for delegating a subscription to a customer */
export declare type DelegateSubscriptionToCustomerInput = {
    /** The customer ID which will manage the subscription (the paying customer of the subscription will not change) */
    destinationCustomerId?: InputMaybe<Scalars['String']>;
    /** The environment ID of the subscription to delegate */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The ID of the subscription to delegate */
    subscriptionId: Scalars['String'];
};
/** Input for deleting a feature */
export declare type DeleteFeatureInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Unique identifier for the entity */
    id: Scalars['String'];
};
export declare type DeleteOneHookInput = {
    /** The id of the record to delete. */
    id: Scalars['UUID'];
};
export declare type DeleteOneIntegrationInput = {
    /** The id of the record to delete. */
    id: Scalars['UUID'];
};
export declare type DeleteOnePackageEntitlementInput = {
    /** The id of the record to delete. */
    id: Scalars['UUID'];
};
export declare type DeleteOnePriceInput = {
    /** The id of the record to delete. */
    id: Scalars['UUID'];
};
/** Input for deleting a product */
export declare type DeleteOneProductInput = {
    /** Unique identifier for the entity */
    id: Scalars['String'];
};
export declare type DeleteOnePromotionalEntitlementInput = {
    /** The id of the record to delete. */
    id: Scalars['UUID'];
};
/** Delete workflow trigger input */
export declare type DeleteWorkflowTriggerInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Workflow trigger id */
    workflowTriggerId: Scalars['String'];
};
/** The department the user belongs to */
export declare enum Department {
    /** CEO or Founder */
    CeoOrFounder = "CEO_OR_FOUNDER",
    /** Engineering */
    Engineering = "ENGINEERING",
    /** Growth */
    Growth = "GROWTH",
    /** Marketing */
    Marketing = "MARKETING",
    /** Monetization */
    Monetization = "MONETIZATION",
    /** Other */
    Other = "OTHER",
    /** Product */
    Product = "PRODUCT"
}
/** Remove a payment method from a customer */
export declare type DetachCustomerPaymentMethodInput = {
    /** Customer slug */
    customerId: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
};
/** Configuration for mapping AWS Marketplace dimensions to Stigg plans */
export declare type DimensionsMappingInput = {
    /** AWS dimension key for the mapping */
    key: Scalars['String'];
    /** Corresponding Stigg plan name for feature management */
    planName: Scalars['String'];
    /** Reference ID of the corresponding Stigg plan */
    planRefId: Scalars['String'];
};
/** Discard Package Draft Input */
export declare type DiscardPackageDraftInput = {
    /** The unique identifier for the environment */
    environmentId: Scalars['String'];
    /** The unique identifier for the entity */
    refId: Scalars['String'];
};
/** The type of the discount duration */
export declare enum DiscountDurationType {
    Forever = "FOREVER",
    Once = "ONCE",
    Repeating = "REPEATING"
}
/** The type of the discount */
export declare enum DiscountType {
    Fixed = "FIXED",
    Percentage = "PERCENTAGE"
}
/** Input for checking if a feature exists */
export declare type DoesFeatureExist = {
    /** The unique identifier for the environment */
    environmentId: Scalars['UUID'];
    /** The unique identifier for the feature */
    refId: Scalars['String'];
};
/** Input for dumping two environments for comparison before a merge */
export declare type DumpEnvironmentForForMergeComparisonInput = {
    /** Slug of the destination environment */
    destinationEnvironmentSlug: Scalars['String'];
    /** Merge configuration */
    mergeConfiguration?: InputMaybe<EnvironmentMergeConfigurationInput>;
    /** Slug of the source environment */
    sourceEnvironmentSlug: Scalars['String'];
};
/** Input type for dumpEnvironmentProductCatalog mutation */
export declare type DumpEnvironmentProductCatalogInput = {
    /** The slug of the environment to dump */
    environmentSlug: Scalars['String'];
};
/** Input for duplicating a product */
export declare type DuplicateProductInput = {
    /** Description of the new product */
    description?: InputMaybe<Scalars['String']>;
    /** Display name of the new product */
    displayName?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId: Scalars['String'];
    /** The unique identifier for the entity */
    refId: Scalars['String'];
    /** ID of the product to duplicate */
    sourceProductId: Scalars['String'];
};
/** The input type for editing a package group details */
export declare type EditPackageGroupDetailsInput = {
    /** The description of the package group */
    description?: InputMaybe<Scalars['String']>;
    /** The display name of the package group */
    displayName: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The id of the package group */
    packageGroupId: Scalars['String'];
};
/** The behavior of the entitlement */
export declare enum EntitlementBehavior {
    /** Increment the value of the entitlement */
    Increment = "Increment",
    /** Override the value of the entitlement */
    Override = "Override"
}
/** Input used to report that an entitlement check was performed for a customer. */
export declare type EntitlementCheckRequested = {
    /** Identifier of the customer for whom the entitlement check was made. */
    customerId: Scalars['String'];
    /** Result object of an entitlement access check. */
    entitlementCheckResult: EntitlementCheckResult;
    /** The environment context in which the check occurred. */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The internal ID of the feature linked to this entitlement. */
    featureId: Scalars['String'];
    /** The amount of usage requested by the customer. */
    requestedUsage?: InputMaybe<Scalars['Float']>;
    /** The values requested by the customer, if applicable. */
    requestedValues?: InputMaybe<Array<Scalars['String']>>;
    /** The specific resource identifier scoped for the entitlement check. */
    resourceId?: InputMaybe<Scalars['String']>;
};
/** Result object of an entitlement access check. */
export declare type EntitlementCheckResult = {
    /** Optional message explaining why access to the feature is denied. */
    accessDeniedReason?: InputMaybe<AccessDeniedReason>;
    /** The amount of the feature the customer has used so far in the current period. */
    currentUsage?: InputMaybe<Scalars['Float']>;
    /** List of enum values applicable to this entitlement, if it is an enum feature. */
    enumValues?: InputMaybe<Array<Scalars['String']>>;
    /** Indicates whether the customer currently has access to the feature. */
    hasAccess: Scalars['Boolean'];
    /** Indicates whether the usage limit is soft — usage can exceed the limit, but will be tracked. */
    hasSoftLimit?: InputMaybe<Scalars['Boolean']>;
    /** Indicates whether this entitlement grants unlimited usage with no enforced cap. */
    hasUnlimitedUsage?: InputMaybe<Scalars['Boolean']>;
    /** Configuration for monthly usage reset. */
    monthlyResetPeriodConfiguration?: InputMaybe<MonthlyResetPeriodConfigInput>;
    /** The next date when the entitlement usage resets. */
    nextResetDate?: InputMaybe<Scalars['DateTime']>;
    /** The amount of usage requested by the customer. */
    requestedUsage?: InputMaybe<Scalars['Float']>;
    /** The values requested by the customer, if applicable. */
    requestedValues?: InputMaybe<Array<Scalars['String']>>;
    /** The interval at which usage resets automatically, such as monthly or yearly. */
    resetPeriod?: InputMaybe<EntitlementResetPeriod>;
    /** The maximum allowed usage for this entitlement before restrictions apply. */
    usageLimit?: InputMaybe<Scalars['Float']>;
    /** Configuration for weekly usage reset. */
    weeklyResetPeriodConfiguration?: InputMaybe<WeeklyResetPeriodConfigInput>;
    /** Configuration for yearly usage reset. */
    yearlyResetPeriodConfiguration?: InputMaybe<YearlyResetPeriodConfigInput>;
};
/** Options for configuring how an entitlement is tracked or applied. */
export declare type EntitlementOptions = {
    /** The amount of usage requested by the customer. */
    requestedUsage?: InputMaybe<Scalars['Float']>;
    /** The values requested by the customer, if applicable. */
    requestedValues?: InputMaybe<Array<Scalars['String']>>;
    /** Not in use anymore */
    shouldTrack?: InputMaybe<Scalars['Boolean']>;
};
/** Entitlement reset period */
export declare enum EntitlementResetPeriod {
    /** Day */
    Day = "DAY",
    /** Hour */
    Hour = "HOUR",
    /** Month */
    Month = "MONTH",
    /** Week */
    Week = "WEEK",
    /** Year */
    Year = "YEAR"
}
/** Mode for selecting which entities to import */
export declare enum EntitySelectionMode {
    /** Exclude specified entities from import */
    BlackList = "BLACK_LIST",
    /** Only import specified entities */
    WhiteList = "WHITE_LIST"
}
/** Feature enum configuration entity */
export declare type EnumConfigurationEntityInput = {
    /** The display name for the enum configuration entity */
    displayName: Scalars['String'];
    /** The unique value identifier for the enum configuration entity */
    value: Scalars['String'];
};
/** Environment access role of the user */
export declare enum EnvironmentAccessRole {
    /** User has administrative access to the environment */
    Admin = "ADMIN",
    /** User has no access to the environment */
    None = "NONE",
    /** User has support-level access to the environment to manage customers and subscriptions */
    Support = "SUPPORT",
    /** User has read-only access to the environment */
    Viewer = "VIEWER"
}
export declare type EnvironmentFilter = {
    and?: InputMaybe<Array<EnvironmentFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<EnvironmentFilter>>;
    permanentDeletionDate?: InputMaybe<DateFieldComparison>;
    slug?: InputMaybe<StringFieldComparison>;
};
/** Input for updating an existing environment */
export declare type EnvironmentInput = {
    /** The color used to distinguish this environment in the UI */
    color?: InputMaybe<Scalars['String']>;
    /** Optional description of the environment */
    description?: InputMaybe<Scalars['String']>;
    /** The name of the environment that will be displayed in the UI */
    displayName?: InputMaybe<Scalars['String']>;
    /** Whether client-side security hardening is enabled for this environment */
    hardenClientAccessEnabled?: InputMaybe<Scalars['Boolean']>;
    /** The current provisioning status of the environment */
    provisionStatus?: InputMaybe<EnvironmentProvisionStatus>;
};
/** Configuration options for customizing an environment merge or comparison process */
export declare type EnvironmentMergeConfigurationInput = {
    /** Whether to include coupons in the merge or comparison. Defaults to true if not specified */
    includeCoupons?: InputMaybe<Scalars['Boolean']>;
};
/** Represents the provisioning status of an environment */
export declare enum EnvironmentProvisionStatus {
    /** The environment has been successfully provisioned */
    Done = "DONE",
    /** The environment provisioning process has failed */
    Failed = "FAILED",
    /** The environment provisioning process is currently in progress */
    InProgress = "IN_PROGRESS",
    /** The environment has not yet started the provisioning process */
    NotProvisioned = "NOT_PROVISIONED"
}
export declare type EnvironmentSort = {
    direction: SortDirection;
    field: EnvironmentSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum EnvironmentSortFields {
    CreatedAt = "createdAt",
    DisplayName = "displayName",
    Id = "id",
    PermanentDeletionDate = "permanentDeletionDate",
    Slug = "slug"
}
/** EnvironmentType */
export declare enum EnvironmentType {
    /** Development environment, used for testing and development purposes */
    Development = "DEVELOPMENT",
    /** Production environment, used for live applications and services */
    Production = "PRODUCTION",
    /** Sandbox environment, used for isolated testing and experimentation */
    Sandbox = "SANDBOX"
}
/** error codes */
export declare enum ErrorCode {
    AccessDeniedError = "AccessDeniedError",
    AccountNotFoundError = "AccountNotFoundError",
    /** Addon dependency missing error */
    AddonDependencyMissingError = "AddonDependencyMissingError",
    AddonHasToHavePriceError = "AddonHasToHavePriceError",
    /** Cannot delete an addon that is compatible with an addon group */
    AddonIsCompatibleWithGroup = "AddonIsCompatibleWithGroup",
    /** Cannot delete an addon that is compatible with a plan */
    AddonIsCompatibleWithPlan = "AddonIsCompatibleWithPlan",
    AddonNotFound = "AddonNotFound",
    /** Addon quantity exceeds limit error */
    AddonQuantityExceedsLimitError = "AddonQuantityExceedsLimitError",
    AddonWithDraftCannotBeDeletedError = "AddonWithDraftCannotBeDeletedError",
    /** Multiple addons not found */
    AddonsNotFound = "AddonsNotFound",
    AmountTooLarge = "AmountTooLarge",
    ArchivedCouponCantBeApplied = "ArchivedCouponCantBeApplied",
    /** The authenticated customer does not match the customer in the request */
    AuthCustomerMismatch = "AuthCustomerMismatch",
    /** The authenticated customer has read-only permissions and cannot perform this operation */
    AuthCustomerReadonly = "AuthCustomerReadonly",
    AwsMarketplaceIntegrationError = "AwsMarketplaceIntegrationError",
    AwsMarketplaceIntegrationValidationError = "AwsMarketplaceIntegrationValidationError",
    BadUserInput = "BadUserInput",
    BillingIntegrationAlreadyExistsError = "BillingIntegrationAlreadyExistsError",
    BillingIntegrationMissing = "BillingIntegrationMissing",
    BillingPeriodMissingError = "BillingPeriodMissingError",
    /** Cannot update entitlement feature group */
    CanNotUpdateEntitlementsFeatureGroup = "CanNotUpdateEntitlementsFeatureGroup",
    /** Cannot add override entitlement to a plan */
    CannotAddOverrideEntitlementToPlan = "CannotAddOverrideEntitlementToPlan",
    CannotArchiveFeatureError = "CannotArchiveFeatureError",
    CannotArchiveFeatureGroupError = "CannotArchiveFeatureGroupError",
    /** Cannot change billing integration at current customer state */
    CannotChangeBillingIntegration = "CannotChangeBillingIntegration",
    CannotDeleteCustomerError = "CannotDeleteCustomerError",
    /** Deleting the default integration is not allowed */
    CannotDeleteDefaultIntegration = "CannotDeleteDefaultIntegration",
    CannotDeleteFeatureError = "CannotDeleteFeatureError",
    CannotDeleteProductError = "CannotDeleteProductError",
    CannotEditPackageInNonDraftMode = "CannotEditPackageInNonDraftMode",
    CannotRemovePaymentMethodFromCustomerError = "CannotRemovePaymentMethodFromCustomerError",
    CannotReportUsageForEntitlementWithMeterError = "CannotReportUsageForEntitlementWithMeterError",
    /** Cannot update expireAt for an expired credit grant */
    CannotUpdateExpireAtForExpiredCreditGrantError = "CannotUpdateExpireAtForExpiredCreditGrantError",
    /** Can not update unit transformation since this feature has connected active subscriptions */
    CannotUpdateUnitTransformationError = "CannotUpdateUnitTransformationError",
    CannotUpsertToPackageThatHasDraft = "CannotUpsertToPackageThatHasDraft",
    /** Changing paying customer is not supported */
    ChangingPayingCustomerIsNotSupportedError = "ChangingPayingCustomerIsNotSupportedError",
    CheckoutIsNotSupported = "CheckoutIsNotSupported",
    CouponNotFound = "CouponNotFound",
    /** Credit grant not found */
    CreditGrantNotFound = "CreditGrantNotFound",
    /** Custom currency not found */
    CustomCurrencyNotFound = "CustomCurrencyNotFound",
    CustomerAlreadyHaveCustomerCoupon = "CustomerAlreadyHaveCustomerCoupon",
    CustomerAlreadyUsesCoupon = "CustomerAlreadyUsesCoupon",
    CustomerHasNoEmailAddress = "CustomerHasNoEmailAddress",
    CustomerNoBillingId = "CustomerNoBillingId",
    CustomerNotFound = "CustomerNotFound",
    CustomerResourceNotFound = "CustomerResourceNotFound",
    /** Deprecated estimate subscription error */
    DeprecatedEstimateSubscriptionError = "DeprecatedEstimateSubscriptionError",
    DowngradeBillingPeriodNotSupportedError = "DowngradeBillingPeriodNotSupportedError",
    /** Draft addon cannot be archived */
    DraftAddonCantBeArchived = "DraftAddonCantBeArchived",
    DraftPlanCantBeArchived = "DraftPlanCantBeArchived",
    /** Duplicate addons provisioned error */
    DuplicateAddonProvisionedError = "DuplicateAddonProvisionedError",
    /** Duplicate integration for same non billing vendor identifier not allowed */
    DuplicateIntegrationNotAllowed = "DuplicateIntegrationNotAllowed",
    DuplicateProductValidationError = "DuplicateProductValidationError",
    DuplicatedEntityNotAllowed = "DuplicatedEntityNotAllowed",
    EditAllowedOnDraftPackageOnlyError = "EditAllowedOnDraftPackageOnlyError",
    /** Entitlement belongs to feature groups and cannot be deleted */
    EntitlementBelongsToFeatureGroupError = "EntitlementBelongsToFeatureGroupError",
    EntitlementLimitExceededError = "EntitlementLimitExceededError",
    EntitlementUsageOutOfRangeError = "EntitlementUsageOutOfRangeError",
    EntitlementsMustBelongToSamePackage = "EntitlementsMustBelongToSamePackage",
    EntityIdDifferentFromRefIdError = "EntityIdDifferentFromRefIdError",
    EntityIsArchivedError = "EntityIsArchivedError",
    EnvironmentMissing = "EnvironmentMissing",
    ExperimentAlreadyRunning = "ExperimentAlreadyRunning",
    ExperimentNotFoundError = "ExperimentNotFoundError",
    ExperimentStatusError = "ExperimentStatusError",
    /** field expireAt must be later than effectiveAt for credit grants */
    ExpireAtMustBeLaterThanEffectiveAtError = "ExpireAtMustBeLaterThanEffectiveAtError",
    FailedToCreateCheckoutSessionError = "FailedToCreateCheckoutSessionError",
    FailedToImportCustomer = "FailedToImportCustomer",
    /** Failed to import subscriptions */
    FailedToImportSubscriptions = "FailedToImportSubscriptions",
    /** Failed to resolve billing integration */
    FailedToResolveBillingIntegration = "FailedToResolveBillingIntegration",
    FeatureConfigurationExceededLimitError = "FeatureConfigurationExceededLimitError",
    /** Feature group is missing required features */
    FeatureGroupMissingFeaturesError = "FeatureGroupMissingFeaturesError",
    FeatureGroupNotFoundError = "FeatureGroupNotFoundError",
    /** Feature does not belong to the specified feature group */
    FeatureNotBelongToFeatureGroupError = "FeatureNotBelongToFeatureGroupError",
    FeatureNotFound = "FeatureNotFound",
    FetchAllCountriesPricesNotAllowed = "FetchAllCountriesPricesNotAllowed",
    /** Free plan can't have compatible package groups error */
    FreePlanCantHaveCompatiblePackageGroupError = "FreePlanCantHaveCompatiblePackageGroupError",
    /** Too many graphql aliases were used in a single request */
    GraphQlAliasesLimitExceeded = "GraphQLAliasesLimitExceeded",
    /** Too many batched operations were used in a single request */
    GraphQlBatchedOperationsLimitExceeded = "GraphQLBatchedOperationsLimitExceeded",
    /** Unsupported directive */
    GraphQlUnsupportedDirective = "GraphQLUnsupportedDirective",
    HubspotIntegrationError = "HubspotIntegrationError",
    IdentityForbidden = "IdentityForbidden",
    ImportAlreadyInProgress = "ImportAlreadyInProgress",
    ImportSubscriptionsBulkError = "ImportSubscriptionsBulkError",
    IncompatibleSubscriptionAddon = "IncompatibleSubscriptionAddon",
    InitStripePaymentMethodError = "InitStripePaymentMethodError",
    IntegrationNotFound = "IntegrationNotFound",
    IntegrationValidationError = "IntegrationValidationError",
    IntegrityViolation = "IntegrityViolation",
    InvalidAddressError = "InvalidAddressError",
    InvalidArgumentError = "InvalidArgumentError",
    InvalidCancellationDate = "InvalidCancellationDate",
    InvalidDoggoSignatureError = "InvalidDoggoSignatureError",
    InvalidEntitlementResetPeriod = "InvalidEntitlementResetPeriod",
    InvalidMemberDelete = "InvalidMemberDelete",
    InvalidMetadataError = "InvalidMetadataError",
    InvalidQuantity = "InvalidQuantity",
    InvalidSubscriptionStatus = "InvalidSubscriptionStatus",
    InvalidUpdatePriceUnitAmountError = "InvalidUpdatePriceUnitAmountError",
    MemberInvitationError = "MemberInvitationError",
    MemberNotFound = "MemberNotFound",
    MergeEnvironmentValidationError = "MergeEnvironmentValidationError",
    MeterMustBeAssociatedToMeteredFeature = "MeterMustBeAssociatedToMeteredFeature",
    MeteringNotAvailableForFeatureType = "MeteringNotAvailableForFeatureType",
    MissingEntityIdError = "MissingEntityIdError",
    MissingSubscriptionInvoiceError = "MissingSubscriptionInvoiceError",
    /** Multi subscription product cannot be a source of auto-cancellation rules */
    MultiSubscriptionCantBeAutoCancellationSourceError = "MultiSubscriptionCantBeAutoCancellationSourceError",
    /** This account has no access to the requested feature */
    NoFeatureEntitlementError = "NoFeatureEntitlementError",
    NoFeatureEntitlementInSubscription = "NoFeatureEntitlementInSubscription",
    NoProductsAvailable = "NoProductsAvailable",
    OperationNotAllowedDuringInProgressExperiment = "OperationNotAllowedDuringInProgressExperiment",
    PackageAlreadyPublished = "PackageAlreadyPublished",
    /** Package group min items error */
    PackageGroupMinItemsError = "PackageGroupMinItemsError",
    PackageGroupNotFound = "PackageGroupNotFound",
    PackagePricingTypeNotSet = "PackagePricingTypeNotSet",
    PaymentMethodNotFoundError = "PaymentMethodNotFoundError",
    PlanCannotBePublishWhenBasePlanIsDraft = "PlanCannotBePublishWhenBasePlanIsDraft",
    PlanCannotBePublishWhenCompatibleAddonIsDraft = "PlanCannotBePublishWhenCompatibleAddonIsDraft",
    PlanIsUsedAsDefaultStartPlan = "PlanIsUsedAsDefaultStartPlan",
    PlanIsUsedAsDowngradePlan = "PlanIsUsedAsDowngradePlan",
    PlanNotFound = "PlanNotFound",
    PlanWithChildCantBeDeleted = "PlanWithChildCantBeDeleted",
    PlansCircularDependencyError = "PlansCircularDependencyError",
    PreparePaymentMethodFormError = "PreparePaymentMethodFormError",
    PriceNotFound = "PriceNotFound",
    ProductNotFoundError = "ProductNotFoundError",
    PromotionCodeCustomerNotFirstPurchase = "PromotionCodeCustomerNotFirstPurchase",
    PromotionCodeMaxRedemptionsReached = "PromotionCodeMaxRedemptionsReached",
    PromotionCodeMinimumAmountNotReached = "PromotionCodeMinimumAmountNotReached",
    PromotionCodeNotActive = "PromotionCodeNotActive",
    PromotionCodeNotForCustomer = "PromotionCodeNotForCustomer",
    PromotionCodeNotFound = "PromotionCodeNotFound",
    PromotionalEntitlementNotFoundError = "PromotionalEntitlementNotFoundError",
    RateLimitExceeded = "RateLimitExceeded",
    RecalculateEntitlementsError = "RecalculateEntitlementsError",
    RequiredSsoAuthenticationError = "RequiredSsoAuthenticationError",
    ResyncAlreadyInProgress = "ResyncAlreadyInProgress",
    ScheduledMigrationAlreadyExistsError = "ScheduledMigrationAlreadyExistsError",
    SelectedBillingModelDoesntMatchImportedItemError = "SelectedBillingModelDoesntMatchImportedItemError",
    /** Single subscription product cannot be a target of auto-cancellation rules */
    SingleSubscriptionCantBeAutoCancellationTargetError = "SingleSubscriptionCantBeAutoCancellationTargetError",
    StripeCustomerIsDeleted = "StripeCustomerIsDeleted",
    StripeError = "StripeError",
    SubscriptionAlreadyCanceledOrExpired = "SubscriptionAlreadyCanceledOrExpired",
    SubscriptionAlreadyOnLatestPlanError = "SubscriptionAlreadyOnLatestPlanError",
    SubscriptionDoesNotHaveBillingPeriod = "SubscriptionDoesNotHaveBillingPeriod",
    SubscriptionInvoiceStatusError = "SubscriptionInvoiceStatusError",
    SubscriptionMustHaveSinglePlanError = "SubscriptionMustHaveSinglePlanError",
    SubscriptionNoBillingId = "SubscriptionNoBillingId",
    SubscriptionNotFound = "SubscriptionNotFound",
    /** Too many custom currencies */
    TooManyCustomCurrencies = "TooManyCustomCurrencies",
    TooManySubscriptionsPerCustomer = "TooManySubscriptionsPerCustomer",
    TrialMustBeCancelledImmediately = "TrialMustBeCancelledImmediately",
    UnPublishedPackage = "UnPublishedPackage",
    Unauthenticated = "Unauthenticated",
    UnexpectedError = "UnexpectedError",
    UnsupportedFeatureType = "UnsupportedFeatureType",
    /** Unsupported parameter */
    UnsupportedParameter = "UnsupportedParameter",
    UnsupportedSubscriptionScheduleType = "UnsupportedSubscriptionScheduleType",
    UnsupportedVendorIdentifier = "UnsupportedVendorIdentifier",
    UsageMeasurementDiffOutOfRangeError = "UsageMeasurementDiffOutOfRangeError",
    VersionExceedsMaxValueError = "VersionExceedsMaxValueError",
    /** Workflow trigger not found */
    WorkflowTriggerNotFound = "WorkflowTriggerNotFound"
}
export declare type EstimateSubscriptionInput = {
    addons?: InputMaybe<Array<SubscriptionAddonInput>>;
    /** Coupon input */
    appliedCoupon?: InputMaybe<SubscriptionCouponInput>;
    billableFeatures?: InputMaybe<Array<BillableFeatureInput>>;
    billingCountryCode?: InputMaybe<Scalars['String']>;
    billingInformation?: InputMaybe<SubscriptionBillingInfo>;
    billingPeriod?: InputMaybe<BillingPeriod>;
    customerId: Scalars['String'];
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The customer that will pay for the subscription */
    payingCustomerId?: InputMaybe<Scalars['String']>;
    planId: Scalars['String'];
    priceUnitAmount?: InputMaybe<Scalars['Float']>;
    promotionCode?: InputMaybe<Scalars['String']>;
    resourceId?: InputMaybe<Scalars['String']>;
    skipTrial?: InputMaybe<Scalars['Boolean']>;
    startDate?: InputMaybe<Scalars['DateTime']>;
    /** trial configuration to override the default values from plan if exists */
    trialOverrideConfiguration?: InputMaybe<TrialOverrideConfigurationInput>;
    unitQuantity?: InputMaybe<Scalars['Float']>;
};
export declare type EstimateSubscriptionUpdateInput = {
    addons?: InputMaybe<Array<SubscriptionAddonInput>>;
    /** Coupon input */
    appliedCoupon?: InputMaybe<SubscriptionCouponInput>;
    billableFeatures?: InputMaybe<Array<BillableFeatureInput>>;
    environmentId?: InputMaybe<Scalars['UUID']>;
    promotionCode?: InputMaybe<Scalars['String']>;
    subscriptionId: Scalars['String'];
    unitQuantity?: InputMaybe<Scalars['Float']>;
};
/** Event actor type */
export declare enum EventActor {
    /** Client SDK with hardened authentication */
    AppCustomer = "APP_CUSTOMER",
    /** Client SDK */
    AppPublic = "APP_PUBLIC",
    /** Backend SDK */
    AppServer = "APP_SERVER",
    /** AWS triggered event */
    Aws = "AWS",
    /** Import triggered event */
    Import = "IMPORT",
    /** Migration triggered event */
    Migration = "MIGRATION",
    /** Salesforce API key */
    Salesforce = "SALESFORCE",
    /** Stigg scheduler */
    Scheduler = "SCHEDULER",
    /** Stigg user service key */
    Service = "SERVICE",
    /** Stripe triggered event */
    Stripe = "STRIPE",
    /** Stigg customer support */
    Support = "SUPPORT",
    /** Stigg internal system */
    System = "SYSTEM",
    /** Web application user */
    User = "USER",
    /** Workflow triggered event */
    Workflow = "WORKFLOW"
}
/** Event entity type */
export declare enum EventEntityType {
    /** Add-on entity */
    Addon = "ADDON",
    /** Coupon entity */
    Coupon = "COUPON",
    /** Customer entity */
    Customer = "CUSTOMER",
    /** Entitlement entity */
    Entitlement = "ENTITLEMENT",
    /** Feature entity */
    Feature = "FEATURE",
    /** Feature Group Entity */
    FeatureGroup = "FEATURE_GROUP",
    /** Import entity */
    Import = "IMPORT",
    /** Measurement entity */
    Measurement = "MEASUREMENT",
    /** Package entity */
    Package = "PACKAGE",
    /** Package group entity */
    PackageGroup = "PACKAGE_GROUP",
    /** Plan entity */
    Plan = "PLAN",
    /** Product entity */
    Product = "PRODUCT",
    /** Promotional entitlement entity */
    PromotionalEntitlement = "PROMOTIONAL_ENTITLEMENT",
    /** Subscription entity */
    Subscription = "SUBSCRIPTION"
}
export declare type EventLogCreatedAtFilterComparison = {
    gte?: InputMaybe<Scalars['DateTime']>;
    lte?: InputMaybe<Scalars['DateTime']>;
};
export declare type EventLogEntityIdFilterComparison = {
    eq?: InputMaybe<Scalars['String']>;
    in?: InputMaybe<Array<Scalars['String']>>;
};
export declare type EventLogEnvironmentIdFilterComparison = {
    eq?: InputMaybe<Scalars['UUID']>;
};
export declare type EventLogEventLogTypeFilterComparison = {
    eq?: InputMaybe<EventLogType>;
    in?: InputMaybe<Array<EventLogType>>;
    neq?: InputMaybe<EventLogType>;
    notIn?: InputMaybe<Array<EventLogType>>;
};
export declare type EventLogFilter = {
    and?: InputMaybe<Array<EventLogFilter>>;
    createdAt?: InputMaybe<EventLogCreatedAtFilterComparison>;
    entityId?: InputMaybe<EventLogEntityIdFilterComparison>;
    environmentId: EventLogEnvironmentIdFilterComparison;
    eventLogType?: InputMaybe<EventLogEventLogTypeFilterComparison>;
    id?: InputMaybe<EventLogIdFilterComparison>;
    or?: InputMaybe<Array<EventLogFilter>>;
    parentEntityId?: InputMaybe<EventLogParentEntityIdFilterComparison>;
};
export declare type EventLogIdFilterComparison = {
    eq?: InputMaybe<Scalars['String']>;
};
export declare type EventLogParentEntityIdFilterComparison = {
    eq?: InputMaybe<Scalars['String']>;
    in?: InputMaybe<Array<Scalars['String']>>;
};
export declare type EventLogSort = {
    direction: SortDirection;
    field: EventLogSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum EventLogSortFields {
    CreatedAt = "createdAt",
    EntityId = "entityId",
    EnvironmentId = "environmentId",
    EventLogType = "eventLogType",
    Id = "id",
    ParentEntityId = "parentEntityId"
}
/** Event log type */
export declare enum EventLogType {
    /** Addon created */
    AddonCreated = "ADDON_CREATED",
    /** Addon deleted */
    AddonDeleted = "ADDON_DELETED",
    /** Addon updated */
    AddonUpdated = "ADDON_UPDATED",
    /** Coupon archived */
    CouponArchived = "COUPON_ARCHIVED",
    /** Coupon created */
    CouponCreated = "COUPON_CREATED",
    /** Coupon updated */
    CouponUpdated = "COUPON_UPDATED",
    /** Create subscription failed */
    CreateSubscriptionFailed = "CREATE_SUBSCRIPTION_FAILED",
    /** Credits expired */
    CreditsExpired = "CREDITS_EXPIRED",
    /** Credits granted */
    CreditsGranted = "CREDITS_GRANTED",
    /** Customer created */
    CustomerCreated = "CUSTOMER_CREATED",
    /** Customer deleted */
    CustomerDeleted = "CUSTOMER_DELETED",
    /** Customer entitlement calculation triggered */
    CustomerEntitlementCalculationTriggered = "CUSTOMER_ENTITLEMENT_CALCULATION_TRIGGERED",
    /** Customer payment failed */
    CustomerPaymentFailed = "CUSTOMER_PAYMENT_FAILED",
    /** Customer resource entitlement calculation triggered */
    CustomerResourceEntitlementCalculationTriggered = "CUSTOMER_RESOURCE_ENTITLEMENT_CALCULATION_TRIGGERED",
    /** Customer updated */
    CustomerUpdated = "CUSTOMER_UPDATED",
    /** Edge API customer data resync */
    EdgeApiCustomerDataResync = "EDGE_API_CUSTOMER_DATA_RESYNC",
    /** Edge API data resync */
    EdgeApiDataResync = "EDGE_API_DATA_RESYNC",
    /** Edge API Doggo resync */
    EdgeApiDoggoResync = "EDGE_API_DOGGO_RESYNC",
    /** Edge API package entitlements data resync */
    EdgeApiPackageEntitlementsDataResync = "EDGE_API_PACKAGE_ENTITLEMENTS_DATA_RESYNC",
    /** Edge API subscriptions data resync */
    EdgeApiSubscriptionsDataResync = "EDGE_API_SUBSCRIPTIONS_DATA_RESYNC",
    /** Entitlements updated */
    EntitlementsUpdated = "ENTITLEMENTS_UPDATED",
    /** Entitlement denied */
    EntitlementDenied = "ENTITLEMENT_DENIED",
    /** Entitlement granted */
    EntitlementGranted = "ENTITLEMENT_GRANTED",
    /** Entitlement requested */
    EntitlementRequested = "ENTITLEMENT_REQUESTED",
    /** Entitlement usage exceeded */
    EntitlementUsageExceeded = "ENTITLEMENT_USAGE_EXCEEDED",
    /** Environment deleted */
    EnvironmentDeleted = "ENVIRONMENT_DELETED",
    /** Feature archived */
    FeatureArchived = "FEATURE_ARCHIVED",
    /** Feature created */
    FeatureCreated = "FEATURE_CREATED",
    /** Feature deleted */
    FeatureDeleted = "FEATURE_DELETED",
    /** Feature group archived */
    FeatureGroupArchived = "FEATURE_GROUP_ARCHIVED",
    /** Feature group created */
    FeatureGroupCreated = "FEATURE_GROUP_CREATED",
    /** Feature group un-archived */
    FeatureGroupUnArchived = "FEATURE_GROUP_UN_ARCHIVED",
    /** Feature group updated */
    FeatureGroupUpdated = "FEATURE_GROUP_UPDATED",
    /** Feature updated */
    FeatureUpdated = "FEATURE_UPDATED",
    /** Import integration catalog triggered */
    ImportIntegrationCatalogTriggered = "IMPORT_INTEGRATION_CATALOG_TRIGGERED",
    /** Import integration customers triggered */
    ImportIntegrationCustomersTriggered = "IMPORT_INTEGRATION_CUSTOMERS_TRIGGERED",
    /** Import subscriptions bulk triggered */
    ImportSubscriptionsBulkTriggered = "IMPORT_SUBSCRIPTIONS_BULK_TRIGGERED",
    /** Measurement reported */
    MeasurementReported = "MEASUREMENT_REPORTED",
    /** Package group created */
    PackageGroupCreated = "PACKAGE_GROUP_CREATED",
    /** Package group updated */
    PackageGroupUpdated = "PACKAGE_GROUP_UPDATED",
    /** Package published */
    PackagePublished = "PACKAGE_PUBLISHED",
    /** Plan created */
    PlanCreated = "PLAN_CREATED",
    /** Plan deleted */
    PlanDeleted = "PLAN_DELETED",
    /** Plan updated */
    PlanUpdated = "PLAN_UPDATED",
    /** Product created */
    ProductCreated = "PRODUCT_CREATED",
    /** Product deleted */
    ProductDeleted = "PRODUCT_DELETED",
    /** Product updated */
    ProductUpdated = "PRODUCT_UPDATED",
    /** Promotional entitlement expired */
    PromotionalEntitlementExpired = "PROMOTIONAL_ENTITLEMENT_EXPIRED",
    /** Promotional entitlement granted */
    PromotionalEntitlementGranted = "PROMOTIONAL_ENTITLEMENT_GRANTED",
    /** Promotional entitlement revoked */
    PromotionalEntitlementRevoked = "PROMOTIONAL_ENTITLEMENT_REVOKED",
    /** Promotional entitlement updated */
    PromotionalEntitlementUpdated = "PROMOTIONAL_ENTITLEMENT_UPDATED",
    /** Recalculate entitlements triggered */
    RecalculateEntitlementsTriggered = "RECALCULATE_ENTITLEMENTS_TRIGGERED",
    /** Resync integration triggered */
    ResyncIntegrationTriggered = "RESYNC_INTEGRATION_TRIGGERED",
    /** Subscriptions migrated */
    SubscriptionsMigrated = "SUBSCRIPTIONS_MIGRATED",
    /** Subscriptions migration triggered */
    SubscriptionsMigrationTriggered = "SUBSCRIPTIONS_MIGRATION_TRIGGERED",
    /** Subscription billing month ends soon */
    SubscriptionBillingMonthEndsSoon = "SUBSCRIPTION_BILLING_MONTH_ENDS_SOON",
    /** Subscription canceled */
    SubscriptionCanceled = "SUBSCRIPTION_CANCELED",
    /** Subscription created */
    SubscriptionCreated = "SUBSCRIPTION_CREATED",
    /** Subscription expired */
    SubscriptionExpired = "SUBSCRIPTION_EXPIRED",
    /** Subscription spent limit exceeded */
    SubscriptionSpentLimitExceeded = "SUBSCRIPTION_SPENT_LIMIT_EXCEEDED",
    /** Subscription trial converted */
    SubscriptionTrialConverted = "SUBSCRIPTION_TRIAL_CONVERTED",
    /** Subscription trial ends soon */
    SubscriptionTrialEndsSoon = "SUBSCRIPTION_TRIAL_ENDS_SOON",
    /** Subscription trial expired */
    SubscriptionTrialExpired = "SUBSCRIPTION_TRIAL_EXPIRED",
    /** Subscription trial started */
    SubscriptionTrialStarted = "SUBSCRIPTION_TRIAL_STARTED",
    /** Subscription updated */
    SubscriptionUpdated = "SUBSCRIPTION_UPDATED",
    /** Subscription usage charge triggered */
    SubscriptionUsageChargeTriggered = "SUBSCRIPTION_USAGE_CHARGE_TRIGGERED",
    /** Subscription usage updated */
    SubscriptionUsageUpdated = "SUBSCRIPTION_USAGE_UPDATED",
    /** Sync failed */
    SyncFailed = "SYNC_FAILED",
    /** Widget configuration updated */
    WidgetConfigurationUpdated = "WIDGET_CONFIGURATION_UPDATED"
}
/** Input parameters for retrieving events fields */
export declare type EventsFieldsInput = {
    /** Customer id */
    customerId?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId: Scalars['UUID'];
    /** Reference identifier for the feature */
    featureId?: InputMaybe<Scalars['String']>;
    /** Filters to apply to the events fields */
    filters?: InputMaybe<Array<MeterFilterDefinitionInput>>;
    /** Meter id */
    meterId?: InputMaybe<Scalars['String']>;
    /** Resource id */
    resourceId?: InputMaybe<Scalars['String']>;
    /** Exclude fields with more than this number of unique values */
    uniqueValuesLimit?: InputMaybe<Scalars['Float']>;
};
export declare type ExperimentFilter = {
    and?: InputMaybe<Array<ExperimentFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    customers?: InputMaybe<ExperimentFilterCustomerFilter>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    name?: InputMaybe<StringFieldComparison>;
    or?: InputMaybe<Array<ExperimentFilter>>;
    productId?: InputMaybe<StringFieldComparison>;
    refId?: InputMaybe<StringFieldComparison>;
    status?: InputMaybe<ExperimentStatusFilterComparison>;
};
export declare type ExperimentFilterCustomerFilter = {
    and?: InputMaybe<Array<ExperimentFilterCustomerFilter>>;
    billingId?: InputMaybe<StringFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    crmHubspotCompanyId?: InputMaybe<StringFieldComparison>;
    crmHubspotCompanyUrl?: InputMaybe<StringFieldComparison>;
    crmId?: InputMaybe<StringFieldComparison>;
    customerId?: InputMaybe<StringFieldComparison>;
    deletedAt?: InputMaybe<DateFieldComparison>;
    email?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    name?: InputMaybe<StringFieldComparison>;
    or?: InputMaybe<Array<ExperimentFilterCustomerFilter>>;
    refId?: InputMaybe<StringFieldComparison>;
    salesforceId?: InputMaybe<StringFieldComparison>;
    searchQuery?: InputMaybe<CustomerSearchQueryFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
export declare type ExperimentSort = {
    direction: SortDirection;
    field: ExperimentSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum ExperimentSortFields {
    CreatedAt = "createdAt",
    EnvironmentId = "environmentId",
    Id = "id",
    Name = "name",
    ProductId = "productId",
    RefId = "refId",
    Status = "status"
}
/** Query parameters for retrieving experiment statistics */
export declare type ExperimentStatsQuery = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The unique identifier for the experiment */
    experimentRefId: Scalars['String'];
};
/** The status of the experiment */
export declare enum ExperimentStatus {
    /** Experiment has been completed */
    Completed = "COMPLETED",
    /** Experiment is in draft state */
    Draft = "DRAFT",
    /** Experiment is currently running */
    InProgress = "IN_PROGRESS"
}
export declare type ExperimentStatusFilterComparison = {
    eq?: InputMaybe<ExperimentStatus>;
    gt?: InputMaybe<ExperimentStatus>;
    gte?: InputMaybe<ExperimentStatus>;
    iLike?: InputMaybe<ExperimentStatus>;
    in?: InputMaybe<Array<ExperimentStatus>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<ExperimentStatus>;
    lt?: InputMaybe<ExperimentStatus>;
    lte?: InputMaybe<ExperimentStatus>;
    neq?: InputMaybe<ExperimentStatus>;
    notILike?: InputMaybe<ExperimentStatus>;
    notIn?: InputMaybe<Array<ExperimentStatus>>;
    notLike?: InputMaybe<ExperimentStatus>;
};
/** Input for getting the associated latest packages for a feature */
export declare type FeatureAssociatedLatestPackages = {
    /** The unique identifier for the environment */
    environmentId: Scalars['UUID'];
    /** The ID of the feature */
    featureId: Scalars['String'];
};
export declare type FeatureFilter = {
    and?: InputMaybe<Array<FeatureFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    description?: InputMaybe<StringFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    featureStatus?: InputMaybe<FeatureStatusFilterComparison>;
    featureType?: InputMaybe<FeatureTypeFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    meterType?: InputMaybe<MeterTypeFilterComparison>;
    or?: InputMaybe<Array<FeatureFilter>>;
    refId?: InputMaybe<StringFieldComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
/** Input for getting associated latest packages of a feature group */
export declare type FeatureGroupAssociatedLatestPackagesInput = {
    /** The unique identifier for the environment */
    environmentId: Scalars['UUID'];
    /** The feature group id */
    featureGroupId: Scalars['String'];
};
export declare type FeatureGroupFilter = {
    and?: InputMaybe<Array<FeatureGroupFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    featureGroupId?: InputMaybe<StringFieldComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    isLatest?: InputMaybe<BooleanFieldComparison>;
    or?: InputMaybe<Array<FeatureGroupFilter>>;
    status?: InputMaybe<FeatureGroupStatusFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
    versionNumber?: InputMaybe<IntFieldComparison>;
};
export declare type FeatureGroupSort = {
    direction: SortDirection;
    field: FeatureGroupSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum FeatureGroupSortFields {
    CreatedAt = "createdAt",
    DisplayName = "displayName",
    EnvironmentId = "environmentId",
    FeatureGroupId = "featureGroupId",
    Id = "id",
    IsLatest = "isLatest",
    Status = "status",
    UpdatedAt = "updatedAt",
    VersionNumber = "versionNumber"
}
/** Feature group status */
export declare enum FeatureGroupStatus {
    /** The feature group is archived */
    Archived = "ARCHIVED",
    /** The feature group is published */
    Published = "PUBLISHED"
}
export declare type FeatureGroupStatusFilterComparison = {
    eq?: InputMaybe<FeatureGroupStatus>;
    gt?: InputMaybe<FeatureGroupStatus>;
    gte?: InputMaybe<FeatureGroupStatus>;
    iLike?: InputMaybe<FeatureGroupStatus>;
    in?: InputMaybe<Array<FeatureGroupStatus>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<FeatureGroupStatus>;
    lt?: InputMaybe<FeatureGroupStatus>;
    lte?: InputMaybe<FeatureGroupStatus>;
    neq?: InputMaybe<FeatureGroupStatus>;
    notILike?: InputMaybe<FeatureGroupStatus>;
    notIn?: InputMaybe<Array<FeatureGroupStatus>>;
    notLike?: InputMaybe<FeatureGroupStatus>;
};
/** Input for creating a feature */
export declare type FeatureInput = {
    /** The additional metadata for the feature */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** The description for the feature */
    description?: InputMaybe<Scalars['String']>;
    /** The display name for the feature */
    displayName: Scalars['String'];
    /** The configuration data for the feature */
    enumConfiguration?: InputMaybe<Array<EnumConfigurationEntityInput>>;
    /** The unique identifier for the environment */
    environmentId: Scalars['UUID'];
    /** The status of the feature */
    featureStatus?: InputMaybe<FeatureStatus>;
    /** The type of the feature */
    featureType: FeatureType;
    /** The units for the feature */
    featureUnits?: InputMaybe<Scalars['String']>;
    /** The plural units for the feature */
    featureUnitsPlural?: InputMaybe<Scalars['String']>;
    /** Input for creating a meter */
    meter?: InputMaybe<CreateMeter>;
    /** The meter type for the feature */
    meterType?: InputMaybe<MeterType>;
    /** The unique identifier for the feature */
    refId: Scalars['String'];
    /** Unit transformation to be applied to the reported usage */
    unitTransformation?: InputMaybe<UnitTransformationInput>;
};
export declare type FeatureSort = {
    direction: SortDirection;
    field: FeatureSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum FeatureSortFields {
    CreatedAt = "createdAt",
    Description = "description",
    DisplayName = "displayName",
    EnvironmentId = "environmentId",
    FeatureStatus = "featureStatus",
    FeatureType = "featureType",
    Id = "id",
    MeterType = "meterType",
    RefId = "refId",
    UpdatedAt = "updatedAt"
}
/** Feature status */
export declare enum FeatureStatus {
    /** Active feature */
    Active = "ACTIVE",
    /** New feature */
    New = "NEW",
    /** Suspended feature */
    Suspended = "SUSPENDED"
}
export declare type FeatureStatusFilterComparison = {
    eq?: InputMaybe<FeatureStatus>;
    gt?: InputMaybe<FeatureStatus>;
    gte?: InputMaybe<FeatureStatus>;
    iLike?: InputMaybe<FeatureStatus>;
    in?: InputMaybe<Array<FeatureStatus>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<FeatureStatus>;
    lt?: InputMaybe<FeatureStatus>;
    lte?: InputMaybe<FeatureStatus>;
    neq?: InputMaybe<FeatureStatus>;
    notILike?: InputMaybe<FeatureStatus>;
    notIn?: InputMaybe<Array<FeatureStatus>>;
    notLike?: InputMaybe<FeatureStatus>;
};
/** The type of the feature */
export declare enum FeatureType {
    /** Boolean feature type */
    Boolean = "BOOLEAN",
    /** Enum feature type */
    Enum = "ENUM",
    /** Numeric feature type */
    Number = "NUMBER"
}
export declare type FeatureTypeFilterComparison = {
    eq?: InputMaybe<FeatureType>;
    gt?: InputMaybe<FeatureType>;
    gte?: InputMaybe<FeatureType>;
    iLike?: InputMaybe<FeatureType>;
    in?: InputMaybe<Array<FeatureType>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<FeatureType>;
    lt?: InputMaybe<FeatureType>;
    lte?: InputMaybe<FeatureType>;
    neq?: InputMaybe<FeatureType>;
    notILike?: InputMaybe<FeatureType>;
    notIn?: InputMaybe<Array<FeatureType>>;
    notLike?: InputMaybe<FeatureType>;
};
/** Query for fetching a single entitlement for a specific feature and customer. */
export declare type FetchEntitlementQuery = {
    /** Identifier of the customer. */
    customerId: Scalars['String'];
    /** The environment identifier used to resolve the entitlement context. */
    environmentId?: InputMaybe<Scalars['String']>;
    /** The internal ID of the feature linked to this entitlement. */
    featureId: Scalars['String'];
    /** Options for configuring how an entitlement is tracked or applied. */
    options?: InputMaybe<EntitlementOptions>;
    /** The scoped resource Identifier. */
    resourceId?: InputMaybe<Scalars['String']>;
};
/** Query for retrieving all entitlements for a customer in a specific environment. */
export declare type FetchEntitlementsQuery = {
    /** Identifier of the customer. */
    customerId: Scalars['String'];
    /** The environment context for entitlement resolution. */
    environmentId?: InputMaybe<Scalars['String']>;
    /** The scoped resource Identifier. */
    resourceId?: InputMaybe<Scalars['String']>;
};
/** Input for defining font style for a text variant. */
export declare type FontVariantInput = {
    /** Size of the text in px or rem. */
    fontSize?: InputMaybe<Scalars['Float']>;
    /** Weight of the font, such as normal or bold. */
    fontWeight?: InputMaybe<FontWeight>;
};
/** Font weight */
export declare enum FontWeight {
    /** Bold font weight. */
    Bold = "BOLD",
    /** Standard font weight. */
    Normal = "NORMAL"
}
export declare type GetActiveSubscriptionsInput = {
    customerId: Scalars['String'];
    environmentId?: InputMaybe<Scalars['UUID']>;
    resourceId?: InputMaybe<Scalars['String']>;
    resourceIds?: InputMaybe<Array<Scalars['String']>>;
};
/** Input configuration for retrieving Auth0 applications */
export declare type GetAuth0ApplicationsInput = {
    /** Domain of the Auth0 client */
    clientDomain: Scalars['String'];
    /** ID of the Auth0 client */
    clientId: Scalars['String'];
    /** Secret of the Auth0 client */
    clientSecret: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
};
/** Input for retrieving credit grants */
export declare type GetCreditGrantsInput = {
    /** The custom currency ID of the credit grant */
    currencyId?: InputMaybe<Scalars['String']>;
    /** The customer ID of the credit grant */
    customerId: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The resource ID of the credit grant */
    resourceId?: InputMaybe<Scalars['String']>;
};
/** Get a customer by slug */
export declare type GetCustomerByRefIdInput = {
    /** Customer slug */
    customerId: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
};
/** Get Package By Ref Id Input */
export declare type GetPackageByRefIdInput = {
    /** The unique identifier for the environment */
    environmentId: Scalars['String'];
    /** The unique identifier for the entity */
    refId: Scalars['String'];
    /** The version number of the package */
    versionNumber?: InputMaybe<Scalars['Float']>;
};
/** The input type for getting a package group */
export declare type GetPackageGroup = {
    /** The unique identifier for the environment */
    environmentId: Scalars['String'];
    /** The id of the package group to filter by */
    packageGroupId: Scalars['String'];
    /** The version number of the package group to filter by */
    versionNumber?: InputMaybe<Scalars['Float']>;
};
/** Input for fetching the paywall */
export declare type GetPaywallInput = {
    /** The country code for billing, e.g. US */
    billingCountryCode?: InputMaybe<Scalars['String']>;
    /** Context for the paywall, e.g. "checkout" or "subscription" */
    context?: InputMaybe<WidgetType>;
    /** The customer ID for whom the paywall is being fetched */
    customerId?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Whether to fetch prices for all countries or just the specified billing country */
    fetchAllCountriesPrices?: InputMaybe<Scalars['Boolean']>;
    /** Whether to include hidden plans in the paywall */
    includeHiddenPlans?: InputMaybe<Scalars['Boolean']>;
    /** The product ID for which the paywall is being fetched */
    productId?: InputMaybe<Scalars['String']>;
    /** The resource ID for which the paywall is being fetched */
    resourceId?: InputMaybe<Scalars['String']>;
};
/** Get subscription input */
export declare type GetSubscriptionInput = {
    /** The environment ID the subscription belongs to */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The subscription ID to retrieve */
    subscriptionId: Scalars['String'];
};
/** Input object used to retrieve current widget configuration for the environment. */
export declare type GetWidgetConfigurationInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
};
/** Get workflow triggers input */
export declare type GetWorkflowTriggersInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Trigger id */
    triggerId?: InputMaybe<Scalars['String']>;
    /** Workflow trigger id */
    workflowTriggerId?: InputMaybe<Scalars['String']>;
};
/** Grant promotional entitlement input */
export declare type GrantPromotionalEntitlementInput = {
    /** The custom end date of the promotional entitlement */
    customEndDate?: InputMaybe<Scalars['DateTime']>;
    /** The enum values of the entitlement */
    enumValues?: InputMaybe<Array<Scalars['String']>>;
    /** The unique identifier of the entitlement feature */
    featureId: Scalars['String'];
    /** Whether the entitlement has a soft limit */
    hasSoftLimit?: InputMaybe<Scalars['Boolean']>;
    /** Whether the entitlement has an unlimited usage */
    hasUnlimitedUsage?: InputMaybe<Scalars['Boolean']>;
    /** Whether the entitlement is visible */
    isVisible?: InputMaybe<Scalars['Boolean']>;
    /** The monthly reset period configuration of the entitlement, defined when reset period is monthly */
    monthlyResetPeriodConfiguration?: InputMaybe<MonthlyResetPeriodConfigInput>;
    /** The grant period of the promotional entitlement */
    period: PromotionalEntitlementPeriod;
    /** The reset period of the entitlement */
    resetPeriod?: InputMaybe<EntitlementResetPeriod>;
    /** The usage limit of the entitlement */
    usageLimit?: InputMaybe<Scalars['Float']>;
    /** The weekly reset period configuration of the entitlement, defined when reset period is weekly */
    weeklyResetPeriodConfiguration?: InputMaybe<WeeklyResetPeriodConfigInput>;
    /** The yearly reset period configuration of the entitlement, defined when reset period is yearly */
    yearlyResetPeriodConfiguration?: InputMaybe<YearlyResetPeriodConfigInput>;
};
/** Grant promotional entitlements for a feature group input */
export declare type GrantPromotionalEntitlementsGroupInput = {
    /** The unique identifier of the entitlement customer */
    customerId: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Feature group ID to grant as promotional entitlement */
    featureGroupId: Scalars['UUID'];
    /** List of promotional entitlements for features in the group */
    promotionalEntitlements: Array<GrantPromotionalEntitlementInput>;
};
/** Grant multiple promotional entitlements input */
export declare type GrantPromotionalEntitlementsInput = {
    /** The unique identifier of the entitlement customer */
    customerId: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Promotional entitlements to grant */
    promotionalEntitlements: Array<GrantPromotionalEntitlementInput>;
};
export declare type HookFilter = {
    and?: InputMaybe<Array<HookFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    endpoint?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<HookFilter>>;
    status?: InputMaybe<HookStatusFilterComparison>;
};
export declare type HookSort = {
    direction: SortDirection;
    field: HookSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum HookSortFields {
    CreatedAt = "createdAt",
    Endpoint = "endpoint",
    EnvironmentId = "environmentId",
    Id = "id",
    Status = "status"
}
/** Hook status */
export declare enum HookStatus {
    /** Active */
    Active = "ACTIVE",
    /** Inactive */
    Inactive = "INACTIVE"
}
export declare type HookStatusFilterComparison = {
    eq?: InputMaybe<HookStatus>;
    gt?: InputMaybe<HookStatus>;
    gte?: InputMaybe<HookStatus>;
    iLike?: InputMaybe<HookStatus>;
    in?: InputMaybe<Array<HookStatus>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<HookStatus>;
    lt?: InputMaybe<HookStatus>;
    lte?: InputMaybe<HookStatus>;
    neq?: InputMaybe<HookStatus>;
    notILike?: InputMaybe<HookStatus>;
    notIn?: InputMaybe<Array<HookStatus>>;
    notLike?: InputMaybe<HookStatus>;
};
/** Input configuration for HubSpot integration */
export declare type HubspotCredentialsInput = {
    /** Authorization code for HubSpot */
    authorizationCode: Scalars['String'];
    /** Refresh token for HubSpot */
    refreshToken?: InputMaybe<Scalars['String']>;
};
/** Input for importing a bulk of customers */
export declare type ImportCustomerBulkInput = {
    /** List of customers to import */
    customers: Array<ImportCustomerInput>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
};
/** Input for importing a customer */
export declare type ImportCustomerInput = {
    /** Additional metadata */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** Id in the billing provider */
    billingId?: InputMaybe<Scalars['String']>;
    /** Customer slug */
    customerId?: InputMaybe<Scalars['String']>;
    /** Customer email */
    email?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Customer name */
    name?: InputMaybe<Scalars['String']>;
    /** Payment method Id in the billing provider */
    paymentMethodId?: InputMaybe<Scalars['String']>;
    /** Customer slug */
    refId?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the customer in Salesforce integration */
    salesforceId?: InputMaybe<Scalars['String']>;
    /** Indicates the last update of the customer. In case there's already existing customer that was updated after that date, it will skip import this customer */
    updatedAt?: InputMaybe<Scalars['DateTime']>;
};
/** Input parameters for importing product catalog from an integration */
export declare type ImportIntegrationCatalogInput = {
    /** Billing model configuration for the imported product */
    billingModel?: InputMaybe<BillingModel>;
    /** Mode for selecting plans to import (blacklist or whitelist) */
    entitySelectionMode: EntitySelectionMode;
    /** The unique identifier for the environment */
    environmentId: Scalars['String'];
    /** Singular name for the feature unit */
    featureUnitName?: InputMaybe<Scalars['String']>;
    /** Plural name for the feature unit */
    featureUnitPluralName?: InputMaybe<Scalars['String']>;
    /** List of plan IDs to exclude when using blacklist mode */
    plansSelectionBlacklist?: InputMaybe<Array<Scalars['String']>>;
    /** List of plan IDs to include when using whitelist mode */
    plansSelectionWhitelist?: InputMaybe<Array<Scalars['String']>>;
    /** Product ID to import from the integration */
    productId: Scalars['String'];
    /** List of addon billing IDs to import */
    selectedAddonBillingIds: Array<Scalars['String']>;
    /** The vendor identifier of integration */
    vendorIdentifier: VendorIdentifier;
};
/** Input parameters for importing customers from an integration */
export declare type ImportIntegrationCustomersInput = {
    /** List of customer IDs to exclude when using blacklist mode */
    customersSelectionBlacklist?: InputMaybe<Array<Scalars['String']>>;
    /** List of customer IDs to include when using whitelist mode */
    customersSelectionWhitelist?: InputMaybe<Array<Scalars['String']>>;
    /** Mode for selecting customers to import (blacklist or whitelist) */
    entitySelectionMode: EntitySelectionMode;
    /** The unique identifier for the environment */
    environmentId: Scalars['String'];
    /** Product ID to import customers from */
    productId: Scalars['String'];
    /** The vendor identifier of integration */
    vendorIdentifier: VendorIdentifier;
};
export declare type ImportIntegrationTaskFilter = {
    and?: InputMaybe<Array<ImportIntegrationTaskFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    environmentId?: InputMaybe<StringFieldComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<ImportIntegrationTaskFilter>>;
    status?: InputMaybe<TaskStatusFilterComparison>;
    taskType?: InputMaybe<TaskTypeFilterComparison>;
};
export declare type ImportIntegrationTaskSort = {
    direction: SortDirection;
    field: ImportIntegrationTaskSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum ImportIntegrationTaskSortFields {
    CreatedAt = "createdAt",
    EnvironmentId = "environmentId",
    Id = "id",
    Status = "status",
    TaskType = "taskType"
}
export declare type ImportSubscriptionInput = {
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    addons?: InputMaybe<Array<SubscriptionAddonInput>>;
    billableFeatures?: InputMaybe<Array<BillableFeatureInput>>;
    billingId?: InputMaybe<Scalars['String']>;
    billingPeriod?: InputMaybe<BillingPeriod>;
    customerId: Scalars['String'];
    endDate?: InputMaybe<Scalars['DateTime']>;
    planId: Scalars['String'];
    resourceId?: InputMaybe<Scalars['String']>;
    salesforceId?: InputMaybe<Scalars['String']>;
    startDate?: InputMaybe<Scalars['DateTime']>;
    subscriptionEntitlements?: InputMaybe<Array<SubscriptionEntitlementInput>>;
    subscriptionId?: InputMaybe<Scalars['String']>;
    unitQuantity?: InputMaybe<Scalars['Float']>;
    /** Indicates the last update of the subscription. In case there's already existing subscription that was updated after that date, it will skip import this subscription */
    updatedAt?: InputMaybe<Scalars['DateTime']>;
};
export declare type ImportSubscriptionsBulkInput = {
    environmentId?: InputMaybe<Scalars['UUID']>;
    subscriptions: Array<ImportSubscriptionInput>;
};
/** Input for initializing a payment method form for a customer */
export declare type InitAddStripeCustomerPaymentMethodInput = {
    /** Customer slug */
    customerRefId: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The billing integration to use for this payment method */
    integrationId?: InputMaybe<Scalars['String']>;
};
export declare type IntFieldComparison = {
    between?: InputMaybe<IntFieldComparisonBetween>;
    eq?: InputMaybe<Scalars['Int']>;
    gt?: InputMaybe<Scalars['Int']>;
    gte?: InputMaybe<Scalars['Int']>;
    in?: InputMaybe<Array<Scalars['Int']>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    lt?: InputMaybe<Scalars['Int']>;
    lte?: InputMaybe<Scalars['Int']>;
    neq?: InputMaybe<Scalars['Int']>;
    notBetween?: InputMaybe<IntFieldComparisonBetween>;
    notIn?: InputMaybe<Array<Scalars['Int']>>;
};
export declare type IntFieldComparisonBetween = {
    lower: Scalars['Int'];
    upper: Scalars['Int'];
};
export declare type IntegrationFilter = {
    and?: InputMaybe<Array<IntegrationFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<IntegrationFilter>>;
    vendorIdentifier?: InputMaybe<VendorIdentifierFilterComparison>;
    vendorType?: InputMaybe<IntegrationVendorTypeFilterComparison>;
};
export declare type IntegrationSort = {
    direction: SortDirection;
    field: IntegrationSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum IntegrationSortFields {
    CreatedAt = "createdAt",
    EnvironmentId = "environmentId",
    Id = "id",
    VendorIdentifier = "vendorIdentifier",
    VendorType = "vendorType"
}
export declare type IntegrationVendorTypeFilterComparison = {
    eq?: InputMaybe<VendorType>;
    in?: InputMaybe<Array<VendorType>>;
    neq?: InputMaybe<VendorType>;
    notIn?: InputMaybe<Array<VendorType>>;
};
/** Input for inviting members */
export declare type InviteMembersInput = {
    /** Account level access of the user, defaults to member role */
    accountRole?: InputMaybe<AccountAccessRole>;
    /** List of emails to invite */
    invites: Array<Scalars['String']>;
    /** Environment level access of the user, defaults to read-only role */
    nonProductionRole?: InputMaybe<EnvironmentAccessRole>;
    /** Environment level access of the user, defaults to read-only role */
    productionRole?: InputMaybe<EnvironmentAccessRole>;
};
/** The type of the invoice line item */
export declare enum InvoiceLineItemType {
    AddonCharge = "AddonCharge",
    BaseCharge = "BaseCharge",
    InAdvanceCommitmentCharge = "InAdvanceCommitmentCharge",
    MinimumSpendAdjustmentCharge = "MinimumSpendAdjustmentCharge",
    MinimumSpendCharge = "MinimumSpendCharge",
    Other = "Other",
    OverageCharge = "OverageCharge",
    PayAsYouGoCharge = "PayAsYouGoCharge",
    TierCharge = "TierCharge",
    ZeroAmountBaseCharge = "ZeroAmountBaseCharge"
}
/** Link feature group to package entitlements input */
export declare type LinkFeatureGroupToPackageInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The group id to link to the package */
    featureGroupId: Scalars['UUID'];
    /** The unique identifier of the entitlement package */
    packageId: Scalars['UUID'];
};
/** Input for retrieving AWS Marketplace product dimensions */
export declare type ListAwsProductDimensionsInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** AWS product ID to fetch dimensions for */
    productId: Scalars['String'];
};
/** Input parameters for listing available AWS Marketplace products */
export declare type ListAwsProductsInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
};
/** Input for triggering the subscription invoice as paid */
export declare type MarkInvoiceAsPaidInput = {
    /** Environment ID */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The subscription entity id to trigger mark invoice as paid */
    subscriptionId: Scalars['String'];
};
export declare type MemberFilter = {
    and?: InputMaybe<Array<MemberFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    email?: InputMaybe<StringFieldComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<MemberFilter>>;
    user?: InputMaybe<MemberFilterUserFilter>;
};
export declare type MemberFilterUserFilter = {
    and?: InputMaybe<Array<MemberFilterUserFilter>>;
    email?: InputMaybe<StringFieldComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    name?: InputMaybe<StringFieldComparison>;
    or?: InputMaybe<Array<MemberFilterUserFilter>>;
};
export declare type MemberSort = {
    direction: SortDirection;
    field: MemberSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum MemberSortFields {
    CreatedAt = "createdAt",
    Email = "email",
    Id = "id"
}
/** Member Status */
export declare enum MemberStatus {
    /** User has been invited to the environment */
    Invited = "INVITED",
    /** User is a member of this environment */
    Registered = "REGISTERED"
}
/** Input type for mergeEnvironment mutation */
export declare type MergeEnvironmentInput = {
    /** Name for the new environment if destinationEnvironmentSlug is not provided */
    destinationEnvironmentName?: InputMaybe<Scalars['String']>;
    /** Slug of the destination environment to merge into. If not provided, a new environment will be created */
    destinationEnvironmentSlug?: InputMaybe<Scalars['String']>;
    /** Type for the new environment if destinationEnvironmentSlug is not provided */
    destinationEnvironmentType?: InputMaybe<EnvironmentType>;
    /** Optional configuration to customize the merge process */
    mergeConfiguration?: InputMaybe<EnvironmentMergeConfigurationInput>;
    /** How to migrate customers to newer plan version of updated plans. Default is not to migrate existing customers */
    migrationType?: InputMaybe<PublishMigrationType>;
    /** Slug of the source environment to merge from. Either this or sourceTemplate must be provided */
    sourceEnvironmentSlug?: InputMaybe<Scalars['String']>;
    /** A template dump of the source environment. Either this or sourceEnvironmentSlug must be provided */
    sourceTemplate?: InputMaybe<Scalars['JSON']>;
};
/** Defines how meter data should be aggregated using a specified aggregation function */
export declare type MeterAggregation = {
    /** The data field to which the aggregation function will be applied */
    field?: InputMaybe<Scalars['String']>;
    /** The aggregation function to apply to the data (e.g. SUM, AVG, COUNT) */
    function: AggregationFunction;
};
/** A condition that will be used to filter the data */
export declare type MeterConditionInput = {
    /** The field to filter on */
    field: Scalars['String'];
    /** The operation to perform on the field */
    operation: ConditionOperation;
    /** The value of the field to filter on */
    value?: InputMaybe<Scalars['String']>;
};
/** A configuration defining how to filter the data */
export declare type MeterFilterDefinitionInput = {
    /** List of conditions that will be applied to the data */
    conditions: Array<MeterConditionInput>;
};
/** The meter type of the feature */
export declare enum MeterType {
    /** Fluctuating */
    Fluctuating = "Fluctuating",
    /** Incremental */
    Incremental = "Incremental",
    /** None */
    None = "None"
}
export declare type MeterTypeFilterComparison = {
    eq?: InputMaybe<MeterType>;
    gt?: InputMaybe<MeterType>;
    gte?: InputMaybe<MeterType>;
    iLike?: InputMaybe<MeterType>;
    in?: InputMaybe<Array<MeterType>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<MeterType>;
    lt?: InputMaybe<MeterType>;
    lte?: InputMaybe<MeterType>;
    neq?: InputMaybe<MeterType>;
    notILike?: InputMaybe<MeterType>;
    notIn?: InputMaybe<Array<MeterType>>;
    notLike?: InputMaybe<MeterType>;
};
/** Input for migrating package feature groups to latest version */
export declare type MigratePackageFeatureGroupsToLatestInput = {
    /** The unique identifier for the account */
    accountId: Scalars['UUID'];
    /** List of package entitlements that are new to the feature groups */
    entitlements: Array<PackageEntitlementInput>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The unique identifier of the entitlement package */
    packageId: Scalars['UUID'];
};
/** Minimum spend input */
export declare type MinimumSpendInput = {
    /** The billing period of the price */
    billingPeriod: BillingPeriod;
    /** The minimum spend value */
    minimum: MoneyInputDto;
};
/** Money Input */
export declare type MoneyInputDto = {
    /** The price amount */
    amount: Scalars['Float'];
    /** The price currency */
    currency?: InputMaybe<Currency>;
};
/** Monthly reset period according to configuration */
export declare enum MonthlyAccordingTo {
    /** Start of the month */
    StartOfTheMonth = "StartOfTheMonth",
    /** Subscription start */
    SubscriptionStart = "SubscriptionStart"
}
/** Monthly reset period config input */
export declare type MonthlyResetPeriodConfigInput = {
    /** Monthly according to configuration */
    accordingTo: MonthlyAccordingTo;
};
export declare type NumberFieldComparison = {
    between?: InputMaybe<NumberFieldComparisonBetween>;
    eq?: InputMaybe<Scalars['Float']>;
    gt?: InputMaybe<Scalars['Float']>;
    gte?: InputMaybe<Scalars['Float']>;
    in?: InputMaybe<Array<Scalars['Float']>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    lt?: InputMaybe<Scalars['Float']>;
    lte?: InputMaybe<Scalars['Float']>;
    neq?: InputMaybe<Scalars['Float']>;
    notBetween?: InputMaybe<NumberFieldComparisonBetween>;
    notIn?: InputMaybe<Array<Scalars['Float']>>;
};
export declare type NumberFieldComparisonBetween = {
    lower: Scalars['Float'];
    upper: Scalars['Float'];
};
/** Input configuration for OpenFGA integration */
export declare type OpenFgaCredentialsInput = {
    /** Audience for the OpenFGA API */
    apiAudience: Scalars['String'];
    /** Issuer of the OpenFGA API token */
    apiTokenIssuer: Scalars['String'];
    /** URL of the OpenFGA API */
    apiUrl: Scalars['String'];
    /** Client ID for the OpenFGA API */
    clientId: Scalars['String'];
    /** Client secret for OpenFGA */
    clientSecret: Scalars['String'];
    /** ID of the OpenFGA store */
    storeId?: InputMaybe<Scalars['String']>;
};
/** Configures when the overage charge is billed. */
export declare enum OverageBillingPeriod {
    Monthly = "MONTHLY",
    OnSubscriptionRenewal = "ON_SUBSCRIPTION_RENEWAL"
}
/** Overage Entitlement Create Input */
export declare type OverageEntitlementCreateInput = {
    /** The behavior of the entitlement */
    behavior?: InputMaybe<EntitlementBehavior>;
    /** The description of the entitlement */
    description?: InputMaybe<Scalars['String']>;
    /** The display name override of the entitlement */
    displayNameOverride?: InputMaybe<Scalars['String']>;
    /** The enum values of the entitlement */
    enumValues?: InputMaybe<Array<Scalars['String']>>;
    /** Primary feature group ID (first in the array) associated with this entitlement */
    featureGroupId?: InputMaybe<Scalars['UUID']>;
    /** The unique identifier of the entitlement feature */
    featureId: Scalars['UUID'];
    /** Whether the entitlement has a soft limit */
    hasSoftLimit?: InputMaybe<Scalars['Boolean']>;
    /** Whether the entitlement has an unlimited usage */
    hasUnlimitedUsage?: InputMaybe<Scalars['Boolean']>;
    /** Whether the entitlement is hidden from widgets */
    hiddenFromWidgets?: InputMaybe<Array<WidgetType>>;
    /** Whether the entitlement is a custom entitlement */
    isCustom?: InputMaybe<Scalars['Boolean']>;
    /** Whether entitlement grant is active */
    isGranted?: InputMaybe<Scalars['Boolean']>;
    /** The monthly reset period configuration of the entitlement, defined when reset period is monthly */
    monthlyResetPeriodConfiguration?: InputMaybe<MonthlyResetPeriodConfigInput>;
    /** The order of the entitlement in the entitlement list */
    order?: InputMaybe<Scalars['Float']>;
    /** The reset period of the entitlement */
    resetPeriod?: InputMaybe<EntitlementResetPeriod>;
    /** The usage limit of the entitlement */
    usageLimit?: InputMaybe<Scalars['Float']>;
    /** The weekly reset period configuration of the entitlement, defined when reset period is weekly */
    weeklyResetPeriodConfiguration?: InputMaybe<WeeklyResetPeriodConfigInput>;
    /** The yearly reset period configuration of the entitlement, defined when reset period is yearly */
    yearlyResetPeriodConfiguration?: InputMaybe<YearlyResetPeriodConfigInput>;
};
/** Overage Pricing Model Create Input */
export declare type OveragePricingModelCreateInput = {
    /** The billing cadence of the base pricing model */
    billingCadence?: InputMaybe<BillingCadence>;
    /** The billing model of the base pricing model */
    billingModel: BillingModel;
    /** The entitlement of the overage pricing model */
    entitlement?: InputMaybe<OverageEntitlementCreateInput>;
    /** The feature id of the base pricing model */
    featureId?: InputMaybe<Scalars['String']>;
    /** The price periods of the base pricing model */
    pricePeriods: Array<PricePeriodInput>;
};
export declare type PackageDtoFilter = {
    and?: InputMaybe<Array<PackageDtoFilter>>;
    billingId?: InputMaybe<StringFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    description?: InputMaybe<StringFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    isLatest?: InputMaybe<BooleanFieldComparison>;
    or?: InputMaybe<Array<PackageDtoFilter>>;
    pricingType?: InputMaybe<PricingTypeFilterComparison>;
    productId?: InputMaybe<StringFieldComparison>;
    refId?: InputMaybe<StringFieldComparison>;
    status?: InputMaybe<PackageStatusFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
    versionNumber?: InputMaybe<IntFieldComparison>;
};
export declare type PackageDtoSort = {
    direction: SortDirection;
    field: PackageDtoSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum PackageDtoSortFields {
    BillingId = "billingId",
    CreatedAt = "createdAt",
    Description = "description",
    DisplayName = "displayName",
    EnvironmentId = "environmentId",
    Id = "id",
    IsLatest = "isLatest",
    PricingType = "pricingType",
    ProductId = "productId",
    RefId = "refId",
    Status = "status",
    UpdatedAt = "updatedAt",
    VersionNumber = "versionNumber"
}
export declare type PackageEntitlementFilter = {
    and?: InputMaybe<Array<PackageEntitlementFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    feature?: InputMaybe<PackageEntitlementFilterFeatureFilter>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<PackageEntitlementFilter>>;
    package?: InputMaybe<PackageEntitlementFilterPackageDtoFilter>;
    packageId?: InputMaybe<StringFieldComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
export declare type PackageEntitlementFilterFeatureFilter = {
    and?: InputMaybe<Array<PackageEntitlementFilterFeatureFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    description?: InputMaybe<StringFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    featureStatus?: InputMaybe<FeatureStatusFilterComparison>;
    featureType?: InputMaybe<FeatureTypeFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    meterType?: InputMaybe<MeterTypeFilterComparison>;
    or?: InputMaybe<Array<PackageEntitlementFilterFeatureFilter>>;
    refId?: InputMaybe<StringFieldComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
export declare type PackageEntitlementFilterPackageDtoFilter = {
    and?: InputMaybe<Array<PackageEntitlementFilterPackageDtoFilter>>;
    billingId?: InputMaybe<StringFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    description?: InputMaybe<StringFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    isLatest?: InputMaybe<BooleanFieldComparison>;
    or?: InputMaybe<Array<PackageEntitlementFilterPackageDtoFilter>>;
    pricingType?: InputMaybe<PricingTypeFilterComparison>;
    productId?: InputMaybe<StringFieldComparison>;
    refId?: InputMaybe<StringFieldComparison>;
    status?: InputMaybe<PackageStatusFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
    versionNumber?: InputMaybe<IntFieldComparison>;
};
/** Package entitlement input */
export declare type PackageEntitlementInput = {
    /** The behavior of the entitlement */
    behavior?: InputMaybe<EntitlementBehavior>;
    /** The description of the entitlement */
    description?: InputMaybe<Scalars['String']>;
    /** The display name override of the entitlement */
    displayNameOverride?: InputMaybe<Scalars['String']>;
    /** The enum values of the entitlement */
    enumValues?: InputMaybe<Array<Scalars['String']>>;
    /** The unique identifier for the environment */
    environmentId: Scalars['UUID'];
    /** Primary feature group ID (first in the array) associated with this entitlement */
    featureGroupId?: InputMaybe<Scalars['UUID']>;
    /** The unique identifier of the entitlement feature */
    featureId: Scalars['UUID'];
    /** Whether the entitlement has a soft limit */
    hasSoftLimit?: InputMaybe<Scalars['Boolean']>;
    /** Whether the entitlement has an unlimited usage */
    hasUnlimitedUsage?: InputMaybe<Scalars['Boolean']>;
    /** Whether the entitlement is hidden from widgets */
    hiddenFromWidgets?: InputMaybe<Array<WidgetType>>;
    /** Whether the entitlement is a custom entitlement */
    isCustom?: InputMaybe<Scalars['Boolean']>;
    /** Whether entitlement grant is active */
    isGranted?: InputMaybe<Scalars['Boolean']>;
    /** The monthly reset period configuration of the entitlement, defined when reset period is monthly */
    monthlyResetPeriodConfiguration?: InputMaybe<MonthlyResetPeriodConfigInput>;
    /** The order of the entitlement in the entitlement list */
    order?: InputMaybe<Scalars['Float']>;
    /** The unique identifier of the entitlement package */
    packageId: Scalars['UUID'];
    /** The reset period of the entitlement */
    resetPeriod?: InputMaybe<EntitlementResetPeriod>;
    /** The usage limit of the entitlement */
    usageLimit?: InputMaybe<Scalars['Float']>;
    /** The weekly reset period configuration of the entitlement, defined when reset period is weekly */
    weeklyResetPeriodConfiguration?: InputMaybe<WeeklyResetPeriodConfigInput>;
    /** The yearly reset period configuration of the entitlement, defined when reset period is yearly */
    yearlyResetPeriodConfiguration?: InputMaybe<YearlyResetPeriodConfigInput>;
};
export declare type PackageEntitlementSort = {
    direction: SortDirection;
    field: PackageEntitlementSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum PackageEntitlementSortFields {
    CreatedAt = "createdAt",
    EnvironmentId = "environmentId",
    Id = "id",
    PackageId = "packageId",
    UpdatedAt = "updatedAt"
}
/** Package entitlement update input */
export declare type PackageEntitlementUpdateInput = {
    /** The behavior of the entitlement */
    behavior?: InputMaybe<EntitlementBehavior>;
    /** The description of the entitlement */
    description?: InputMaybe<Scalars['String']>;
    /** The display name override of the entitlement */
    displayNameOverride?: InputMaybe<Scalars['String']>;
    /** The enum values of the entitlement */
    enumValues?: InputMaybe<Array<Scalars['String']>>;
    /** Whether the entitlement has a soft limit */
    hasSoftLimit?: InputMaybe<Scalars['Boolean']>;
    /** Whether the entitlement has an unlimited usage */
    hasUnlimitedUsage?: InputMaybe<Scalars['Boolean']>;
    /** Whether the entitlement is hidden from widgets */
    hiddenFromWidgets?: InputMaybe<Array<WidgetType>>;
    /** Whether the entitlement is a custom entitlement */
    isCustom?: InputMaybe<Scalars['Boolean']>;
    /** Whether entitlement grant is active */
    isGranted?: InputMaybe<Scalars['Boolean']>;
    /** The monthly reset period configuration of the entitlement, defined when reset period is monthly */
    monthlyResetPeriodConfiguration?: InputMaybe<MonthlyResetPeriodConfigInput>;
    /** The order of the entitlement in the entitlement list */
    order?: InputMaybe<Scalars['Float']>;
    /** The reset period of the entitlement */
    resetPeriod?: InputMaybe<EntitlementResetPeriod>;
    /** The usage limit of the entitlement */
    usageLimit?: InputMaybe<Scalars['Float']>;
    /** The weekly reset period configuration of the entitlement, defined when reset period is weekly */
    weeklyResetPeriodConfiguration?: InputMaybe<WeeklyResetPeriodConfigInput>;
    /** The yearly reset period configuration of the entitlement, defined when reset period is yearly */
    yearlyResetPeriodConfiguration?: InputMaybe<YearlyResetPeriodConfigInput>;
};
export declare type PackageGroupFilter = {
    and?: InputMaybe<Array<PackageGroupFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    isLatest?: InputMaybe<BooleanFieldComparison>;
    or?: InputMaybe<Array<PackageGroupFilter>>;
    packageGroupId?: InputMaybe<StringFieldComparison>;
    product?: InputMaybe<PackageGroupFilterProductFilter>;
    productId?: InputMaybe<StringFieldComparison>;
    status?: InputMaybe<PackageGroupStatusFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
    versionNumber?: InputMaybe<IntFieldComparison>;
};
export declare type PackageGroupFilterProductFilter = {
    and?: InputMaybe<Array<PackageGroupFilterProductFilter>>;
    awsMarketplaceProductCode?: InputMaybe<StringFieldComparison>;
    awsMarketplaceProductId?: InputMaybe<StringFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    description?: InputMaybe<StringFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    isDefaultProduct?: InputMaybe<BooleanFieldComparison>;
    multipleSubscriptions?: InputMaybe<BooleanFieldComparison>;
    or?: InputMaybe<Array<PackageGroupFilterProductFilter>>;
    refId?: InputMaybe<StringFieldComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
export declare type PackageGroupSort = {
    direction: SortDirection;
    field: PackageGroupSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum PackageGroupSortFields {
    CreatedAt = "createdAt",
    DisplayName = "displayName",
    EnvironmentId = "environmentId",
    IsLatest = "isLatest",
    PackageGroupId = "packageGroupId",
    ProductId = "productId",
    Status = "status",
    UpdatedAt = "updatedAt",
    VersionNumber = "versionNumber"
}
/** Package group status */
export declare enum PackageGroupStatus {
    /** The package group is archived */
    Archived = "ARCHIVED",
    /** The package group is a draft */
    Draft = "DRAFT",
    /** The package group is published */
    Published = "PUBLISHED"
}
export declare type PackageGroupStatusFilterComparison = {
    eq?: InputMaybe<PackageGroupStatus>;
    gt?: InputMaybe<PackageGroupStatus>;
    gte?: InputMaybe<PackageGroupStatus>;
    iLike?: InputMaybe<PackageGroupStatus>;
    in?: InputMaybe<Array<PackageGroupStatus>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<PackageGroupStatus>;
    lt?: InputMaybe<PackageGroupStatus>;
    lte?: InputMaybe<PackageGroupStatus>;
    neq?: InputMaybe<PackageGroupStatus>;
    notILike?: InputMaybe<PackageGroupStatus>;
    notIn?: InputMaybe<Array<PackageGroupStatus>>;
    notLike?: InputMaybe<PackageGroupStatus>;
};
/** Package Pricing Input */
export declare type PackagePricingInput = {
    /** The unique identifier for the environment */
    environmentId: Scalars['String'];
    /** The minimum spend configuration per each billing period */
    minimumSpend?: InputMaybe<Array<MinimumSpendInput>>;
    /** The overage billing period of the package pricing */
    overageBillingPeriod?: InputMaybe<OverageBillingPeriod>;
    /** The list of overage pricing models of the package pricing */
    overagePricingModels?: InputMaybe<Array<OveragePricingModelCreateInput>>;
    /** The package id of the price */
    packageId: Scalars['String'];
    /** The pricing model of the package pricing */
    pricingModel?: InputMaybe<PricingModelCreateInput>;
    /** The list of pricing models of the package pricing */
    pricingModels?: InputMaybe<Array<PricingModelCreateInput>>;
    /** The pricing type of the package pricing */
    pricingType: PricingType;
};
/** Package Publish Input */
export declare type PackagePublishInput = {
    /** Unique identifier for the entity */
    id: Scalars['UUID'];
    /** The migration type of the package */
    migrationType: PublishMigrationType;
};
/** Package status. */
export declare enum PackageStatus {
    Archived = "ARCHIVED",
    Draft = "DRAFT",
    Published = "PUBLISHED"
}
export declare type PackageStatusFilterComparison = {
    eq?: InputMaybe<PackageStatus>;
    gt?: InputMaybe<PackageStatus>;
    gte?: InputMaybe<PackageStatus>;
    iLike?: InputMaybe<PackageStatus>;
    in?: InputMaybe<Array<PackageStatus>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<PackageStatus>;
    lt?: InputMaybe<PackageStatus>;
    lte?: InputMaybe<PackageStatus>;
    neq?: InputMaybe<PackageStatus>;
    notILike?: InputMaybe<PackageStatus>;
    notIn?: InputMaybe<Array<PackageStatus>>;
    notLike?: InputMaybe<PackageStatus>;
};
/** Payment collection */
export declare enum PaymentCollection {
    ActionRequired = "ACTION_REQUIRED",
    Failed = "FAILED",
    NotRequired = "NOT_REQUIRED",
    Processing = "PROCESSING"
}
export declare type PaymentCollectionFilterComparison = {
    eq?: InputMaybe<PaymentCollection>;
    gt?: InputMaybe<PaymentCollection>;
    gte?: InputMaybe<PaymentCollection>;
    iLike?: InputMaybe<PaymentCollection>;
    in?: InputMaybe<Array<PaymentCollection>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<PaymentCollection>;
    lt?: InputMaybe<PaymentCollection>;
    lte?: InputMaybe<PaymentCollection>;
    neq?: InputMaybe<PaymentCollection>;
    notILike?: InputMaybe<PaymentCollection>;
    notIn?: InputMaybe<Array<PaymentCollection>>;
    notLike?: InputMaybe<PaymentCollection>;
};
/** The method used to collect payments for a subscription */
export declare enum PaymentCollectionMethod {
    /** Automatically charge the payment method on file */
    Charge = "CHARGE",
    /** Generate an invoice to the customer to pay manually */
    Invoice = "INVOICE",
    /** Do not leverage Stigg to manage payments for this subscription */
    None = "NONE"
}
/** Type of a payment method */
export declare enum PaymentMethodType {
    /** Bank Transfer */
    Bank = "BANK",
    /** Credit Card */
    Card = "CARD",
    /** Cash App */
    CashApp = "CASH_APP"
}
/** Input for customizing paywall-specific color elements. */
export declare type PaywallColorsPaletteInput = {
    /** Background color of the widget. */
    backgroundColor?: InputMaybe<Scalars['String']>;
    /** Color applied to widget borders or separators. */
    borderColor?: InputMaybe<Scalars['String']>;
    /** Background color for the customer’s current plan section in the paywall. */
    currentPlanBackground?: InputMaybe<Scalars['String']>;
    /** Primary accent color used throughout the widget. */
    primary?: InputMaybe<Scalars['String']>;
    /** Default color used for text content. */
    textColor?: InputMaybe<Scalars['String']>;
};
/** Input for updating the paywall configuration. */
export declare type PaywallConfigurationInput = {
    /** Custom CSS overrides for additional visual customization. */
    customCss?: InputMaybe<Scalars['String']>;
    /** Layout settings for plan display in the paywall. */
    layout?: InputMaybe<PaywallLayoutConfigurationInput>;
    /** Color palette settings for the paywall UI. */
    palette?: InputMaybe<PaywallColorsPaletteInput>;
    /** Typography configuration used in the paywall widget. */
    typography?: InputMaybe<TypographyConfigurationInput>;
};
/** Input for controlling the layout of pricing plans in the paywall. */
export declare type PaywallLayoutConfigurationInput = {
    /** Horizontal alignment of pricing plans, such as left, center, or right. */
    alignment?: InputMaybe<Alignment>;
    /** Outer spacing around each plan. */
    planMargin?: InputMaybe<Scalars['Float']>;
    /** Inner spacing inside each plan card. */
    planPadding?: InputMaybe<Scalars['Float']>;
    /** Width of each plan card displayed in the paywall. */
    planWidth?: InputMaybe<Scalars['Float']>;
};
/** Type of the change between two plans of the same subscription */
export declare enum PlanChangeType {
    /** Subscription downgrade to lower plan */
    Downgrade = "DOWNGRADE",
    /** Subscription remains on the same plan */
    None = "NONE",
    /** Subscription upgrade to higher plan */
    Upgrade = "UPGRADE"
}
/** Input for creating a plan */
export declare type PlanCreateInput = {
    /** The additional meta data of the package */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** The AWS marketplace plan dimension of the package */
    awsMarketplacePlanDimension?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the entity in the billing provider */
    billingId?: InputMaybe<Scalars['String']>;
    /** The description of the package */
    description?: InputMaybe<Scalars['String']>;
    /** The display name of the package */
    displayName: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** List of hidden widgets of the package */
    hiddenFromWidgets?: InputMaybe<Array<WidgetType>>;
    /** The ID of the parent plan, if applicable */
    parentPlanId?: InputMaybe<Scalars['String']>;
    /** The pricing type of the package */
    pricingType?: InputMaybe<PricingType>;
    /** The product id of the package */
    productId: Scalars['String'];
    /** The unique identifier for the entity */
    refId?: InputMaybe<Scalars['String']>;
    /** The status of the package */
    status?: InputMaybe<PackageStatus>;
};
export declare type PlanFilter = {
    and?: InputMaybe<Array<PlanFilter>>;
    billingId?: InputMaybe<StringFieldComparison>;
    compatibleAddons?: InputMaybe<PlanFilterAddonFilter>;
    createdAt?: InputMaybe<DateFieldComparison>;
    description?: InputMaybe<StringFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    isLatest?: InputMaybe<BooleanFieldComparison>;
    or?: InputMaybe<Array<PlanFilter>>;
    pricingType?: InputMaybe<PricingTypeFilterComparison>;
    product?: InputMaybe<PlanFilterProductFilter>;
    productId?: InputMaybe<StringFieldComparison>;
    refId?: InputMaybe<StringFieldComparison>;
    status?: InputMaybe<PackageStatusFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
    versionNumber?: InputMaybe<IntFieldComparison>;
};
export declare type PlanFilterAddonFilter = {
    and?: InputMaybe<Array<PlanFilterAddonFilter>>;
    billingId?: InputMaybe<StringFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    description?: InputMaybe<StringFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    isLatest?: InputMaybe<BooleanFieldComparison>;
    or?: InputMaybe<Array<PlanFilterAddonFilter>>;
    pricingType?: InputMaybe<PricingTypeFilterComparison>;
    productId?: InputMaybe<StringFieldComparison>;
    refId?: InputMaybe<StringFieldComparison>;
    status?: InputMaybe<PackageStatusFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
    versionNumber?: InputMaybe<IntFieldComparison>;
};
export declare type PlanFilterProductFilter = {
    and?: InputMaybe<Array<PlanFilterProductFilter>>;
    awsMarketplaceProductCode?: InputMaybe<StringFieldComparison>;
    awsMarketplaceProductId?: InputMaybe<StringFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    description?: InputMaybe<StringFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    isDefaultProduct?: InputMaybe<BooleanFieldComparison>;
    multipleSubscriptions?: InputMaybe<BooleanFieldComparison>;
    or?: InputMaybe<Array<PlanFilterProductFilter>>;
    refId?: InputMaybe<StringFieldComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
export declare type PlanSort = {
    direction: SortDirection;
    field: PlanSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum PlanSortFields {
    BillingId = "billingId",
    CreatedAt = "createdAt",
    Description = "description",
    DisplayName = "displayName",
    EnvironmentId = "environmentId",
    Id = "id",
    IsLatest = "isLatest",
    PricingType = "pricingType",
    ProductId = "productId",
    RefId = "refId",
    Status = "status",
    UpdatedAt = "updatedAt",
    VersionNumber = "versionNumber"
}
/** Input for updating a plan */
export declare type PlanUpdateInput = {
    /** Additional metadata for the plan, e.g. features or tags */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** The unique identifier for the entity in the billing provider */
    billingId?: InputMaybe<Scalars['String']>;
    /** Default trial configuration for the plan */
    defaultTrialConfig?: InputMaybe<DefaultTrialConfigInputDto>;
    /** The description of the plan */
    description?: InputMaybe<Scalars['String']>;
    /** The display name of the plan */
    displayName?: InputMaybe<Scalars['String']>;
    /** Indicates if the plan should be hidden from widgets */
    hiddenFromWidgets?: InputMaybe<Array<WidgetType>>;
    /** The ID of the plan to update */
    id: Scalars['UUID'];
    /** The minimum spend configuration per each billing period */
    minimumSpend?: InputMaybe<Array<MinimumSpendInput>>;
    /** The ID of the parent plan, if applicable */
    parentPlanId?: InputMaybe<Scalars['String']>;
    /** The status of the plan, e.g. "active" or "archived" */
    status?: InputMaybe<PackageStatus>;
};
/** Input for preparing a payment method form */
export declare type PreparePaymentMethodFormInput = {
    /** Customer slug */
    customerId: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The billing integration to use for this payment method */
    integrationId?: InputMaybe<Scalars['String']>;
};
/** Input to preview the next invoice for a subscription */
export declare type PreviewNextInvoiceInput = {
    /** The environment id of the subscription to preview */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The subscription id to preview */
    subscriptionId: Scalars['String'];
};
export declare type PreviewSubscriptionInput = {
    addons?: InputMaybe<Array<SubscriptionAddonInput>>;
    /** Coupon input */
    appliedCoupon?: InputMaybe<SubscriptionCouponInput>;
    billableFeatures?: InputMaybe<Array<BillableFeatureInput>>;
    billingCountryCode?: InputMaybe<Scalars['String']>;
    billingInformation?: InputMaybe<SubscriptionBillingInfo>;
    billingPeriod?: InputMaybe<BillingPeriod>;
    customerId: Scalars['String'];
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The customer that will pay for the subscription */
    payingCustomerId?: InputMaybe<Scalars['String']>;
    planId: Scalars['String'];
    promotionCode?: InputMaybe<Scalars['String']>;
    resourceId?: InputMaybe<Scalars['String']>;
    scheduleStrategy?: InputMaybe<ScheduleStrategy>;
    startDate?: InputMaybe<Scalars['DateTime']>;
    /** trial configuration to override the default values from plan if exists */
    trialOverrideConfiguration?: InputMaybe<TrialOverrideConfigurationInput>;
    unitQuantity?: InputMaybe<Scalars['Float']>;
};
export declare type PriceFilter = {
    and?: InputMaybe<Array<PriceFilter>>;
    billingCadence?: InputMaybe<BillingCadenceFilterComparison>;
    billingId?: InputMaybe<StringFieldComparison>;
    billingModel?: InputMaybe<BillingModelFilterComparison>;
    billingPeriod?: InputMaybe<BillingPeriodFilterComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<PriceFilter>>;
    package?: InputMaybe<PriceFilterPackageDtoFilter>;
    tiersMode?: InputMaybe<TiersModeFilterComparison>;
};
export declare type PriceFilterPackageDtoFilter = {
    and?: InputMaybe<Array<PriceFilterPackageDtoFilter>>;
    billingId?: InputMaybe<StringFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    description?: InputMaybe<StringFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    isLatest?: InputMaybe<BooleanFieldComparison>;
    or?: InputMaybe<Array<PriceFilterPackageDtoFilter>>;
    pricingType?: InputMaybe<PricingTypeFilterComparison>;
    productId?: InputMaybe<StringFieldComparison>;
    refId?: InputMaybe<StringFieldComparison>;
    status?: InputMaybe<PackageStatusFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
    versionNumber?: InputMaybe<IntFieldComparison>;
};
export declare type PriceOverrideInput = {
    /** The corresponding addon id of the price */
    addonId?: InputMaybe<Scalars['String']>;
    /** Whether the price is a base charge */
    baseCharge?: InputMaybe<Scalars['Boolean']>;
    /** The number of units per block. Defaults to 1 unit */
    blockSize?: InputMaybe<Scalars['Float']>;
    /** The credit rate for this period */
    creditRate?: InputMaybe<CreditRateInput>;
    /** The corresponding feature id of the price */
    featureId?: InputMaybe<Scalars['String']>;
    /** The price of the price period */
    price?: InputMaybe<MoneyInputDto>;
    /** List of tiers of the price period */
    tiers?: InputMaybe<Array<PriceTierInput>>;
};
/** Price Period Input */
export declare type PricePeriodInput = {
    /** The billing country code of the price */
    billingCountryCode?: InputMaybe<Scalars['String']>;
    /** The billing period of the price */
    billingPeriod: BillingPeriod;
    /** The number of units per block. Defaults to 1 unit */
    blockSize?: InputMaybe<Scalars['Float']>;
    /** The credit rate for this period */
    creditRate?: InputMaybe<CreditRateInput>;
    /** The price of the price period */
    price?: InputMaybe<MoneyInputDto>;
    /** List of tiers of the price period */
    tiers?: InputMaybe<Array<PriceTierInput>>;
};
export declare type PriceSort = {
    direction: SortDirection;
    field: PriceSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum PriceSortFields {
    BillingCadence = "billingCadence",
    BillingId = "billingId",
    BillingModel = "billingModel",
    BillingPeriod = "billingPeriod",
    CreatedAt = "createdAt",
    Id = "id",
    TiersMode = "tiersMode"
}
/** Price Tier Input */
export declare type PriceTierInput = {
    /** The flat fee price of the price tier */
    flatPrice?: InputMaybe<MoneyInputDto>;
    /** The unit price of the price tier */
    unitPrice?: InputMaybe<MoneyInputDto>;
    /** The up to quantity of the price tier */
    upTo?: InputMaybe<Scalars['Float']>;
};
/** Pricing Model Create Input */
export declare type PricingModelCreateInput = {
    /** The billing cadence of the base pricing model */
    billingCadence?: InputMaybe<BillingCadence>;
    /** The billing model of the base pricing model */
    billingModel: BillingModel;
    /** The feature id of the base pricing model */
    featureId?: InputMaybe<Scalars['String']>;
    /** The maximum unit quantity of the pricing model */
    maxUnitQuantity?: InputMaybe<Scalars['Float']>;
    /** The minimum unit quantity of the pricing model */
    minUnitQuantity?: InputMaybe<Scalars['Float']>;
    /** The monthly reset period configuration of the pricing model */
    monthlyResetPeriodConfiguration?: InputMaybe<MonthlyResetPeriodConfigInput>;
    /** The price periods of the base pricing model */
    pricePeriods: Array<PricePeriodInput>;
    /** The reset period of the pricing model */
    resetPeriod?: InputMaybe<EntitlementResetPeriod>;
    /** The tiers mode of the pricing model */
    tiersMode?: InputMaybe<TiersMode>;
    /** The weekly reset period configuration of the pricing model */
    weeklyResetPeriodConfiguration?: InputMaybe<WeeklyResetPeriodConfigInput>;
    /** The yearly reset period configuration of the pricing model */
    yearlyResetPeriodConfiguration?: InputMaybe<YearlyResetPeriodConfigInput>;
};
/** Pricing Type. */
export declare enum PricingType {
    Custom = "CUSTOM",
    Free = "FREE",
    Paid = "PAID"
}
export declare type PricingTypeFilterComparison = {
    eq?: InputMaybe<PricingType>;
    gt?: InputMaybe<PricingType>;
    gte?: InputMaybe<PricingType>;
    iLike?: InputMaybe<PricingType>;
    in?: InputMaybe<Array<PricingType>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<PricingType>;
    lt?: InputMaybe<PricingType>;
    lte?: InputMaybe<PricingType>;
    neq?: InputMaybe<PricingType>;
    notILike?: InputMaybe<PricingType>;
    notIn?: InputMaybe<Array<PricingType>>;
    notLike?: InputMaybe<PricingType>;
};
/** Input for creating a product */
export declare type ProductCreateInput = {
    /** Additional metadata for the product */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** Description of the product */
    description?: InputMaybe<Scalars['String']>;
    /** Display name of the product */
    displayName?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId: Scalars['UUID'];
    /** Indicates if multiple subscriptions to this product are allowed */
    multipleSubscriptions?: InputMaybe<Scalars['Boolean']>;
    /** The unique identifier for the entity */
    refId: Scalars['String'];
};
export declare type ProductFilter = {
    and?: InputMaybe<Array<ProductFilter>>;
    awsMarketplaceProductCode?: InputMaybe<StringFieldComparison>;
    awsMarketplaceProductId?: InputMaybe<StringFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    description?: InputMaybe<StringFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    isDefaultProduct?: InputMaybe<BooleanFieldComparison>;
    multipleSubscriptions?: InputMaybe<BooleanFieldComparison>;
    or?: InputMaybe<Array<ProductFilter>>;
    refId?: InputMaybe<StringFieldComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
/** Input for product settings */
export declare type ProductSettingsInput = {
    /** Indicates if the subscription should be downgraded at the end of the billing period */
    downgradeAtEndOfBillingPeriod?: InputMaybe<Scalars['String']>;
    /** ID of the plan to downgrade to at the end of the billing period */
    downgradePlanId?: InputMaybe<Scalars['String']>;
    /** Indicates if the subscription should be prorated at the end of the billing period */
    prorateAtEndOfBillingPeriod?: InputMaybe<Scalars['Boolean']>;
    /** Time when the subscription will be cancelled */
    subscriptionCancellationTime: SubscriptionCancellationTime;
    /** Setup for the end of the subscription */
    subscriptionEndSetup: SubscriptionEndSetup;
    /** ID of the plan to start the subscription with */
    subscriptionStartPlanId?: InputMaybe<Scalars['String']>;
    /** Setup for the start of the subscription */
    subscriptionStartSetup: SubscriptionStartSetup;
};
export declare type ProductSort = {
    direction: SortDirection;
    field: ProductSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum ProductSortFields {
    AwsMarketplaceProductCode = "awsMarketplaceProductCode",
    AwsMarketplaceProductId = "awsMarketplaceProductId",
    CreatedAt = "createdAt",
    Description = "description",
    DisplayName = "displayName",
    EnvironmentId = "environmentId",
    Id = "id",
    IsDefaultProduct = "isDefaultProduct",
    MultipleSubscriptions = "multipleSubscriptions",
    RefId = "refId",
    UpdatedAt = "updatedAt"
}
/** Input for updating a product */
export declare type ProductUpdateInput = {
    /** Additional metadata for the product */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** Auto cancellation rules */
    autoCancellationRules?: InputMaybe<Array<AutoCancellationRuleInput>>;
    /** Description of the product */
    description?: InputMaybe<Scalars['String']>;
    /** Display name of the product */
    displayName?: InputMaybe<Scalars['String']>;
    /** Indicates if multiple subscriptions to this product are allowed */
    multipleSubscriptions?: InputMaybe<Scalars['Boolean']>;
    /** Settings for the product */
    productSettings?: InputMaybe<ProductSettingsInput>;
    /** Usage reset cutoff rule */
    usageResetCutoffRule?: InputMaybe<SubscriptionUpdateUsageResetCutoffRuleInput>;
};
export declare type PromotionalEntitlementFilter = {
    and?: InputMaybe<Array<PromotionalEntitlementFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<PromotionalEntitlementFilter>>;
    status?: InputMaybe<PromotionalEntitlementStatusFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
/** Promotional entitlement input */
export declare type PromotionalEntitlementInput = {
    /** The unique identifier of the entitlement customer */
    customerId: Scalars['String'];
    /** The description of the entitlement */
    description?: InputMaybe<Scalars['String']>;
    /** The end date of the promotional entitlement */
    endDate?: InputMaybe<Scalars['DateTime']>;
    /** The enum values of the entitlement */
    enumValues?: InputMaybe<Array<Scalars['String']>>;
    /** The unique identifier for the environment */
    environmentId: Scalars['UUID'];
    /** Primary feature group ID (first in the array) associated with this entitlement */
    featureGroupId?: InputMaybe<Scalars['UUID']>;
    /** The unique identifier of the entitlement feature */
    featureId: Scalars['String'];
    /** Whether the entitlement has a soft limit */
    hasSoftLimit?: InputMaybe<Scalars['Boolean']>;
    /** Whether the entitlement has an unlimited usage */
    hasUnlimitedUsage?: InputMaybe<Scalars['Boolean']>;
    /** Whether the entitlement is visible */
    isVisible: Scalars['Boolean'];
    /** The monthly reset period configuration of the entitlement, defined when reset period is monthly */
    monthlyResetPeriodConfiguration?: InputMaybe<MonthlyResetPeriodConfigInput>;
    /** The grant period of the promotional entitlement */
    period: PromotionalEntitlementPeriod;
    /** The reset period of the entitlement */
    resetPeriod?: InputMaybe<EntitlementResetPeriod>;
    /** The usage limit of the entitlement */
    usageLimit?: InputMaybe<Scalars['Float']>;
    /** The weekly reset period configuration of the entitlement, defined when reset period is weekly */
    weeklyResetPeriodConfiguration?: InputMaybe<WeeklyResetPeriodConfigInput>;
    /** The yearly reset period configuration of the entitlement, defined when reset period is yearly */
    yearlyResetPeriodConfiguration?: InputMaybe<YearlyResetPeriodConfigInput>;
};
/** Promotional entitlement duration */
export declare enum PromotionalEntitlementPeriod {
    Custom = "CUSTOM",
    /** Lifetime */
    Lifetime = "LIFETIME",
    /** One month */
    OneMonth = "ONE_MONTH",
    /** One week */
    OneWeek = "ONE_WEEK",
    /** One year */
    OneYear = "ONE_YEAR",
    /** Six months */
    SixMonth = "SIX_MONTH"
}
export declare type PromotionalEntitlementSort = {
    direction: SortDirection;
    field: PromotionalEntitlementSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum PromotionalEntitlementSortFields {
    CreatedAt = "createdAt",
    EnvironmentId = "environmentId",
    Id = "id",
    Status = "status",
    UpdatedAt = "updatedAt"
}
/** Promotional entitlement status */
export declare enum PromotionalEntitlementStatus {
    /** Active */
    Active = "Active",
    /** Expired */
    Expired = "Expired",
    /** Paused */
    Paused = "Paused"
}
export declare type PromotionalEntitlementStatusFilterComparison = {
    eq?: InputMaybe<PromotionalEntitlementStatus>;
    gt?: InputMaybe<PromotionalEntitlementStatus>;
    gte?: InputMaybe<PromotionalEntitlementStatus>;
    iLike?: InputMaybe<PromotionalEntitlementStatus>;
    in?: InputMaybe<Array<PromotionalEntitlementStatus>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<PromotionalEntitlementStatus>;
    lt?: InputMaybe<PromotionalEntitlementStatus>;
    lte?: InputMaybe<PromotionalEntitlementStatus>;
    neq?: InputMaybe<PromotionalEntitlementStatus>;
    notILike?: InputMaybe<PromotionalEntitlementStatus>;
    notIn?: InputMaybe<Array<PromotionalEntitlementStatus>>;
    notLike?: InputMaybe<PromotionalEntitlementStatus>;
};
/** Promotional entitlement update input */
export declare type PromotionalEntitlementUpdateInput = {
    /** The description of the entitlement */
    description?: InputMaybe<Scalars['String']>;
    /** The end date of the promotional entitlement */
    endDate?: InputMaybe<Scalars['DateTime']>;
    /** The enum values of the entitlement */
    enumValues?: InputMaybe<Array<Scalars['String']>>;
    /** Whether the entitlement has a soft limit */
    hasSoftLimit?: InputMaybe<Scalars['Boolean']>;
    /** Whether the entitlement has an unlimited usage */
    hasUnlimitedUsage?: InputMaybe<Scalars['Boolean']>;
    /** Whether the entitlement is visible */
    isVisible: Scalars['Boolean'];
    /** The monthly reset period configuration of the entitlement, defined when reset period is monthly */
    monthlyResetPeriodConfiguration?: InputMaybe<MonthlyResetPeriodConfigInput>;
    /** The grant period of the promotional entitlement */
    period: PromotionalEntitlementPeriod;
    /** The reset period of the entitlement */
    resetPeriod?: InputMaybe<EntitlementResetPeriod>;
    /** The usage limit of the entitlement */
    usageLimit?: InputMaybe<Scalars['Float']>;
    /** The weekly reset period configuration of the entitlement, defined when reset period is weekly */
    weeklyResetPeriodConfiguration?: InputMaybe<WeeklyResetPeriodConfigInput>;
};
/** Proration behavior for subscription billing */
export declare enum ProrationBehavior {
    /** Create proration invoice items for changes in the subscription */
    CreateProrations = "CREATE_PRORATIONS",
    /** Invoice immediately for changes in the subscription without proration */
    InvoiceImmediately = "INVOICE_IMMEDIATELY"
}
/** Input to provision a customer and subscription */
export declare type ProvisionCustomerInput = {
    /** Additional metadata */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** The AWS Marketplace integration id */
    awsMarketplaceCustomerId?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the entity in the billing provider */
    billingId?: InputMaybe<Scalars['String']>;
    /** Customer billing information */
    billingInformation?: InputMaybe<CustomerBillingInfo>;
    /** Customer level coupon */
    couponRefId?: InputMaybe<Scalars['String']>;
    /** Timestamp of when the record was created */
    createdAt?: InputMaybe<Scalars['DateTime']>;
    /** The unique identifier for the customer in Hubspot integration */
    crmId?: InputMaybe<Scalars['String']>;
    /** Customer slug */
    customerId?: InputMaybe<Scalars['String']>;
    /** The email of the customer */
    email?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Wether the customer should be excluded from the experiment */
    excludeFromExperiment?: InputMaybe<Scalars['Boolean']>;
    /** The name of the customer */
    name?: InputMaybe<Scalars['String']>;
    /** Customer slug */
    refId?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the customer in Salesforce integration */
    salesforceId?: InputMaybe<Scalars['String']>;
    /** Wether or not to sync free subscriptions to the billing provider */
    shouldSyncFree?: InputMaybe<Scalars['Boolean']>;
    /** Subscription parameters */
    subscriptionParams?: InputMaybe<ProvisionCustomerSubscriptionInput>;
};
/** Provision a new subscription for a customer */
export declare type ProvisionCustomerSubscriptionInput = {
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    addons?: InputMaybe<Array<SubscriptionAddonInput>>;
    /** Coupon input */
    appliedCoupon?: InputMaybe<SubscriptionCouponInput>;
    awaitPaymentConfirmation?: InputMaybe<Scalars['Boolean']>;
    billableFeatures?: InputMaybe<Array<BillableFeatureInput>>;
    billingCountryCode?: InputMaybe<Scalars['String']>;
    billingId?: InputMaybe<Scalars['String']>;
    billingInformation?: InputMaybe<SubscriptionBillingInfo>;
    billingPeriod?: InputMaybe<BillingPeriod>;
    /** Budget configuration */
    budget?: InputMaybe<BudgetConfigurationInput>;
    /** The minimum spend configuration */
    minimumSpend?: InputMaybe<SubscriptionMinimumSpendValueInput>;
    /** Subscription payment collection method */
    paymentCollectionMethod?: InputMaybe<PaymentCollectionMethod>;
    planId: Scalars['String'];
    /** Override the price of the subscription */
    priceOverrides?: InputMaybe<Array<PriceOverrideInput>>;
    priceUnitAmount?: InputMaybe<Scalars['Float']>;
    promotionCode?: InputMaybe<Scalars['String']>;
    refId?: InputMaybe<Scalars['String']>;
    resourceId?: InputMaybe<Scalars['String']>;
    salesforceId?: InputMaybe<Scalars['String']>;
    startDate?: InputMaybe<Scalars['DateTime']>;
    subscriptionEntitlements?: InputMaybe<Array<SubscriptionEntitlementInput>>;
    subscriptionId?: InputMaybe<Scalars['String']>;
    trialOverrideConfiguration?: InputMaybe<TrialOverrideConfigurationInput>;
    unitQuantity?: InputMaybe<Scalars['Float']>;
};
/** Input for provisioning a sandbox environment */
export declare type ProvisionSandboxInput = {
    /** The billing model to use for the sandbox environment */
    billingModel: BillingModel;
    /** The name of the sandbox environment */
    displayName: Scalars['String'];
};
export declare type ProvisionSubscription = {
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    addons?: InputMaybe<Array<SubscriptionAddonInput>>;
    /** Coupon input */
    appliedCoupon?: InputMaybe<SubscriptionCouponInput>;
    awaitPaymentConfirmation?: InputMaybe<Scalars['Boolean']>;
    billableFeatures?: InputMaybe<Array<BillableFeatureInput>>;
    billingCountryCode?: InputMaybe<Scalars['String']>;
    billingId?: InputMaybe<Scalars['String']>;
    billingInformation?: InputMaybe<SubscriptionBillingInfo>;
    billingPeriod?: InputMaybe<BillingPeriod>;
    /** Budget configuration */
    budget?: InputMaybe<BudgetConfigurationInput>;
    checkoutOptions?: InputMaybe<CheckoutOptions>;
    customerId: Scalars['String'];
    /** The minimum spend configuration */
    minimumSpend?: InputMaybe<SubscriptionMinimumSpendValueInput>;
    payingCustomerId?: InputMaybe<Scalars['String']>;
    /** Subscription payment collection method */
    paymentCollectionMethod?: InputMaybe<PaymentCollectionMethod>;
    planId: Scalars['String'];
    /** Override the price of the subscription */
    priceOverrides?: InputMaybe<Array<PriceOverrideInput>>;
    priceUnitAmount?: InputMaybe<Scalars['Float']>;
    promotionCode?: InputMaybe<Scalars['String']>;
    refId?: InputMaybe<Scalars['String']>;
    resourceId?: InputMaybe<Scalars['String']>;
    salesforceId?: InputMaybe<Scalars['String']>;
    scheduleStrategy?: InputMaybe<ScheduleStrategy>;
    skipTrial?: InputMaybe<Scalars['Boolean']>;
    startDate?: InputMaybe<Scalars['DateTime']>;
    subscriptionEntitlements?: InputMaybe<Array<SubscriptionEntitlementInput>>;
    subscriptionId?: InputMaybe<Scalars['String']>;
    trialOverrideConfiguration?: InputMaybe<TrialOverrideConfigurationInput>;
    unitQuantity?: InputMaybe<Scalars['Float']>;
};
export declare type ProvisionSubscriptionInput = {
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    addons?: InputMaybe<Array<SubscriptionAddonInput>>;
    /** Coupon input */
    appliedCoupon?: InputMaybe<SubscriptionCouponInput>;
    awaitPaymentConfirmation?: InputMaybe<Scalars['Boolean']>;
    billableFeatures?: InputMaybe<Array<BillableFeatureInput>>;
    billingCountryCode?: InputMaybe<Scalars['String']>;
    billingId?: InputMaybe<Scalars['String']>;
    billingInformation?: InputMaybe<SubscriptionBillingInfo>;
    billingPeriod?: InputMaybe<BillingPeriod>;
    /** Budget configuration */
    budget?: InputMaybe<BudgetConfigurationInput>;
    checkoutOptions?: InputMaybe<CheckoutOptions>;
    customerId: Scalars['String'];
    /** The minimum spend configuration */
    minimumSpend?: InputMaybe<SubscriptionMinimumSpendValueInput>;
    payingCustomerId?: InputMaybe<Scalars['String']>;
    /** Subscription payment collection method */
    paymentCollectionMethod?: InputMaybe<PaymentCollectionMethod>;
    planId: Scalars['String'];
    /** Override the price of the subscription */
    priceOverrides?: InputMaybe<Array<PriceOverrideInput>>;
    priceUnitAmount?: InputMaybe<Scalars['Float']>;
    promotionCode?: InputMaybe<Scalars['String']>;
    refId?: InputMaybe<Scalars['String']>;
    resourceId?: InputMaybe<Scalars['String']>;
    salesforceId?: InputMaybe<Scalars['String']>;
    scheduleStrategy?: InputMaybe<ScheduleStrategy>;
    skipTrial?: InputMaybe<Scalars['Boolean']>;
    startDate?: InputMaybe<Scalars['DateTime']>;
    subscriptionEntitlements?: InputMaybe<Array<SubscriptionEntitlementInput>>;
    subscriptionId?: InputMaybe<Scalars['String']>;
    trialOverrideConfiguration?: InputMaybe<TrialOverrideConfigurationInput>;
    unitQuantity?: InputMaybe<Scalars['Float']>;
};
/** Provision subscription status */
export declare enum ProvisionSubscriptionStatus {
    PaymentRequired = "PAYMENT_REQUIRED",
    Success = "SUCCESS"
}
/** The migration type, either publish the new version to new customers or all customers */
export declare enum PublishMigrationType {
    /** Publish to all customers */
    AllCustomers = "ALL_CUSTOMERS",
    /** Publish only to new customers */
    NewCustomers = "NEW_CUSTOMERS"
}
/** Input object for triggering entitlement recalculation for one or more customers. */
export declare type RecalculateEntitlementsInput = {
    /** List of customer IDs for which to recalculate entitlements. */
    customerIds?: InputMaybe<Array<Scalars['String']>>;
    /** Identifier of the environment where recalculation should occur. */
    environmentId: Scalars['UUID'];
    /** If true, recalculates entitlements for all customers in the environment. */
    forAllCustomers?: InputMaybe<Scalars['Boolean']>;
    /** Optional flags to control recalculation side effects. */
    sideEffectsOptions?: InputMaybe<RecalculateEntitlementsSideEffectsOptionsInput>;
};
/** Flags to control side effects triggered during entitlement recalculation. */
export declare type RecalculateEntitlementsSideEffectsOptionsInput = {
    /** Prevents publishing entitlement updates to subscribers. */
    skipPublishToSubscribers?: InputMaybe<Scalars['Boolean']>;
    /** Skips cache updates for recalculated entitlements. */
    skipWriteToCache?: InputMaybe<Scalars['Boolean']>;
    /** Skips updating the data catalog during recalculation. */
    skipWriteToDataCatalog?: InputMaybe<Scalars['Boolean']>;
    /** Skips writing entitlement recalculation events to the event log. */
    skipWriteToEventLog?: InputMaybe<Scalars['Boolean']>;
};
export declare type RemoveBasePlanFromPlanInput = {
    /** The id of the record. */
    id: Scalars['UUID'];
    /** The id of relation. */
    relationId: Scalars['UUID'];
};
export declare type RemoveCompatibleAddonsFromPlanInput = {
    /** The id of the record. */
    id: Scalars['UUID'];
    /** The ids of the relations. */
    relationIds: Array<Scalars['UUID']>;
};
export declare type RemoveCouponFromCustomerInput = {
    /** The id of the record. */
    id: Scalars['UUID'];
    /** The id of relation. */
    relationId: Scalars['UUID'];
};
export declare type RemoveExperimentFromCustomerInput = {
    /** The id of the record. */
    id: Scalars['UUID'];
    /** The id of relation. */
    relationId: Scalars['UUID'];
};
export declare type RemoveExperimentFromCustomerSubscriptionInput = {
    /** The id of the record. */
    id: Scalars['UUID'];
    /** The id of relation. */
    relationId: Scalars['UUID'];
};
/** Input for removing a feature group and his related entitlements (if there are no other groups they are a part of) from a package */
export declare type RemoveFeatureGroupFromPackageInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The group id to remove */
    featureGroupId: Scalars['UUID'];
    /** The unique identifier of the entitlement package */
    packageId: Scalars['UUID'];
};
/** Report usage base input */
export declare type ReportUsageBaseInput = {
    /** Timestamp of when the record was created */
    createdAt?: InputMaybe<Scalars['DateTime']>;
    /** Customer id */
    customerId: Scalars['String'];
    /** Additional dimensions for the usage report */
    dimensions?: InputMaybe<Scalars['JSON']>;
    /** Feature id */
    featureId: Scalars['String'];
    /** Resource id */
    resourceId?: InputMaybe<Scalars['String']>;
    /** The method by which the usage value should be updated */
    updateBehavior?: InputMaybe<UsageUpdateBehavior>;
    /** The value to report for usage */
    value: Scalars['Float'];
};
/** Input for reporting usage in bulk */
export declare type ReportUsageBulkInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** A list of usage reports to be submitted in bulk */
    usages: Array<ReportUsageBaseInput>;
};
/** Input parameters for reporting usage */
export declare type ReportUsageInput = {
    /** Timestamp of when the record was created */
    createdAt?: InputMaybe<Scalars['DateTime']>;
    /** Customer id */
    customerId: Scalars['String'];
    /** Additional dimensions for the usage report */
    dimensions?: InputMaybe<Scalars['JSON']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Feature id */
    featureId: Scalars['String'];
    /** Resource id */
    resourceId?: InputMaybe<Scalars['String']>;
    /** The method by which the usage value should be updated */
    updateBehavior?: InputMaybe<UsageUpdateBehavior>;
    /** The value to report for usage */
    value: Scalars['Float'];
};
/** Input for re-syncing an integration */
export declare type ResyncIntegrationInput = {
    /** The unique identifier for the environment */
    environmentId: Scalars['String'];
    /** Internal ID of the integration to re-sync */
    integrationId: Scalars['String'];
    /** Allow skipping entitlement recalculation */
    recalculateEntitlements?: InputMaybe<Scalars['Boolean']>;
    /** The vendor identifier of integration */
    vendorIdentifier?: InputMaybe<VendorIdentifier>;
};
/** Revoke promotional entitlement input */
export declare type RevokePromotionalEntitlementInput = {
    /** The unique identifier of the entitlement customer */
    customerId: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The unique identifier of the entitlement feature */
    featureId: Scalars['String'];
};
/** Revoke promotional entitlements for a feature group input */
export declare type RevokePromotionalEntitlementsGroupInput = {
    /** The unique identifier of the entitlement customer */
    customerId: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Feature group ID to revoke from promotional entitlements */
    featureGroupId: Scalars['UUID'];
};
/** Input configuration for Salesforce Integration */
export declare type SalesforceCredentialsInput = {
    /** Domain of the Salesforce account */
    domain?: InputMaybe<Scalars['String']>;
};
/** Options for when a change for a paid subscription should take effect */
export declare enum ScheduleStrategy {
    /** Schedule the change to the end of the billing month (for subscriptions whose billing period is larger then month) */
    EndOfBillingMonth = "END_OF_BILLING_MONTH",
    /** Schedule the change to the end of the billing period */
    EndOfBillingPeriod = "END_OF_BILLING_PERIOD",
    /** Apply the change immediately */
    Immediate = "IMMEDIATE"
}
/** Input for setting access roles for a user */
export declare type SetAccessRolesInput = {
    /** Account level access of the user */
    accountRole: AccountAccessRole;
    /** Environment level access of the user */
    nonProductionRole: EnvironmentAccessRole;
    /** Environment level access of the user */
    productionRole: EnvironmentAccessRole;
    /** The id of the user associated with this member */
    userId: Scalars['String'];
};
export declare type SetBasePlanOnPlanInput = {
    /** The id of the record. */
    id: Scalars['UUID'];
    /** The id of relation. */
    relationId: Scalars['UUID'];
};
export declare type SetCompatibleAddonsOnPlanInput = {
    /** The id of the record. */
    id: Scalars['UUID'];
    /** The ids of the relations. */
    relationIds: Array<Scalars['UUID']>;
};
export declare type SetCouponOnCustomerInput = {
    /** The id of the record. */
    id: Scalars['UUID'];
    /** The id of relation. */
    relationId: Scalars['UUID'];
};
export declare type SetExperimentOnCustomerInput = {
    /** The id of the record. */
    id: Scalars['UUID'];
    /** The id of relation. */
    relationId: Scalars['UUID'];
};
export declare type SetExperimentOnCustomerSubscriptionInput = {
    /** The id of the record. */
    id: Scalars['UUID'];
    /** The id of relation. */
    relationId: Scalars['UUID'];
};
/** The input type for setting the addons of an package group */
export declare type SetPackageGroupAddons = {
    /** The addons to set on the package group */
    addons: Array<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The id of the package group */
    packageGroupId: Scalars['String'];
};
/** Set plan compatible package groups input */
export declare type SetPlanCompatiblePackageGroup = {
    /** The options for the package group */
    options?: InputMaybe<SetPlanCompatiblePackageGroupOptions>;
    /** The package group id */
    packageGroupId: Scalars['String'];
};
/** Set plan compatible package groups input */
export declare type SetPlanCompatiblePackageGroupOptions = {
    /** Number of free items from packageGroup */
    freeItems?: InputMaybe<Scalars['Float']>;
    /** Number of required items from packageGroup */
    minItems?: InputMaybe<Scalars['Float']>;
};
/** Set plan compatible package groups input */
export declare type SetPlanCompatiblePackageGroups = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The id of the plan */
    id: Scalars['String'];
    /** The package groups with optional options */
    packageGroups: Array<SetPlanCompatiblePackageGroup>;
};
/** Input configuration for Snowflake integration */
export declare type SnowflakeCredentialsInput = {
    /** The database you specified when creating the Stigg entities in Snowflake, for example: STIGG_DATABASE */
    database: Scalars['String'];
    /** The Snowflake account URL, for example: https://ab12345.us-east-2.aws.snowflakecomputing.com */
    host: Scalars['String'];
    /** The password you specified when creating the Stigg entities in Snowflake */
    password: Scalars['String'];
    /** The role you specified when creating the Stigg entities in Snowflake, for example: STIGG_ROLE */
    role: Scalars['String'];
    /** The schema you specified when creating the Stigg entities in Snowflake, for example: STIGG_SCHEMA */
    schemaName: Scalars['String'];
    /** The username you specified when creating the Stigg entities in Snowflake, for example: STIGG_USER */
    username: Scalars['String'];
    /** The warehouse you specified when creating the Stigg entities in Snowflake, for example: STIGG_WAREHOUSE */
    warehouse: Scalars['String'];
};
/** Sort Directions */
export declare enum SortDirection {
    Asc = "ASC",
    Desc = "DESC"
}
/** Sort Nulls Options */
export declare enum SortNulls {
    NullsFirst = "NULLS_FIRST",
    NullsLast = "NULLS_LAST"
}
export declare enum SourceType {
    JsClientSdk = "JS_CLIENT_SDK",
    NodeServerSdk = "NODE_SERVER_SDK",
    PersistentCacheService = "PERSISTENT_CACHE_SERVICE"
}
/** Input parameters for starting an experiment */
export declare type StartExperimentInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The unique identifier for the experiment */
    refId: Scalars['String'];
};
/** Input parameters for stopping an experiment */
export declare type StopExperimentInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The unique identifier for the experiment */
    refId: Scalars['String'];
};
export declare type StringFieldComparison = {
    eq?: InputMaybe<Scalars['String']>;
    gt?: InputMaybe<Scalars['String']>;
    gte?: InputMaybe<Scalars['String']>;
    iLike?: InputMaybe<Scalars['String']>;
    in?: InputMaybe<Array<Scalars['String']>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<Scalars['String']>;
    lt?: InputMaybe<Scalars['String']>;
    lte?: InputMaybe<Scalars['String']>;
    neq?: InputMaybe<Scalars['String']>;
    notILike?: InputMaybe<Scalars['String']>;
    notIn?: InputMaybe<Array<Scalars['String']>>;
    notLike?: InputMaybe<Scalars['String']>;
};
/** Input configuration for Stripe integration */
export declare type StripeCredentialsInput = {
    /** ID of the Stripe account */
    accountId?: InputMaybe<Scalars['String']>;
    /** Authorization code for Stripe */
    authorizationCode: Scalars['String'];
    /** Whether tax is enabled for the Stripe account */
    isTaxEnabled?: InputMaybe<Scalars['Boolean']>;
    /** Whether the Stripe account is in test mode */
    isTestMode: Scalars['Boolean'];
};
/** Input parameters for searching Stripe customers */
export declare type StripeCustomerSearchInput = {
    /** Name of the customer to search for */
    customerName?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId: Scalars['String'];
    /** Token for retrieving the next page of results */
    nextPage?: InputMaybe<Scalars['String']>;
};
/** Input parameters for searching Stripe products */
export declare type StripeProductSearchInput = {
    /** The unique identifier for the environment */
    environmentId: Scalars['String'];
    /** Token for retrieving the next page of results */
    nextPage?: InputMaybe<Scalars['String']>;
    /** Name of the product to search for */
    productName?: InputMaybe<Scalars['String']>;
};
/** Input parameters for searching Stripe subscriptions */
export declare type StripeSubscriptionSearchInput = {
    /** The unique identifier for the environment */
    environmentId: Scalars['String'];
    /** Token for retrieving the next page of results */
    nextPage?: InputMaybe<Scalars['String']>;
};
export declare type SubscriptionAddonFilter = {
    and?: InputMaybe<Array<SubscriptionAddonFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<SubscriptionAddonFilter>>;
    price?: InputMaybe<SubscriptionAddonFilterPriceFilter>;
    quantity?: InputMaybe<NumberFieldComparison>;
    subscription?: InputMaybe<SubscriptionAddonFilterCustomerSubscriptionFilter>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
export declare type SubscriptionAddonFilterCustomerSubscriptionFilter = {
    and?: InputMaybe<Array<SubscriptionAddonFilterCustomerSubscriptionFilter>>;
    billingCycleAnchor?: InputMaybe<DateFieldComparison>;
    billingId?: InputMaybe<StringFieldComparison>;
    cancelReason?: InputMaybe<SubscriptionCancelReasonFilterComparison>;
    cancellationDate?: InputMaybe<DateFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    crmId?: InputMaybe<StringFieldComparison>;
    crmLinkUrl?: InputMaybe<StringFieldComparison>;
    currentBillingPeriodEnd?: InputMaybe<DateFieldComparison>;
    currentBillingPeriodStart?: InputMaybe<DateFieldComparison>;
    customerId?: InputMaybe<UuidFilterComparison>;
    effectiveEndDate?: InputMaybe<DateFieldComparison>;
    endDate?: InputMaybe<DateFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    oldBillingId?: InputMaybe<StringFieldComparison>;
    or?: InputMaybe<Array<SubscriptionAddonFilterCustomerSubscriptionFilter>>;
    payingCustomerId?: InputMaybe<UuidFilterComparison>;
    paymentCollection?: InputMaybe<PaymentCollectionFilterComparison>;
    pricingType?: InputMaybe<PricingTypeFilterComparison>;
    refId?: InputMaybe<StringFieldComparison>;
    resourceId?: InputMaybe<UuidFilterComparison>;
    salesforceId?: InputMaybe<StringFieldComparison>;
    startDate?: InputMaybe<DateFieldComparison>;
    status?: InputMaybe<SubscriptionStatusFilterComparison>;
    subscriptionId?: InputMaybe<StringFieldComparison>;
    trialEndDate?: InputMaybe<DateFieldComparison>;
};
export declare type SubscriptionAddonFilterPriceFilter = {
    and?: InputMaybe<Array<SubscriptionAddonFilterPriceFilter>>;
    billingCadence?: InputMaybe<BillingCadenceFilterComparison>;
    billingId?: InputMaybe<StringFieldComparison>;
    billingModel?: InputMaybe<BillingModelFilterComparison>;
    billingPeriod?: InputMaybe<BillingPeriodFilterComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<SubscriptionAddonFilterPriceFilter>>;
    tiersMode?: InputMaybe<TiersModeFilterComparison>;
};
export declare type SubscriptionAddonInput = {
    addonId: Scalars['String'];
    quantity?: InputMaybe<Scalars['Int']>;
};
export declare type SubscriptionAddonSort = {
    direction: SortDirection;
    field: SubscriptionAddonSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum SubscriptionAddonSortFields {
    CreatedAt = "createdAt",
    Id = "id",
    Quantity = "quantity",
    UpdatedAt = "updatedAt"
}
export declare type SubscriptionBillingInfo = {
    billingAddress?: InputMaybe<BillingAddress>;
    chargeOnBehalfOfAccount?: InputMaybe<Scalars['String']>;
    couponId?: InputMaybe<Scalars['String']>;
    /** The billing integration to use for this subscription */
    integrationId?: InputMaybe<Scalars['String']>;
    invoiceDaysUntilDue?: InputMaybe<Scalars['Float']>;
    isBackdated?: InputMaybe<Scalars['Boolean']>;
    isInvoicePaid?: InputMaybe<Scalars['Boolean']>;
    metadata?: InputMaybe<Scalars['JSON']>;
    /** Override the proration behavior for the subscription */
    prorationBehavior?: InputMaybe<SubscriptionProrationBehavior>;
    taxPercentage?: InputMaybe<Scalars['Float']>;
    taxRateIds?: InputMaybe<Array<Scalars['String']>>;
};
/** Subscription cancellation status */
export declare enum SubscriptionCancelReason {
    AutoCancellationRule = "AutoCancellationRule",
    CancelledByBilling = "CancelledByBilling",
    CustomerArchived = "CustomerArchived",
    DetachBilling = "DetachBilling",
    Expired = "Expired",
    Immediate = "Immediate",
    PendingPaymentExpired = "PendingPaymentExpired",
    ScheduledCancellation = "ScheduledCancellation",
    TrialConverted = "TrialConverted",
    TrialEnded = "TrialEnded",
    UpgradeOrDowngrade = "UpgradeOrDowngrade"
}
export declare type SubscriptionCancelReasonFilterComparison = {
    eq?: InputMaybe<SubscriptionCancelReason>;
    gt?: InputMaybe<SubscriptionCancelReason>;
    gte?: InputMaybe<SubscriptionCancelReason>;
    iLike?: InputMaybe<SubscriptionCancelReason>;
    in?: InputMaybe<Array<SubscriptionCancelReason>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<SubscriptionCancelReason>;
    lt?: InputMaybe<SubscriptionCancelReason>;
    lte?: InputMaybe<SubscriptionCancelReason>;
    neq?: InputMaybe<SubscriptionCancelReason>;
    notILike?: InputMaybe<SubscriptionCancelReason>;
    notIn?: InputMaybe<Array<SubscriptionCancelReason>>;
    notLike?: InputMaybe<SubscriptionCancelReason>;
};
/** Action to take when a subscription is cancelled */
export declare enum SubscriptionCancellationAction {
    /** Default action */
    Default = "DEFAULT",
    /** Revoke entitlements action */
    RevokeEntitlements = "REVOKE_ENTITLEMENTS"
}
export declare type SubscriptionCancellationInput = {
    awaitSubscriptionCancellation?: InputMaybe<Scalars['Boolean']>;
    endDate?: InputMaybe<Scalars['DateTime']>;
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** If set, enables or disables prorating of credits on subscription cancellation. */
    prorate?: InputMaybe<Scalars['Boolean']>;
    subscriptionCancellationAction?: InputMaybe<SubscriptionCancellationAction>;
    subscriptionCancellationTime?: InputMaybe<SubscriptionCancellationTime>;
    subscriptionRefId: Scalars['String'];
};
/** When the subscription will be cancelled */
export declare enum SubscriptionCancellationTime {
    /** At the end of the billing period */
    EndOfBillingPeriod = "END_OF_BILLING_PERIOD",
    /** Immediately */
    Immediate = "IMMEDIATE",
    /** On a specific date */
    SpecificDate = "SPECIFIC_DATE"
}
/** Subscription coupon configuration input */
export declare type SubscriptionCouponConfigurationInput = {
    /** The date to start the coupon from */
    startDate?: InputMaybe<Scalars['DateTime']>;
};
/** Inline subscription coupon input */
export declare type SubscriptionCouponDiscountInput = {
    /** Discount flat fee amounts off */
    amountsOff?: InputMaybe<Array<MoneyInputDto>>;
    /** Description of the coupon that will be created */
    description?: InputMaybe<Scalars['String']>;
    /** The duration in months for which the coupon remains active. */
    durationInMonths?: InputMaybe<Scalars['Float']>;
    /** Name of the coupon that will be created */
    name?: InputMaybe<Scalars['String']>;
    /** Discount percent off */
    percentOff?: InputMaybe<Scalars['Float']>;
};
/** Subscription coupon input */
export declare type SubscriptionCouponInput = {
    /** Billing integration coupon id */
    billingCouponId?: InputMaybe<Scalars['String']>;
    /** Coupon configuration input */
    configuration?: InputMaybe<SubscriptionCouponConfigurationInput>;
    /** Stigg coupon id */
    couponId?: InputMaybe<Scalars['String']>;
    /** An inline discount */
    discount?: InputMaybe<SubscriptionCouponDiscountInput>;
    /** Promotion code */
    promotionCode?: InputMaybe<Scalars['String']>;
};
/** The status of the subscription coupon */
export declare enum SubscriptionCouponStatus {
    Active = "ACTIVE",
    Expired = "EXPIRED",
    Removed = "REMOVED"
}
/** Subscription decision strategy */
export declare enum SubscriptionDecisionStrategy {
    PredefinedFreePlan = "PREDEFINED_FREE_PLAN",
    PredefinedTrialPlan = "PREDEFINED_TRIAL_PLAN",
    RequestedPlan = "REQUESTED_PLAN",
    SkippedSubscriptionCreation = "SKIPPED_SUBSCRIPTION_CREATION"
}
/** Setup for the end of the subscription */
export declare enum SubscriptionEndSetup {
    /** Cancel subscription */
    CancelSubscription = "CANCEL_SUBSCRIPTION",
    /** Downgrade to free plan */
    DowngradeToFree = "DOWNGRADE_TO_FREE"
}
export declare type SubscriptionEntitlementFilter = {
    and?: InputMaybe<Array<SubscriptionEntitlementFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    feature?: InputMaybe<SubscriptionEntitlementFilterFeatureFilter>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<SubscriptionEntitlementFilter>>;
    subscription?: InputMaybe<SubscriptionEntitlementFilterCustomerSubscriptionFilter>;
    subscriptionId?: InputMaybe<StringFieldComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
export declare type SubscriptionEntitlementFilterCustomerSubscriptionFilter = {
    and?: InputMaybe<Array<SubscriptionEntitlementFilterCustomerSubscriptionFilter>>;
    billingCycleAnchor?: InputMaybe<DateFieldComparison>;
    billingId?: InputMaybe<StringFieldComparison>;
    cancelReason?: InputMaybe<SubscriptionCancelReasonFilterComparison>;
    cancellationDate?: InputMaybe<DateFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    crmId?: InputMaybe<StringFieldComparison>;
    crmLinkUrl?: InputMaybe<StringFieldComparison>;
    currentBillingPeriodEnd?: InputMaybe<DateFieldComparison>;
    currentBillingPeriodStart?: InputMaybe<DateFieldComparison>;
    customerId?: InputMaybe<UuidFilterComparison>;
    effectiveEndDate?: InputMaybe<DateFieldComparison>;
    endDate?: InputMaybe<DateFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    oldBillingId?: InputMaybe<StringFieldComparison>;
    or?: InputMaybe<Array<SubscriptionEntitlementFilterCustomerSubscriptionFilter>>;
    payingCustomerId?: InputMaybe<UuidFilterComparison>;
    paymentCollection?: InputMaybe<PaymentCollectionFilterComparison>;
    pricingType?: InputMaybe<PricingTypeFilterComparison>;
    refId?: InputMaybe<StringFieldComparison>;
    resourceId?: InputMaybe<UuidFilterComparison>;
    salesforceId?: InputMaybe<StringFieldComparison>;
    startDate?: InputMaybe<DateFieldComparison>;
    status?: InputMaybe<SubscriptionStatusFilterComparison>;
    subscriptionId?: InputMaybe<StringFieldComparison>;
    trialEndDate?: InputMaybe<DateFieldComparison>;
};
export declare type SubscriptionEntitlementFilterFeatureFilter = {
    and?: InputMaybe<Array<SubscriptionEntitlementFilterFeatureFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    description?: InputMaybe<StringFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    featureStatus?: InputMaybe<FeatureStatusFilterComparison>;
    featureType?: InputMaybe<FeatureTypeFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    meterType?: InputMaybe<MeterTypeFilterComparison>;
    or?: InputMaybe<Array<SubscriptionEntitlementFilterFeatureFilter>>;
    refId?: InputMaybe<StringFieldComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
/** Subscription entitlement input */
export declare type SubscriptionEntitlementInput = {
    /** The description of the entitlement */
    description?: InputMaybe<Scalars['String']>;
    /** The unique identifier of the entitlement feature */
    featureId: Scalars['String'];
    /** Whether the entitlement has a soft limit */
    hasSoftLimit?: InputMaybe<Scalars['Boolean']>;
    /** Whether the entitlement has an unlimited usage */
    hasUnlimitedUsage?: InputMaybe<Scalars['Boolean']>;
    /** The monthly reset period configuration of the entitlement, defined when reset period is monthly */
    monthlyResetPeriodConfiguration?: InputMaybe<MonthlyResetPeriodConfigInput>;
    /** The reset period of the entitlement */
    resetPeriod?: InputMaybe<EntitlementResetPeriod>;
    /** The usage limit of the entitlement */
    usageLimit?: InputMaybe<Scalars['Float']>;
    /** The weekly reset period configuration of the entitlement, defined when reset period is weekly */
    weeklyResetPeriodConfiguration?: InputMaybe<WeeklyResetPeriodConfigInput>;
    /** The yearly reset period configuration of the entitlement, defined when reset period is yearly */
    yearlyResetPeriodConfiguration?: InputMaybe<YearlyResetPeriodConfigInput>;
};
export declare type SubscriptionEntitlementSort = {
    direction: SortDirection;
    field: SubscriptionEntitlementSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum SubscriptionEntitlementSortFields {
    CreatedAt = "createdAt",
    EnvironmentId = "environmentId",
    Id = "id",
    SubscriptionId = "subscriptionId",
    UpdatedAt = "updatedAt"
}
export declare type SubscriptionInput = {
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    addons?: InputMaybe<Array<SubscriptionAddonInput>>;
    /** Coupon input */
    appliedCoupon?: InputMaybe<SubscriptionCouponInput>;
    awaitPaymentConfirmation?: InputMaybe<Scalars['Boolean']>;
    billableFeatures?: InputMaybe<Array<BillableFeatureInput>>;
    billingCountryCode?: InputMaybe<Scalars['String']>;
    billingId?: InputMaybe<Scalars['String']>;
    billingInformation?: InputMaybe<SubscriptionBillingInfo>;
    billingPeriod?: InputMaybe<BillingPeriod>;
    /** Budget configuration */
    budget?: InputMaybe<BudgetConfigurationInput>;
    crmId?: InputMaybe<Scalars['String']>;
    customerId: Scalars['String'];
    endDate?: InputMaybe<Scalars['DateTime']>;
    environmentId?: InputMaybe<Scalars['UUID']>;
    isCustomPriceSubscription?: InputMaybe<Scalars['Boolean']>;
    isOverridingTrialConfig?: InputMaybe<Scalars['Boolean']>;
    isTrial?: InputMaybe<Scalars['Boolean']>;
    /** The minimum spend configuration */
    minimumSpend?: InputMaybe<SubscriptionMinimumSpendValueInput>;
    payingCustomerId?: InputMaybe<Scalars['String']>;
    /** Subscription payment collection method */
    paymentCollectionMethod?: InputMaybe<PaymentCollectionMethod>;
    planId: Scalars['String'];
    /** Override the price of the subscription */
    priceOverrides?: InputMaybe<Array<PriceOverrideInput>>;
    priceUnitAmount?: InputMaybe<Scalars['Float']>;
    promotionCode?: InputMaybe<Scalars['String']>;
    refId?: InputMaybe<Scalars['String']>;
    resourceId?: InputMaybe<Scalars['String']>;
    salesforceId?: InputMaybe<Scalars['String']>;
    scheduleStrategy?: InputMaybe<ScheduleStrategy>;
    startDate?: InputMaybe<Scalars['DateTime']>;
    subscriptionEntitlements?: InputMaybe<Array<SubscriptionEntitlementInput>>;
    subscriptionId?: InputMaybe<Scalars['String']>;
    /** Indicates the behavior of the subscription when the trial is expired. */
    trialEndBehavior?: InputMaybe<TrialEndBehavior>;
    unitQuantity?: InputMaybe<Scalars['Float']>;
};
/** The reason the billing event was created. */
export declare enum SubscriptionInvoiceBillingReason {
    /** A subscription advanced into a new billing cycle. */
    BillingCycle = "BILLING_CYCLE",
    /** An invoice was created manually. */
    Manual = "MANUAL",
    /** A subscription passed the minimum invoice amount */
    MinimumInvoiceAmountExceeded = "MINIMUM_INVOICE_AMOUNT_EXCEEDED",
    /** An invoice was created for another reason. */
    Other = "OTHER",
    /** A subscription was created. */
    SubscriptionCreation = "SUBSCRIPTION_CREATION",
    /** A subscription was updated. */
    SubscriptionUpdate = "SUBSCRIPTION_UPDATE"
}
/** SubscriptionInvoice status */
export declare enum SubscriptionInvoiceStatus {
    Canceled = "CANCELED",
    Open = "OPEN",
    Paid = "PAID"
}
export declare type SubscriptionMigrationInput = {
    environmentId?: InputMaybe<Scalars['UUID']>;
    subscriptionId: Scalars['String'];
    subscriptionMigrationTime?: InputMaybe<SubscriptionMigrationTime>;
};
export declare type SubscriptionMigrationTaskFilter = {
    and?: InputMaybe<Array<SubscriptionMigrationTaskFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    environmentId?: InputMaybe<StringFieldComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<SubscriptionMigrationTaskFilter>>;
    status?: InputMaybe<TaskStatusFilterComparison>;
    taskType?: InputMaybe<TaskTypeFilterComparison>;
};
export declare type SubscriptionMigrationTaskSort = {
    direction: SortDirection;
    field: SubscriptionMigrationTaskSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum SubscriptionMigrationTaskSortFields {
    CreatedAt = "createdAt",
    EnvironmentId = "environmentId",
    Id = "id",
    Status = "status",
    TaskType = "taskType"
}
/** Set non immediate cancellation time (atm supported only for stripe integration) */
export declare enum SubscriptionMigrationTime {
    EndOfBillingPeriod = "END_OF_BILLING_PERIOD",
    Immediate = "IMMEDIATE"
}
/** Subscription minimum spend input */
export declare type SubscriptionMinimumSpendValueInput = {
    /** The subscription minimum spend */
    minimum?: InputMaybe<MoneyInputDto>;
};
export declare type SubscriptionPriceFilter = {
    and?: InputMaybe<Array<SubscriptionPriceFilter>>;
    billingModel?: InputMaybe<BillingModelFilterComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    featureId?: InputMaybe<StringFieldComparison>;
    hasSoftLimit?: InputMaybe<BooleanFieldComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<SubscriptionPriceFilter>>;
    price?: InputMaybe<SubscriptionPriceFilterPriceFilter>;
    subscription?: InputMaybe<SubscriptionPriceFilterCustomerSubscriptionFilter>;
    updatedAt?: InputMaybe<DateFieldComparison>;
    usageLimit?: InputMaybe<NumberFieldComparison>;
};
export declare type SubscriptionPriceFilterCustomerSubscriptionFilter = {
    and?: InputMaybe<Array<SubscriptionPriceFilterCustomerSubscriptionFilter>>;
    billingCycleAnchor?: InputMaybe<DateFieldComparison>;
    billingId?: InputMaybe<StringFieldComparison>;
    cancelReason?: InputMaybe<SubscriptionCancelReasonFilterComparison>;
    cancellationDate?: InputMaybe<DateFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    crmId?: InputMaybe<StringFieldComparison>;
    crmLinkUrl?: InputMaybe<StringFieldComparison>;
    currentBillingPeriodEnd?: InputMaybe<DateFieldComparison>;
    currentBillingPeriodStart?: InputMaybe<DateFieldComparison>;
    customerId?: InputMaybe<UuidFilterComparison>;
    effectiveEndDate?: InputMaybe<DateFieldComparison>;
    endDate?: InputMaybe<DateFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    oldBillingId?: InputMaybe<StringFieldComparison>;
    or?: InputMaybe<Array<SubscriptionPriceFilterCustomerSubscriptionFilter>>;
    payingCustomerId?: InputMaybe<UuidFilterComparison>;
    paymentCollection?: InputMaybe<PaymentCollectionFilterComparison>;
    pricingType?: InputMaybe<PricingTypeFilterComparison>;
    refId?: InputMaybe<StringFieldComparison>;
    resourceId?: InputMaybe<UuidFilterComparison>;
    salesforceId?: InputMaybe<StringFieldComparison>;
    startDate?: InputMaybe<DateFieldComparison>;
    status?: InputMaybe<SubscriptionStatusFilterComparison>;
    subscriptionId?: InputMaybe<StringFieldComparison>;
    trialEndDate?: InputMaybe<DateFieldComparison>;
};
export declare type SubscriptionPriceFilterPriceFilter = {
    and?: InputMaybe<Array<SubscriptionPriceFilterPriceFilter>>;
    billingCadence?: InputMaybe<BillingCadenceFilterComparison>;
    billingId?: InputMaybe<StringFieldComparison>;
    billingModel?: InputMaybe<BillingModelFilterComparison>;
    billingPeriod?: InputMaybe<BillingPeriodFilterComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<SubscriptionPriceFilterPriceFilter>>;
    tiersMode?: InputMaybe<TiersModeFilterComparison>;
};
export declare type SubscriptionPriceSort = {
    direction: SortDirection;
    field: SubscriptionPriceSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum SubscriptionPriceSortFields {
    BillingModel = "billingModel",
    CreatedAt = "createdAt",
    FeatureId = "featureId",
    HasSoftLimit = "hasSoftLimit",
    Id = "id",
    UpdatedAt = "updatedAt",
    UsageLimit = "usageLimit"
}
/** Proration behavior for subscription billing */
export declare enum SubscriptionProrationBehavior {
    /** Create proration invoice items for changes in the subscription */
    CreateProrations = "CREATE_PRORATIONS",
    /** Invoice immediately for changes in the subscription without proration */
    InvoiceImmediately = "INVOICE_IMMEDIATELY",
    /** No proration and no invoice for changes in the subscription */
    None = "NONE"
}
export declare type SubscriptionQueryFilter = {
    and?: InputMaybe<Array<SubscriptionQueryFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    customerId?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<SubscriptionQueryFilter>>;
    productId?: InputMaybe<StringFieldComparison>;
    resourceId?: InputMaybe<StringFieldComparison>;
    startDate?: InputMaybe<DateFieldComparison>;
    status?: InputMaybe<SubscriptionStatusFilterComparison>;
};
export declare type SubscriptionQuerySort = {
    direction: SortDirection;
    field: SubscriptionQuerySortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum SubscriptionQuerySortFields {
    CreatedAt = "createdAt",
    CustomerId = "customerId",
    EnvironmentId = "environmentId",
    ProductId = "productId",
    ResourceId = "resourceId",
    StartDate = "startDate",
    Status = "status"
}
/** Subscription scheduled schedule status */
export declare enum SubscriptionScheduleStatus {
    Canceled = "Canceled",
    Done = "Done",
    Failed = "Failed",
    PendingPayment = "PendingPayment",
    Scheduled = "Scheduled"
}
/** Subscription scheduled schedule type */
export declare enum SubscriptionScheduleType {
    /** Additional metadata change */
    AdditionalMetaData = "AdditionalMetaData",
    /** Addon change */
    Addon = "Addon",
    /** Billing info metadata change */
    BillingInfoMetadata = "BillingInfoMetadata",
    /** Billing period change */
    BillingPeriod = "BillingPeriod",
    /** Coupon change */
    Coupon = "Coupon",
    /** Downgrade change */
    Downgrade = "Downgrade",
    /** Migrate to latest */
    MigrateToLatest = "MigrateToLatest",
    /** Plan change */
    Plan = "Plan",
    /** Custom price change */
    PriceOverride = "PriceOverride",
    /** Unit amount change */
    UnitAmount = "UnitAmount"
}
/** Setup for the start of the subscription */
export declare enum SubscriptionStartSetup {
    /** Start with a free plan */
    FreePlan = "FREE_PLAN",
    /** Select a plan */
    PlanSelection = "PLAN_SELECTION",
    /** Start with a trial period */
    TrialPeriod = "TRIAL_PERIOD"
}
/** Subscription status */
export declare enum SubscriptionStatus {
    Active = "ACTIVE",
    Canceled = "CANCELED",
    Expired = "EXPIRED",
    InTrial = "IN_TRIAL",
    NotStarted = "NOT_STARTED",
    PaymentPending = "PAYMENT_PENDING"
}
export declare type SubscriptionStatusFilterComparison = {
    eq?: InputMaybe<SubscriptionStatus>;
    gt?: InputMaybe<SubscriptionStatus>;
    gte?: InputMaybe<SubscriptionStatus>;
    iLike?: InputMaybe<SubscriptionStatus>;
    in?: InputMaybe<Array<SubscriptionStatus>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<SubscriptionStatus>;
    lt?: InputMaybe<SubscriptionStatus>;
    lte?: InputMaybe<SubscriptionStatus>;
    neq?: InputMaybe<SubscriptionStatus>;
    notILike?: InputMaybe<SubscriptionStatus>;
    notIn?: InputMaybe<Array<SubscriptionStatus>>;
    notLike?: InputMaybe<SubscriptionStatus>;
};
export declare type SubscriptionUpdateScheduleCancellationInput = {
    environmentId?: InputMaybe<Scalars['UUID']>;
    status?: InputMaybe<SubscriptionScheduleStatus>;
    subscriptionId: Scalars['String'];
};
/** Decide whether feature usage will be reset upon creation on new subscription */
export declare enum SubscriptionUpdateUsageCutoffBehavior {
    /** Always reset */
    AlwaysReset = "ALWAYS_RESET",
    /** Billing period changed */
    BillingPeriodChange = "BILLING_PERIOD_CHANGE",
    /** Never reset */
    NeverReset = "NEVER_RESET"
}
/** Input for usage reset cutoff rule */
export declare type SubscriptionUpdateUsageResetCutoffRuleInput = {
    /** Behavior of the usage reset cutoff rule */
    behavior: SubscriptionUpdateUsageCutoffBehavior;
};
/** Status of the integration sync */
export declare enum SyncStatus {
    /** Error sync status */
    Error = "ERROR",
    /** No sync required status */
    NoSyncRequired = "NO_SYNC_REQUIRED",
    /** Pending sync status */
    Pending = "PENDING",
    /** Successful sync status */
    Success = "SUCCESS"
}
/** Input for triggering a sync of tax rates from the billing provider. */
export declare type SyncTaxRatesInput = {
    /** The ID of the environment for which tax rates should be synced. */
    environmentId?: InputMaybe<Scalars['UUID']>;
};
/** The status of the task */
export declare enum TaskStatus {
    /** The task is canceled */
    Canceled = "CANCELED",
    /** The task is completed */
    Completed = "COMPLETED",
    /** The task is failed */
    Failed = "FAILED",
    /** The task is in progress */
    InProgress = "IN_PROGRESS",
    /** The task is partially failed */
    PartiallyFailed = "PARTIALLY_FAILED",
    /** The task is pending */
    Pending = "PENDING"
}
export declare type TaskStatusFilterComparison = {
    eq?: InputMaybe<TaskStatus>;
    gt?: InputMaybe<TaskStatus>;
    gte?: InputMaybe<TaskStatus>;
    iLike?: InputMaybe<TaskStatus>;
    in?: InputMaybe<Array<TaskStatus>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<TaskStatus>;
    lt?: InputMaybe<TaskStatus>;
    lte?: InputMaybe<TaskStatus>;
    neq?: InputMaybe<TaskStatus>;
    notILike?: InputMaybe<TaskStatus>;
    notIn?: InputMaybe<Array<TaskStatus>>;
    notLike?: InputMaybe<TaskStatus>;
};
/** The type of the task */
export declare enum TaskType {
    /** The task is an import of product catalog from integration */
    ImportIntegrationCatalog = "IMPORT_INTEGRATION_CATALOG",
    /** The task is an import of customers from integration */
    ImportIntegrationCustomers = "IMPORT_INTEGRATION_CUSTOMERS",
    /** The task is an import of subscriptions in bulk */
    ImportSubscriptionsBulk = "IMPORT_SUBSCRIPTIONS_BULK",
    /** The task is a batch recalculation of entitlements */
    RecalculateBatchEntitlements = "RECALCULATE_BATCH_ENTITLEMENTS",
    /** The task is a recalculation of entitlements */
    RecalculateEntitlements = "RECALCULATE_ENTITLEMENTS",
    /** The task is a resync integration */
    ResyncIntegration = "RESYNC_INTEGRATION",
    /** The task is a subscription migration v1 */
    SubscriptionMigration = "SUBSCRIPTION_MIGRATION",
    /** The task is a subscription migration v2 */
    SubscriptionMigrationV2 = "SUBSCRIPTION_MIGRATION_V2"
}
export declare type TaskTypeFilterComparison = {
    eq?: InputMaybe<TaskType>;
    gt?: InputMaybe<TaskType>;
    gte?: InputMaybe<TaskType>;
    iLike?: InputMaybe<TaskType>;
    in?: InputMaybe<Array<TaskType>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<TaskType>;
    lt?: InputMaybe<TaskType>;
    lte?: InputMaybe<TaskType>;
    neq?: InputMaybe<TaskType>;
    notILike?: InputMaybe<TaskType>;
    notIn?: InputMaybe<Array<TaskType>>;
    notLike?: InputMaybe<TaskType>;
};
/** Information on the tax exemption. */
export declare type TaxExempt = {
    /** The type of tax exemption identifier, such as VAT. */
    type: Scalars['String'];
    /** The actual tax identifier value */
    value: Scalars['String'];
};
/** TestHookInput object */
export declare type TestHookInput = {
    /** The endpoint URL for the webhook */
    endpointUrl: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId: Scalars['String'];
    /** The event log type to test */
    hookEventType: EventLogType;
};
/** Trigger workflow with test event input */
export declare type TestWorkflowInput = {
    /** Workflow trigger endpoint */
    endpointUrl: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The event type to trigger the workflow on */
    hookEventType: EventLogType;
};
/** Tiers mode */
export declare enum TiersMode {
    /** Tiered */
    Graduated = "GRADUATED",
    /** Volume */
    Volume = "VOLUME"
}
export declare type TiersModeFilterComparison = {
    eq?: InputMaybe<TiersMode>;
    gt?: InputMaybe<TiersMode>;
    gte?: InputMaybe<TiersMode>;
    iLike?: InputMaybe<TiersMode>;
    in?: InputMaybe<Array<TiersMode>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<TiersMode>;
    lt?: InputMaybe<TiersMode>;
    lte?: InputMaybe<TiersMode>;
    neq?: InputMaybe<TiersMode>;
    notILike?: InputMaybe<TiersMode>;
    notIn?: InputMaybe<Array<TiersMode>>;
    notLike?: InputMaybe<TiersMode>;
};
export declare type TransferSubscriptionInput = {
    customerId: Scalars['String'];
    destinationResourceId: Scalars['String'];
    sourceResourceId: Scalars['String'];
};
/** The input for transferring a subscription to a resource */
export declare type TransferSubscriptionToResourceInput = {
    /** The resource ID to transfer the subscription to */
    destinationResourceId?: InputMaybe<Scalars['String']>;
    /** The environment ID of the subscription to transfer */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The ID of the subscription to transfer */
    subscriptionId: Scalars['String'];
};
/** Indicates the behavior of the subscription when the trial is expired. */
export declare enum TrialEndBehavior {
    /** cancel the subscription when the trial is expired */
    CancelSubscription = "CANCEL_SUBSCRIPTION",
    /** convert the trial subscription to a paid subscription */
    ConvertToPaid = "CONVERT_TO_PAID"
}
export declare type TrialOverrideConfigurationInput = {
    isTrial: Scalars['Boolean'];
    /** Indicates the behavior of the subscription when the trial is expired. */
    trialEndBehavior?: InputMaybe<TrialEndBehavior>;
    trialEndDate?: InputMaybe<Scalars['DateTime']>;
};
/** day or month. */
export declare enum TrialPeriodUnits {
    Day = "DAY",
    Month = "MONTH"
}
/** Input for triggering the subscription billing month ends soon webhook */
export declare type TriggerSubscriptionBillingMonthEndsSoonWebhookInput = {
    /** The subscription reference id to trigger the webhook for */
    subscriptionId: Scalars['String'];
};
/** Trigger a subscription migration */
export declare type TriggerSubscriptionMigrationInput = {
    /** The unique identifier for the environment */
    environmentId: Scalars['String'];
    /** The unique identifier for the entity */
    refId: Scalars['String'];
    /** The version number of the plan to migrate */
    versionNumber: Scalars['Float'];
};
/** Input for triggering usage sync */
export declare type TriggerSubscriptionUsageSyncInput = {
    /** The customer id to trigger usage sync for */
    customerId: Scalars['String'];
    /** The environment id to trigger usage sync for */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The resource id to trigger usage sync for */
    resourceId?: InputMaybe<Scalars['String']>;
};
/** Trigger workflow input */
export declare type TriggerWorkflowInput = {
    /** If set to true, trigger the test workflow, otherwise trigger live workflow */
    isTest?: InputMaybe<Scalars['Boolean']>;
    /** Workflow payload */
    payload?: InputMaybe<Scalars['JSON']>;
    /** Trigger id */
    triggerId: Scalars['String'];
};
/** Input for setting typography styles for widgets. */
export declare type TypographyConfigurationInput = {
    /** Style applied to general text content. */
    body?: InputMaybe<FontVariantInput>;
    /** Font family to be used throughout the widget. */
    fontFamily?: InputMaybe<Scalars['String']>;
    /** Style applied to top-level headings. */
    h1?: InputMaybe<FontVariantInput>;
    /** Style applied to second-level headings. */
    h2?: InputMaybe<FontVariantInput>;
    /** Style applied to third-level headings. */
    h3?: InputMaybe<FontVariantInput>;
};
export declare type UuidFilterComparison = {
    eq?: InputMaybe<Scalars['UUID']>;
    gt?: InputMaybe<Scalars['UUID']>;
    gte?: InputMaybe<Scalars['UUID']>;
    iLike?: InputMaybe<Scalars['UUID']>;
    in?: InputMaybe<Array<Scalars['UUID']>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<Scalars['UUID']>;
    lt?: InputMaybe<Scalars['UUID']>;
    lte?: InputMaybe<Scalars['UUID']>;
    neq?: InputMaybe<Scalars['UUID']>;
    notILike?: InputMaybe<Scalars['UUID']>;
    notIn?: InputMaybe<Array<Scalars['UUID']>>;
    notLike?: InputMaybe<Scalars['UUID']>;
};
/** Input for unarchiving a feature group */
export declare type UnArchiveFeatureGroupInput = {
    /** The unique identifier for the environment */
    environmentId: Scalars['UUID'];
    /** The feature group id */
    featureGroupId: Scalars['String'];
};
/** Input for un-archiving a feature */
export declare type UnArchiveFeatureInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Unique identifier for the entity */
    id: Scalars['String'];
};
/** Input for un-archiving a plan */
export declare type UnArchivePlanInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Plan ID to unarchive */
    id: Scalars['String'];
};
/** Unarchive a customer */
export declare type UnarchiveCustomerInput = {
    /** Customer slug */
    customerId: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
};
/** Input for unarchiving an environment */
export declare type UnarchiveEnvironmentInput = {
    /** Unique identifier for the entity */
    id?: InputMaybe<Scalars['String']>;
    /** A unique identifier for the environment */
    slug?: InputMaybe<Scalars['String']>;
};
/** Input for unit transformation to be applied to the reported usage */
export declare type UnitTransformationInput = {
    /** Divide usage by this number */
    divide: Scalars['Int'];
    /** Singular feature units after the transformation */
    featureUnits?: InputMaybe<Scalars['String']>;
    /** Plural feature units after the transformation */
    featureUnitsPlural?: InputMaybe<Scalars['String']>;
    /** After division, either round the result up or down */
    round?: InputMaybe<UnitTransformationRound>;
};
/** Unit transformation round type */
export declare enum UnitTransformationRound {
    /** Apply round down after transformation */
    Down = "DOWN",
    /** Apply round up after transformation */
    Up = "UP"
}
/** Units input object (singular and plural) */
export declare type UnitsInput = {
    /** Plural form of the unit */
    plural: Scalars['String'];
    /** Singular form of the unit */
    singular: Scalars['String'];
};
/** Unlink feature group from package entitlements input */
export declare type UnlinkFeatureGroupFromPackageInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The group id to unlink */
    featureGroupId: Scalars['UUID'];
    /** The unique identifier of the entitlement package */
    packageId: Scalars['UUID'];
};
/** Unlink promotional feature group input */
export declare type UnlinkPromotionalEntitlementsGroupInput = {
    /** The unique identifier of the entitlement customer */
    customerId: Scalars['String'];
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Feature group ID to unlink from promotional entitlements */
    featureGroupId: Scalars['UUID'];
};
/** Input type for updating an account */
export declare type UpdateAccountInput = {
    /** The method of adding new members to this account */
    accessMethod?: InputMaybe<AccountAccessMethod>;
    /** Email domain to be used for sso and authorized domain configuration */
    accountEmailDomain?: InputMaybe<Scalars['String']>;
    /** Default SSO roles for the account */
    defaultSSORoles?: InputMaybe<DefaultSsoRolesInput>;
    /** The display name of the account */
    displayName: Scalars['String'];
    /** The billing anchor for the subscription, e.g. "START_OF_THE_MONTH" */
    subscriptionBillingAnchor?: InputMaybe<BillingAnchor>;
    /** The proration behavior for the subscription, e.g. "CREATE_PRORATIONS" */
    subscriptionProrationBehavior?: InputMaybe<ProrationBehavior>;
    /** The timezone of the account, e.g. "America/New_York" */
    timezone?: InputMaybe<Scalars['String']>;
};
/** Update a coupon input */
export declare type UpdateCouponInput = {
    /** Metadata associated with the entity */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** Description of the coupon */
    description?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Name of the coupon */
    name?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the entity */
    refId: Scalars['String'];
};
/** Input for updating a credit grant */
export declare type UpdateCreditGrantInput = {
    /** Metadata associated with the entity */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** The comment for the credit grant */
    comment?: InputMaybe<Scalars['String']>;
    /** The display name of the credit grant */
    displayName?: InputMaybe<Scalars['String']>;
    /** The effective date of the credit grant */
    effectiveAt?: InputMaybe<Scalars['DateTime']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The expiration date of the credit grant */
    expireAt?: InputMaybe<Scalars['DateTime']>;
    /** The unique identifier for the credit grant */
    id: Scalars['UUID'];
    /** The priority of the credit grant */
    priority?: InputMaybe<Scalars['Float']>;
};
/** Input for updating a custom currency */
export declare type UpdateCustomCurrencyInput = {
    /** Metadata associated with the entity */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** The unique identifier for the custom currency */
    currencyId: Scalars['String'];
    /** Description of the currency */
    description?: InputMaybe<Scalars['String']>;
    /** The name of the custom currency */
    displayName?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The symbol of the custom currency */
    symbol?: InputMaybe<Scalars['String']>;
    /** Units for the currency (singular and plural) */
    units?: InputMaybe<UnitsInput>;
};
/** Update customer information */
export declare type UpdateCustomerInput = {
    /** Additional metadata update */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** The AWS Marketplace integration id */
    awsMarketplaceCustomerId?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the entity in the billing provider */
    billingId?: InputMaybe<Scalars['String']>;
    /** Billing information update */
    billingInformation?: InputMaybe<CustomerBillingInfo>;
    /** Update a customer level coupon */
    couponRefId?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the customer in Hubspot integration */
    crmId?: InputMaybe<Scalars['String']>;
    /** Customer slug */
    customerId?: InputMaybe<Scalars['String']>;
    /** The email of the customer */
    email?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The name of the customer */
    name?: InputMaybe<Scalars['String']>;
    /** Customer slug */
    refId?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the customer in Salesforce integration */
    salesforceId?: InputMaybe<Scalars['String']>;
    /** Should wait for sync to complete before returning a response */
    shouldWaitSync?: InputMaybe<Scalars['Boolean']>;
};
/** Input parameters for updating an existing experiment */
export declare type UpdateExperimentInput = {
    /** Name for the control group */
    controlGroupName?: InputMaybe<Scalars['String']>;
    /** Description of the experiements */
    description?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Name of the experiment */
    name?: InputMaybe<Scalars['String']>;
    /** Internal identifier for the product experiment is associated with */
    productId?: InputMaybe<Scalars['String']>;
    /** Product settings for the variant group */
    productSettings?: InputMaybe<ProductSettingsInput>;
    /** The unique identifier for the experiment */
    refId: Scalars['String'];
    /** Name for the variant group */
    variantGroupName?: InputMaybe<Scalars['String']>;
    /** Percentage of users in the variant group */
    variantPercentage?: InputMaybe<Scalars['Float']>;
};
/** Input for updating a feature */
export declare type UpdateFeatureInput = {
    /** The additional metadata for the feature */
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    /** The description for the feature */
    description?: InputMaybe<Scalars['String']>;
    /** The display name for the feature */
    displayName?: InputMaybe<Scalars['String']>;
    /** The configuration data for the feature */
    enumConfiguration?: InputMaybe<Array<EnumConfigurationEntityInput>>;
    /** The unique identifier for the environment */
    environmentId: Scalars['UUID'];
    /** The units for the feature */
    featureUnits?: InputMaybe<Scalars['String']>;
    /** The plural units for the feature */
    featureUnitsPlural?: InputMaybe<Scalars['String']>;
    /** Input for creating a meter */
    meter?: InputMaybe<CreateMeter>;
    /** The unique identifier for the feature */
    refId: Scalars['String'];
    /** Unit transformation to be applied to the reported usage */
    unitTransformation?: InputMaybe<UnitTransformationInput>;
};
export declare type UpdateHook = {
    /** A JSON containing the configuration for each event log type */
    configuration?: InputMaybe<Scalars['JSON']>;
    /** Timestamp of when the record was created */
    createdAt?: InputMaybe<Scalars['DateTime']>;
    /** Webhook description */
    description?: InputMaybe<Scalars['String']>;
    /** The Webhook endpoint URL */
    endpoint?: InputMaybe<Scalars['String']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The event types that the webhook will be triggered on */
    eventLogTypes?: InputMaybe<Array<EventLogType>>;
    /** Unique identifier for the entity */
    id?: InputMaybe<Scalars['UUID']>;
    /** Secret key for the webhook */
    secretKey?: InputMaybe<Scalars['String']>;
    /** The status of the webhook */
    status?: InputMaybe<HookStatus>;
};
/** Update integration input */
export declare type UpdateIntegrationInput = {
    /** Auth0 integration configuration */
    auth0Credentials?: InputMaybe<Auth0CredentialsInput>;
    /** The reference ID for the integration */
    integrationId?: InputMaybe<Scalars['String']>;
    /** Whether the integration is the default integration */
    isDefault?: InputMaybe<Scalars['Boolean']>;
    /** OpenFGA integration configuration */
    openFGACredentials?: InputMaybe<OpenFgaCredentialsInput>;
    /** Salesforce integration configuration */
    salesforceCredentials?: InputMaybe<SalesforceCredentialsInput>;
    /** Stripe integration configuration */
    stripeCredentials?: InputMaybe<UpdateStripeCredentialsInput>;
    /** The vendor identifier of integration */
    vendorIdentifier: VendorIdentifier;
    /** Zuora integration configuration */
    zuoraCredentials?: InputMaybe<ZuoraCredentialsInput>;
};
export declare type UpdateOneEnvironmentInput = {
    /** The id of the record to update */
    id: Scalars['UUID'];
    /** The update to apply. */
    update: EnvironmentInput;
};
export declare type UpdateOneHookInput = {
    /** The id of the record to update */
    id: Scalars['UUID'];
    /** The update to apply. */
    update: UpdateHook;
};
export declare type UpdateOneIntegrationInput = {
    /** The id of the record to update */
    id: Scalars['UUID'];
    /** The update to apply. */
    update: UpdateIntegrationInput;
};
export declare type UpdateOnePackageEntitlementInput = {
    /** The id of the record to update */
    id: Scalars['UUID'];
    /** The update to apply. */
    update: PackageEntitlementUpdateInput;
};
export declare type UpdateOneProductInput = {
    /** The id of the record to update */
    id: Scalars['UUID'];
    /** The update to apply. */
    update: ProductUpdateInput;
};
export declare type UpdateOnePromotionalEntitlementInput = {
    /** The id of the record to update */
    id: Scalars['UUID'];
    /** The update to apply. */
    update: PromotionalEntitlementUpdateInput;
};
/** Update package entitlement order input */
export declare type UpdatePackageEntitlementOrderInput = {
    /** Entitlements to update */
    entitlements: Array<UpdatePackageEntitlementOrderItemInput>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The unique identifier of the entitlement package */
    packageId: Scalars['String'];
};
/** Update package entitlement order item input */
export declare type UpdatePackageEntitlementOrderItemInput = {
    /** Unique identifier for the entity */
    id: Scalars['UUID'];
    /** The order of the entitlement in the entitlement list */
    order?: InputMaybe<Scalars['Float']>;
};
/** Input configuration for updating Stripe integration */
export declare type UpdateStripeCredentialsInput = {
    /** Whether tax is enabled for the Stripe account */
    isTaxEnabled?: InputMaybe<Scalars['Boolean']>;
};
/** Update subscription entitlement input */
export declare type UpdateSubscriptionEntitlementInput = {
    /** The unique identifier of the entitlement feature */
    featureId?: InputMaybe<Scalars['String']>;
    /** Whether the entitlement has a soft limit */
    hasSoftLimit?: InputMaybe<Scalars['Boolean']>;
    /** Whether the entitlement has an unlimited usage */
    hasUnlimitedUsage?: InputMaybe<Scalars['Boolean']>;
    /** Unique identifier for the entity */
    id?: InputMaybe<Scalars['String']>;
    /** The monthly reset period configuration of the entitlement, defined when reset period is monthly */
    monthlyResetPeriodConfiguration?: InputMaybe<MonthlyResetPeriodConfigInput>;
    /** The reset period of the entitlement */
    resetPeriod?: InputMaybe<EntitlementResetPeriod>;
    /** The usage limit of the entitlement */
    usageLimit?: InputMaybe<Scalars['Float']>;
    /** The weekly reset period configuration of the entitlement, defined when reset period is weekly */
    weeklyResetPeriodConfiguration?: InputMaybe<WeeklyResetPeriodConfigInput>;
    /** The yearly reset period configuration of the entitlement, defined when reset period is yearly */
    yearlyResetPeriodConfiguration?: InputMaybe<YearlyResetPeriodConfigInput>;
};
export declare type UpdateSubscriptionInput = {
    additionalMetaData?: InputMaybe<Scalars['JSON']>;
    addons?: InputMaybe<Array<SubscriptionAddonInput>>;
    /** Coupon input */
    appliedCoupon?: InputMaybe<SubscriptionCouponInput>;
    awaitPaymentConfirmation?: InputMaybe<Scalars['Boolean']>;
    billableFeatures?: InputMaybe<Array<BillableFeatureInput>>;
    billingInformation?: InputMaybe<SubscriptionBillingInfo>;
    billingPeriod?: InputMaybe<BillingPeriod>;
    /** Budget configuration */
    budget?: InputMaybe<BudgetConfigurationInput>;
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** The minimum spend configuration */
    minimumSpend?: InputMaybe<SubscriptionMinimumSpendValueInput>;
    /** Override the price of the subscription */
    priceOverrides?: InputMaybe<Array<PriceOverrideInput>>;
    promotionCode?: InputMaybe<Scalars['String']>;
    refId?: InputMaybe<Scalars['String']>;
    scheduleStrategy?: InputMaybe<ScheduleStrategy>;
    subscriptionEntitlements?: InputMaybe<Array<UpdateSubscriptionEntitlementInput>>;
    subscriptionId?: InputMaybe<Scalars['String']>;
    trialEndDate?: InputMaybe<Scalars['DateTime']>;
    unitQuantity?: InputMaybe<Scalars['Float']>;
};
/** Update the users information */
export declare type UpdateUserInput = {
    /** User selected department */
    department?: InputMaybe<Department>;
    /** User first and last name */
    name: Scalars['String'];
};
/** Input parameters for reporting usage events */
export declare type UsageEventReportInput = {
    /** Customer id */
    customerId: Scalars['String'];
    /** Dimensions to include in the events fields */
    dimensions?: InputMaybe<Scalars['JSON']>;
    /** Name of the event */
    eventName: Scalars['String'];
    /** Idempotency key */
    idempotencyKey: Scalars['String'];
    /** Resource id */
    resourceId?: InputMaybe<Scalars['String']>;
    /** Timestamp */
    timestamp?: InputMaybe<Scalars['DateTime']>;
};
/** Input for usage events */
export declare type UsageEventsInput = {
    /** Customer id filter */
    customerId?: InputMaybe<Scalars['String']>;
    /** Environment id filter */
    environmentId: Scalars['UUID'];
    /** List of event filters */
    filters?: InputMaybe<Array<MeterFilterDefinitionInput>>;
};
/** Input parameters for reporting usage events */
export declare type UsageEventsReportInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** A list of usage events to report */
    usageEvents: Array<UsageEventReportInput>;
};
/** Input parameters for retrieving usage history */
export declare type UsageHistoryInput = {
    /** Reference identifier for the customer */
    customerRefId: Scalars['String'];
    /** The end date of the range */
    endDate?: InputMaybe<Scalars['DateTime']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Reference identifier for the feature */
    featureRefId: Scalars['String'];
    /** Criteria by which to group the usage history */
    groupBy?: InputMaybe<Array<Scalars['String']>>;
    /** Monthly reset period configuration */
    monthlyResetPeriodConfiguration?: InputMaybe<MonthlyResetPeriodConfigInput>;
    /** Reset period */
    resetPeriod?: InputMaybe<EntitlementResetPeriod>;
    /** Reference identifier for the resource */
    resourceRefId?: InputMaybe<Scalars['String']>;
    /** The start date of the range */
    startDate: Scalars['DateTime'];
    /** Weekly reset period configuration */
    weeklyResetPeriodConfiguration?: InputMaybe<WeeklyResetPeriodConfigInput>;
    /** Yearly reset period configuration */
    yearlyResetPeriodConfiguration?: InputMaybe<YearlyResetPeriodConfigInput>;
};
/** Input parameters for retrieving usage history */
export declare type UsageHistoryV2Input = {
    /** Customer id */
    customerId: Scalars['String'];
    /** The end date of the range */
    endDate?: InputMaybe<Scalars['DateTime']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Feature id */
    featureId: Scalars['String'];
    /** Criteria by which to group the usage history */
    groupBy?: InputMaybe<Array<Scalars['String']>>;
    /** Resource id */
    resourceId?: InputMaybe<Scalars['String']>;
    /** The start date of the range */
    startDate: Scalars['DateTime'];
};
/** Type of marker for a usage history point */
export declare enum UsageMarkerType {
    /** Usage was reset due to reaching the end of a usage period */
    PeriodicReset = "PERIODIC_RESET",
    /** Usage was reset due to a subscription change */
    SubscriptionChangeReset = "SUBSCRIPTION_CHANGE_RESET"
}
/** Input for creating a usage measurement */
export declare type UsageMeasurementCreateInput = {
    /** Timestamp of when the record was created */
    createdAt?: InputMaybe<Scalars['DateTime']>;
    /** Customer id */
    customerId: Scalars['String'];
    /** Additional dimensions for the usage report */
    dimensions?: InputMaybe<Scalars['JSON']>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Feature id */
    featureId: Scalars['String'];
    /** Resource id */
    resourceId?: InputMaybe<Scalars['String']>;
    /** The method by which the usage value should be updated */
    updateBehavior?: InputMaybe<UsageUpdateBehavior>;
    /** The value to report for usage */
    value: Scalars['Float'];
};
export declare type UsageMeasurementFilter = {
    and?: InputMaybe<Array<UsageMeasurementFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    customer?: InputMaybe<UsageMeasurementFilterCustomerFilter>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    feature?: InputMaybe<UsageMeasurementFilterFeatureFilter>;
    id?: InputMaybe<UuidFilterComparison>;
    or?: InputMaybe<Array<UsageMeasurementFilter>>;
};
export declare type UsageMeasurementFilterCustomerFilter = {
    and?: InputMaybe<Array<UsageMeasurementFilterCustomerFilter>>;
    billingId?: InputMaybe<StringFieldComparison>;
    createdAt?: InputMaybe<DateFieldComparison>;
    crmHubspotCompanyId?: InputMaybe<StringFieldComparison>;
    crmHubspotCompanyUrl?: InputMaybe<StringFieldComparison>;
    crmId?: InputMaybe<StringFieldComparison>;
    customerId?: InputMaybe<StringFieldComparison>;
    deletedAt?: InputMaybe<DateFieldComparison>;
    email?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    name?: InputMaybe<StringFieldComparison>;
    or?: InputMaybe<Array<UsageMeasurementFilterCustomerFilter>>;
    refId?: InputMaybe<StringFieldComparison>;
    salesforceId?: InputMaybe<StringFieldComparison>;
    searchQuery?: InputMaybe<CustomerSearchQueryFilterComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
export declare type UsageMeasurementFilterFeatureFilter = {
    and?: InputMaybe<Array<UsageMeasurementFilterFeatureFilter>>;
    createdAt?: InputMaybe<DateFieldComparison>;
    description?: InputMaybe<StringFieldComparison>;
    displayName?: InputMaybe<StringFieldComparison>;
    environmentId?: InputMaybe<UuidFilterComparison>;
    featureStatus?: InputMaybe<FeatureStatusFilterComparison>;
    featureType?: InputMaybe<FeatureTypeFilterComparison>;
    id?: InputMaybe<UuidFilterComparison>;
    meterType?: InputMaybe<MeterTypeFilterComparison>;
    or?: InputMaybe<Array<UsageMeasurementFilterFeatureFilter>>;
    refId?: InputMaybe<StringFieldComparison>;
    updatedAt?: InputMaybe<DateFieldComparison>;
};
export declare type UsageMeasurementSort = {
    direction: SortDirection;
    field: UsageMeasurementSortFields;
    nulls?: InputMaybe<SortNulls>;
};
export declare enum UsageMeasurementSortFields {
    CreatedAt = "createdAt",
    EnvironmentId = "environmentId",
    Id = "id"
}
/** Update behavior */
export declare enum UsageUpdateBehavior {
    /** Delta update */
    Delta = "DELTA",
    /** Set update */
    Set = "SET"
}
/** Input type for validateMergeEnvironment query */
export declare type ValidateMergeEnvironmentInput = {
    /** Slug of the destination environment */
    destinationEnvironmentSlug: Scalars['String'];
    /** Optional configuration to customize how the validation is performed */
    mergeConfiguration?: InputMaybe<EnvironmentMergeConfigurationInput>;
    /** Slug of the source environment */
    sourceEnvironmentSlug: Scalars['String'];
};
/** A vendor identifier object */
export declare enum VendorIdentifier {
    /** Auth0 integration vendor identifier */
    Auth0 = "AUTH0",
    /** AWS Marketplace integration vendor identifier */
    AwsMarketplace = "AWS_MARKETPLACE",
    /** Google BigQuery integration vendor identifier */
    BigQuery = "BIG_QUERY",
    /** HubSpot integration vendor identifier */
    Hubspot = "HUBSPOT",
    /** OpenFGA integration vendor identifier */
    OpenFga = "OPEN_FGA",
    /** Salesforce integration vendor identifier */
    Salesforce = "SALESFORCE",
    /** Snowflake integration vendor identifier */
    Snowflake = "SNOWFLAKE",
    /** Stripe integration vendor identifier */
    Stripe = "STRIPE",
    /** Zuora integration vendor identifier */
    Zuora = "ZUORA"
}
export declare type VendorIdentifierFilterComparison = {
    eq?: InputMaybe<VendorIdentifier>;
    gt?: InputMaybe<VendorIdentifier>;
    gte?: InputMaybe<VendorIdentifier>;
    iLike?: InputMaybe<VendorIdentifier>;
    in?: InputMaybe<Array<VendorIdentifier>>;
    is?: InputMaybe<Scalars['Boolean']>;
    isNot?: InputMaybe<Scalars['Boolean']>;
    like?: InputMaybe<VendorIdentifier>;
    lt?: InputMaybe<VendorIdentifier>;
    lte?: InputMaybe<VendorIdentifier>;
    neq?: InputMaybe<VendorIdentifier>;
    notILike?: InputMaybe<VendorIdentifier>;
    notIn?: InputMaybe<Array<VendorIdentifier>>;
    notLike?: InputMaybe<VendorIdentifier>;
};
/** The type of integration */
export declare enum VendorType {
    /** Authentication integration type */
    Auth = "AUTH",
    /** Billing integration type */
    Billing = "BILLING",
    /** CRM integration type */
    Crm = "CRM",
    /** Data export integration type */
    DataExport = "DATA_EXPORT",
    /** Marketplace integration type */
    Marketplace = "MARKETPLACE"
}
/** Weekly reset period according to configuration */
export declare enum WeeklyAccordingTo {
    EveryFriday = "EveryFriday",
    /** Every Monday */
    EveryMonday = "EveryMonday",
    EverySaturday = "EverySaturday",
    /** Every Sunday */
    EverySunday = "EverySunday",
    /** Every Thursday */
    EveryThursday = "EveryThursday",
    /** Every Tuesday */
    EveryTuesday = "EveryTuesday",
    /** Every Wednesday */
    EveryWednesday = "EveryWednesday",
    /** Subscription start */
    SubscriptionStart = "SubscriptionStart"
}
/** Weekly reset period config input */
export declare type WeeklyResetPeriodConfigInput = {
    /** Weekly according to configuration */
    accordingTo: WeeklyAccordingTo;
};
/** Input for updating configuration settings across all widgets. */
export declare type WidgetConfigurationUpdateInput = {
    /** Updated configuration for the checkout widget. */
    checkoutConfiguration?: InputMaybe<CheckoutConfigurationInput>;
    /** Updated configuration for the customer portal widget. */
    customerPortalConfiguration?: InputMaybe<CustomerPortalConfigurationInput>;
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
    /** Updated configuration for the paywall widget. */
    paywallConfiguration?: InputMaybe<PaywallConfigurationInput>;
};
/** The widget type */
export declare enum WidgetType {
    Checkout = "CHECKOUT",
    CustomerPortal = "CUSTOMER_PORTAL",
    Paywall = "PAYWALL"
}
/** Workflow login input */
export declare type WorkflowsLoginInput = {
    /** The unique identifier for the environment */
    environmentId?: InputMaybe<Scalars['UUID']>;
};
/** Yearly reset period according to configuration */
export declare enum YearlyAccordingTo {
    /** Subscription start */
    SubscriptionStart = "SubscriptionStart"
}
/** Yearly reset period config input */
export declare type YearlyResetPeriodConfigInput = {
    /** Yearly according to configuration */
    accordingTo: YearlyAccordingTo;
};
/** Input configuration for Zuora integration */
export declare type ZuoraCredentialsInput = {
    /** REST Base URL of the Zuora account */
    baseUrl: Scalars['String'];
    /** Client ID for the Zuora account */
    clientId: Scalars['String'];
    /** Client secret for the Zuora account */
    clientSecret: Scalars['String'];
    /** The ID of the payment gateway to use */
    paymentGatewayId?: InputMaybe<Scalars['String']>;
    /** The ID of the payment page to use */
    paymentPageId?: InputMaybe<Scalars['String']>;
    /** Stripe publishable key for the Zuora payment page */
    stripePublishableKey?: InputMaybe<Scalars['String']>;
    /** Stripe secret key for the Zuora payment page */
    stripeSecretKey?: InputMaybe<Scalars['String']>;
};
/** The group type of the experiment */
export declare enum ExperimentGroupType {
    /** Control group of the experiment */
    Control = "CONTROL",
    /** Variant group of the experiment */
    Variant = "VARIANT"
}
export declare type CouponFragment = {
    __typename?: 'Coupon';
    id: any;
    discountValue: number;
    percentOff?: number | null;
    type: CouponType;
    additionalMetaData?: any | null;
    refId: string;
    name: string;
    description?: string | null;
    createdAt: any;
    updatedAt: any;
    billingId?: string | null;
    billingLinkUrl?: string | null;
    status: CouponStatus;
    amountsOff?: Array<{
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    }> | null;
    syncStates?: Array<{
        __typename?: 'SyncState';
        vendorIdentifier: VendorIdentifier;
        status: SyncStatus;
    }> | null;
};
export declare type PriceTierFragment = {
    __typename?: 'PriceTier';
    upTo?: number | null;
    unitPrice?: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    } | null;
    flatPrice?: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    } | null;
};
export declare type PriceFragment = {
    __typename?: 'Price';
    billingModel: BillingModel;
    billingPeriod: BillingPeriod;
    billingCadence: BillingCadence;
    billingId?: string | null;
    minUnitQuantity?: number | null;
    maxUnitQuantity?: number | null;
    billingCountryCode?: string | null;
    tiersMode?: TiersMode | null;
    blockSize?: number | null;
    price?: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    } | null;
    creditRate?: {
        __typename?: 'CreditRate';
        amount: number;
        customCurrencyId: any;
    } | null;
    tiers?: Array<({
        __typename?: 'PriceTier';
    } & PriceTierFragment)> | null;
    feature?: {
        __typename?: 'Feature';
        refId: string;
        featureUnits?: string | null;
        featureUnitsPlural?: string | null;
        displayName: string;
        description?: string | null;
    } | null;
};
export declare type OveragePriceFragment = {
    __typename?: 'Price';
    billingModel: BillingModel;
    billingPeriod: BillingPeriod;
    billingId?: string | null;
    billingCountryCode?: string | null;
    tiersMode?: TiersMode | null;
    price?: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    } | null;
    tiers?: Array<({
        __typename?: 'PriceTier';
    } & PriceTierFragment)> | null;
    feature?: {
        __typename?: 'Feature';
        refId: string;
        featureUnits?: string | null;
        featureUnitsPlural?: string | null;
        displayName: string;
        description?: string | null;
    } | null;
};
export declare type TotalPriceFragment = {
    __typename?: 'CustomerSubscriptionTotalPrice';
    subTotal: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
    total: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
};
export declare type PackageEntitlementFragment = {
    __typename?: 'PackageEntitlement';
    usageLimit?: number | null;
    hasUnlimitedUsage?: boolean | null;
    hasSoftLimit?: boolean | null;
    featureId: string;
    resetPeriod?: EntitlementResetPeriod | null;
    hiddenFromWidgets?: Array<WidgetType> | null;
    isCustom?: boolean | null;
    displayNameOverride?: string | null;
    enumValues?: Array<string> | null;
    isGranted: boolean;
    feature: {
        __typename?: 'Feature';
        featureType: FeatureType;
        meterType?: MeterType | null;
        featureUnits?: string | null;
        featureUnitsPlural?: string | null;
        displayName: string;
        description?: string | null;
        refId: string;
        additionalMetaData?: any | null;
    };
};
export declare type AddonFragment = {
    __typename?: 'Addon';
    id: any;
    refId: string;
    billingId?: string | null;
    displayName: string;
    description?: string | null;
    additionalMetaData?: any | null;
    hiddenFromWidgets?: Array<WidgetType> | null;
    pricingType?: PricingType | null;
    maxQuantity?: number | null;
    entitlements?: Array<({
        __typename?: 'PackageEntitlement';
    } & PackageEntitlementFragment)> | null;
    prices?: Array<({
        __typename?: 'Price';
    } & PriceFragment)> | null;
    overagePrices?: Array<({
        __typename?: 'Price';
    } & OveragePriceFragment)> | null;
    dependencies?: Array<({
        __typename?: 'Addon';
    } & AddonDependencyFragment)> | null;
};
export declare type AddonDependencyFragment = {
    __typename?: 'Addon';
    id: any;
    refId: string;
    displayName: string;
    description?: string | null;
};
export declare type PlanFragment = {
    __typename?: 'Plan';
    id: any;
    refId: string;
    displayName: string;
    description?: string | null;
    billingId?: string | null;
    versionNumber: number;
    additionalMetaData?: any | null;
    hiddenFromWidgets?: Array<WidgetType> | null;
    pricingType?: PricingType | null;
    product: ({
        __typename?: 'Product';
    } & ProductFragment);
    basePlan?: {
        __typename?: 'Plan';
        refId: string;
        displayName: string;
    } | null;
    entitlements?: Array<({
        __typename?: 'PackageEntitlement';
    } & PackageEntitlementFragment)> | null;
    inheritedEntitlements?: Array<({
        __typename?: 'PackageEntitlement';
    } & PackageEntitlementFragment)> | null;
    compatibleAddons?: Array<({
        __typename?: 'Addon';
    } & AddonFragment)> | null;
    compatiblePackageGroups?: Array<({
        __typename?: 'PlanCompatiblePackageGroups';
    } & PlanCompatiblePackageGroupsFragment)> | null;
    prices?: Array<({
        __typename?: 'Price';
    } & PriceFragment)> | null;
    overagePrices?: Array<({
        __typename?: 'Price';
    } & OveragePriceFragment)> | null;
    defaultTrialConfig?: {
        __typename?: 'DefaultTrialConfig';
        duration: number;
        units: TrialPeriodUnits;
        trialEndBehavior?: TrialEndBehavior | null;
        budget?: {
            __typename?: 'BudgetConfiguration';
            limit: number;
        } | null;
    } | null;
};
export declare type PlanCompatiblePackageGroupsFragment = {
    __typename?: 'PlanCompatiblePackageGroups';
    packageGroupId: string;
    displayName: string;
    addons?: Array<({
        __typename?: 'Addon';
    } & AddonFragment)> | null;
    options: {
        __typename?: 'PlanCompatiblePackageGroupOptions';
        minItems?: number | null;
        freeItems?: number | null;
    };
};
export declare type CustomerResourceFragment = {
    __typename?: 'CustomerResource';
    resourceId: string;
};
export declare type PageInfoFragment = {
    __typename?: 'PageInfo';
    startCursor?: any | null;
    endCursor?: any | null;
    hasNextPage?: boolean | null;
    hasPreviousPage?: boolean | null;
};
export declare type SubscriptionQueryFragment = {
    __typename?: 'SubscriptionQuery';
    subscriptionId: string;
    status: SubscriptionStatus;
    pricingType: PricingType;
    startDate: any;
    currentBillingPeriodEnd?: any | null;
    trialEndDate?: any | null;
    customer: {
        __typename?: 'Customer';
        customerId: string;
    };
    payingCustomer?: {
        __typename?: 'Customer';
        customerId: string;
    } | null;
    resource?: {
        __typename?: 'CustomerResource';
        resourceId: string;
    } | null;
    plan: {
        __typename?: 'Plan';
        displayName: string;
        planId: string;
    };
    addons?: Array<{
        __typename?: 'SubscriptionAddon';
        quantity: number;
        addon: {
            __typename?: 'Addon';
            addonId: string;
        };
    }> | null;
    trialConfiguration?: {
        __typename?: 'TrialConfiguration';
        trialEndBehavior: TrialEndBehavior;
    } | null;
};
export declare type SlimSubscriptionFragmentV2Fragment = {
    __typename?: 'CustomerSubscription';
    subscriptionId: string;
    status: SubscriptionStatus;
    pricingType: PricingType;
    startDate: any;
    cancellationDate?: any | null;
    currentBillingPeriodEnd?: any | null;
    trialEndDate?: any | null;
    customer: {
        __typename?: 'Customer';
        customerId: string;
    };
    payingCustomer?: {
        __typename?: 'Customer';
        customerId: string;
    } | null;
    resource?: {
        __typename?: 'CustomerResource';
        resourceId: string;
    } | null;
    plan: {
        __typename?: 'Plan';
        displayName: string;
        planId: string;
    };
    addons?: Array<{
        __typename?: 'SubscriptionAddon';
        quantity: number;
        addon: {
            __typename?: 'Addon';
            addonId: string;
        };
    }> | null;
    trialConfiguration?: {
        __typename?: 'TrialConfiguration';
        trialEndBehavior: TrialEndBehavior;
    } | null;
};
export declare type SlimSubscriptionFragment = {
    __typename?: 'CustomerSubscription';
    id: any;
    subscriptionId: string;
    refId: string;
    status: SubscriptionStatus;
    additionalMetaData?: any | null;
    billingId?: string | null;
    billingLinkUrl?: string | null;
    effectiveEndDate?: any | null;
    cancellationDate?: any | null;
    currentBillingPeriodEnd?: any | null;
    pricingType: PricingType;
    paymentCollection: PaymentCollection;
    billingSyncError?: string | null;
    latestInvoice?: ({
        __typename?: 'SubscriptionInvoice';
    } & SubscriptionInvoiceFragment) | null;
    resource?: ({
        __typename?: 'CustomerResource';
    } & CustomerResourceFragment) | null;
    experimentInfo?: {
        __typename?: 'experimentInfo';
        name: string;
        id: string;
        groupType: ExperimentGroupType;
        groupName: string;
    } | null;
    prices?: Array<{
        __typename?: 'SubscriptionPrice';
        usageLimit?: number | null;
        price?: ({
            __typename?: 'Price';
        } & PriceFragment) | null;
    }> | null;
    totalPrice?: ({
        __typename?: 'CustomerSubscriptionTotalPrice';
    } & TotalPriceFragment) | null;
    plan: {
        __typename?: 'Plan';
        id: any;
        refId: string;
    };
    addons?: Array<{
        __typename?: 'SubscriptionAddon';
        quantity: number;
        addon: {
            __typename?: 'Addon';
            id: any;
            refId: string;
        };
    }> | null;
    customer: {
        __typename?: 'Customer';
        id: any;
        refId: string;
    };
};
export declare type SubscriptionScheduledUpdateDataFragment = {
    __typename?: 'SubscriptionScheduledUpdate';
    subscriptionScheduleType: SubscriptionScheduleType;
    scheduleStatus: SubscriptionScheduleStatus;
    scheduledExecutionTime: any;
    targetPackage?: {
        __typename?: 'PackageDTO';
        id: any;
        refId: string;
        displayName: string;
    } | null;
    scheduleVariables?: ({
        __typename?: 'AddonChangeVariables';
    } & ScheduleVariablesFragment_AddonChangeVariables_) | ({
        __typename?: 'AddonPriceOverrideChangeVariables';
    } & ScheduleVariablesFragment_AddonPriceOverrideChangeVariables_) | ({
        __typename?: 'BillingPeriodChangeVariables';
    } & ScheduleVariablesFragment_BillingPeriodChangeVariables_) | ({
        __typename?: 'CouponChangeVariables';
    } & ScheduleVariablesFragment_CouponChangeVariables_) | ({
        __typename?: 'DowngradeChangeVariables';
    } & ScheduleVariablesFragment_DowngradeChangeVariables_) | ({
        __typename?: 'PlanChangeVariables';
    } & ScheduleVariablesFragment_PlanChangeVariables_) | ({
        __typename?: 'PlanPriceOverrideChangeVariables';
    } & ScheduleVariablesFragment_PlanPriceOverrideChangeVariables_) | ({
        __typename?: 'UnitAmountChangeVariables';
    } & ScheduleVariablesFragment_UnitAmountChangeVariables_) | null;
};
export declare type SubscriptionFutureUpdateDataFragment = {
    __typename?: 'SubscriptionFutureUpdate';
    subscriptionScheduleType: SubscriptionScheduleType;
    scheduleStatus: SubscriptionScheduleStatus;
    scheduledExecutionTime: any;
    targetPackage?: {
        __typename?: 'PackageDTO';
        id: any;
        refId: string;
        displayName: string;
    } | null;
    scheduleVariables?: ({
        __typename?: 'AddonChangeVariables';
    } & ScheduleVariablesFragment_AddonChangeVariables_) | ({
        __typename?: 'AddonPriceOverrideChangeVariables';
    } & ScheduleVariablesFragment_AddonPriceOverrideChangeVariables_) | ({
        __typename?: 'BillingPeriodChangeVariables';
    } & ScheduleVariablesFragment_BillingPeriodChangeVariables_) | ({
        __typename?: 'CouponChangeVariables';
    } & ScheduleVariablesFragment_CouponChangeVariables_) | ({
        __typename?: 'DowngradeChangeVariables';
    } & ScheduleVariablesFragment_DowngradeChangeVariables_) | ({
        __typename?: 'PlanChangeVariables';
    } & ScheduleVariablesFragment_PlanChangeVariables_) | ({
        __typename?: 'PlanPriceOverrideChangeVariables';
    } & ScheduleVariablesFragment_PlanPriceOverrideChangeVariables_) | ({
        __typename?: 'UnitAmountChangeVariables';
    } & ScheduleVariablesFragment_UnitAmountChangeVariables_) | null;
};
export declare type SubscriptionInvoiceFragment = {
    __typename?: 'SubscriptionInvoice';
    billingId: string;
    status: SubscriptionInvoiceStatus;
    createdAt: any;
    dueDate?: any | null;
    updatedAt: any;
    errorMessage?: string | null;
    requiresAction: boolean;
    paymentSecret?: string | null;
    paymentUrl?: string | null;
    pdfUrl?: string | null;
    billingReason?: SubscriptionInvoiceBillingReason | null;
    currency?: string | null;
    subTotal?: number | null;
    subTotalExcludingTax?: number | null;
    total?: number | null;
    totalExcludingTax?: number | null;
    tax?: number | null;
    amountDue?: number | null;
    attemptCount?: number | null;
};
export declare type SubscriptionFragment = {
    __typename?: 'CustomerSubscription';
    id: any;
    subscriptionId: string;
    startDate: any;
    endDate?: any | null;
    trialEndDate?: any | null;
    cancellationDate?: any | null;
    effectiveEndDate?: any | null;
    status: SubscriptionStatus;
    refId: string;
    currentBillingPeriodEnd?: any | null;
    additionalMetaData?: any | null;
    billingId?: string | null;
    billingLinkUrl?: string | null;
    paymentCollection: PaymentCollection;
    paymentCollectionMethod?: PaymentCollectionMethod | null;
    billingSyncError?: string | null;
    pricingType: PricingType;
    payingCustomer?: ({
        __typename?: 'Customer';
    } & SlimCustomerFragment) | null;
    latestInvoice?: ({
        __typename?: 'SubscriptionInvoice';
    } & SubscriptionInvoiceFragment) | null;
    resource?: ({
        __typename?: 'CustomerResource';
    } & CustomerResourceFragment) | null;
    experimentInfo?: {
        __typename?: 'experimentInfo';
        name: string;
        groupType: ExperimentGroupType;
        groupName: string;
        id: string;
    } | null;
    prices?: Array<{
        __typename?: 'SubscriptionPrice';
        usageLimit?: number | null;
        price?: ({
            __typename?: 'Price';
        } & PriceFragment) | null;
    }> | null;
    totalPrice?: ({
        __typename?: 'CustomerSubscriptionTotalPrice';
    } & TotalPriceFragment) | null;
    plan: ({
        __typename?: 'Plan';
    } & PlanFragment);
    addons?: Array<{
        __typename?: 'SubscriptionAddon';
        id: any;
        quantity: number;
        addon: ({
            __typename?: 'Addon';
        } & AddonFragment);
    }> | null;
    scheduledUpdates?: Array<({
        __typename?: 'SubscriptionScheduledUpdate';
    } & SubscriptionScheduledUpdateDataFragment)> | null;
    futureUpdates: Array<({
        __typename?: 'SubscriptionFutureUpdate';
    } & SubscriptionFutureUpdateDataFragment)>;
    trialConfiguration?: ({
        __typename?: 'TrialConfiguration';
    } & SubscriptionTrialConfigurationFragment) | null;
};
export declare type SubscriptionTrialConfigurationFragment = {
    __typename?: 'TrialConfiguration';
    trialEndBehavior: TrialEndBehavior;
};
export declare type PromotionalEntitlementFragment = {
    __typename?: 'PromotionalEntitlement';
    status: PromotionalEntitlementStatus;
    usageLimit?: number | null;
    featureId: any;
    hasUnlimitedUsage?: boolean | null;
    hasSoftLimit?: boolean | null;
    resetPeriod?: EntitlementResetPeriod | null;
    endDate?: any | null;
    isVisible: boolean;
    feature: {
        __typename?: 'Feature';
        featureType: FeatureType;
        meterType?: MeterType | null;
        featureUnits?: string | null;
        featureUnitsPlural?: string | null;
        displayName: string;
        description?: string | null;
        refId: string;
        additionalMetaData?: any | null;
    };
};
export declare type SlimCustomerFragment = {
    __typename?: 'Customer';
    id: any;
    name?: string | null;
    email?: string | null;
    createdAt?: any | null;
    updatedAt: any;
    refId: string;
    customerId: string;
    billingId?: string | null;
    additionalMetaData?: any | null;
    awsMarketplaceCustomerId?: string | null;
};
export declare type CustomerFragment = ({
    __typename?: 'Customer';
    hasPaymentMethod: boolean;
    hasActiveSubscription: boolean;
    defaultPaymentExpirationMonth?: number | null;
    defaultPaymentExpirationYear?: number | null;
    defaultPaymentMethodLast4Digits?: string | null;
    defaultPaymentMethodType?: PaymentMethodType | null;
    trialedPlans?: Array<{
        __typename?: 'TrialedPlan';
        productId?: string | null;
        productRefId?: string | null;
        planRefId?: string | null;
        planId?: string | null;
    }> | null;
    experimentInfo?: {
        __typename?: 'experimentInfo';
        groupType: ExperimentGroupType;
        groupName: string;
        id: string;
        name: string;
    } | null;
    coupon?: ({
        __typename?: 'Coupon';
    } & CouponFragment) | null;
    eligibleForTrial?: Array<{
        __typename?: 'EligibleForTrial';
        productId?: string | null;
        productRefId?: string | null;
        eligible: boolean;
    }> | null;
    promotionalEntitlements: Array<({
        __typename?: 'PromotionalEntitlement';
    } & PromotionalEntitlementFragment)>;
} & SlimCustomerFragment);
export declare type CustomerWithSubscriptionsFragment = ({
    __typename?: 'Customer';
    subscriptions?: Array<({
        __typename?: 'CustomerSubscription';
    } & SubscriptionFragment)> | null;
} & CustomerFragment);
export declare type CustomerStatisticsFragment = {
    __typename?: 'Customer';
    statistics?: {
        __typename?: 'CustomerStatistics';
        activeSubscriptionsByPricingType: Array<{
            __typename?: 'SubscriptionPricingTypeStatistics';
            pricingType: PricingType;
            totalCount: number;
        }>;
    } | null;
};
export declare type SubscriptionPreviewFragment = {
    __typename?: 'SubscriptionPreview';
    isPlanDowngrade?: boolean | null;
    hasScheduledUpdates?: boolean | null;
    subTotal: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
    totalExcludingTax: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
    total: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
    discountAmount?: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    } | null;
    taxDetails?: {
        __typename?: 'SubscriptionPreviewTaxDetails';
        displayName: string;
        percentage: number;
        inclusive: boolean;
    } | null;
    tax?: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    } | null;
    billingPeriodRange: {
        __typename?: 'DateRange';
        start?: any | null;
        end?: any | null;
    };
    discount?: {
        __typename?: 'SubscriptionPreviewDiscount';
        name?: string | null;
        type: DiscountType;
        value: number;
        durationType: DiscountDurationType;
        durationInMonths?: number | null;
    } | null;
    subscription?: {
        __typename?: 'SubscriptionPricePreviewDTO';
        subTotal: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        totalExcludingTax: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        total: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        tax: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        discountAmount?: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        } | null;
        taxDetails?: {
            __typename?: 'SubscriptionPreviewTaxDetails';
            displayName: string;
            percentage: number;
            inclusive: boolean;
        } | null;
        discount?: {
            __typename?: 'SubscriptionPreviewDiscount';
            name?: string | null;
            type: DiscountType;
            value: number;
            durationType: DiscountDurationType;
            durationInMonths?: number | null;
        } | null;
    } | null;
    proration?: {
        __typename?: 'SubscriptionPreviewProrations';
        prorationDate: any;
        credit: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        debit: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        netAmount: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
    } | null;
    credits?: {
        __typename?: 'SubscriptionPreviewCredits';
        initial: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        used: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        remaining: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
    } | null;
};
export declare type SubscriptionPreviewInvoiceFragment = {
    __typename?: 'SubscriptionPreviewInvoice';
    total: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
    subTotal: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
    totalExcludingTax: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
    tax?: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    } | null;
    discount?: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    } | null;
    taxDetails?: {
        __typename?: 'SubscriptionPreviewTaxDetails';
        displayName: string;
        percentage: number;
        inclusive: boolean;
    } | null;
    discountDetails?: {
        __typename?: 'SubscriptionPreviewDiscount';
        type: DiscountType;
        value: number;
        durationType: DiscountDurationType;
        durationInMonths?: number | null;
    } | null;
};
export declare type ImmediateSubscriptionPreviewInvoiceFragment = {
    __typename?: 'ImmediateSubscriptionPreviewInvoice';
    total: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
    subTotal: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
    totalExcludingTax: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
    tax?: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    } | null;
    discount?: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    } | null;
    taxDetails?: {
        __typename?: 'SubscriptionPreviewTaxDetails';
        displayName: string;
        percentage: number;
        inclusive: boolean;
    } | null;
    discountDetails?: {
        __typename?: 'SubscriptionPreviewDiscount';
        type: DiscountType;
        value: number;
        durationType: DiscountDurationType;
        durationInMonths?: number | null;
    } | null;
    credits?: {
        __typename?: 'SubscriptionPreviewCredits';
        initial: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        used: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        remaining: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
    } | null;
    proration?: {
        __typename?: 'SubscriptionPreviewProrations';
        prorationDate: any;
        hasProrations?: boolean | null;
        credit: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        debit: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        netAmount: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
    } | null;
};
export declare type SubscriptionPreviewV2Fragment = {
    __typename?: 'SubscriptionPreviewV2';
    isPlanDowngrade?: boolean | null;
    hasScheduledUpdates?: boolean | null;
    immediateInvoice: ({
        __typename?: 'ImmediateSubscriptionPreviewInvoice';
    } & ImmediateSubscriptionPreviewInvoiceFragment);
    recurringInvoice?: ({
        __typename?: 'SubscriptionPreviewInvoice';
    } & SubscriptionPreviewInvoiceFragment) | null;
    billingPeriodRange: {
        __typename?: 'DateRange';
        start?: any | null;
        end?: any | null;
    };
};
export declare type SubscriptionInvoicePreviewFragment = {
    __typename?: 'SubscriptionInvoicePreview';
    lastUpdatedAt: any;
    amountDue: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
    minimumSpendAdjustment: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
    total: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
    totalExcludingTax: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
    subTotal: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
    subTotalExcludingTax: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
    tax?: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    } | null;
    taxDetails?: {
        __typename?: 'SubscriptionPreviewTaxDetails';
        displayName: string;
        percentage: number;
        inclusive: boolean;
    } | null;
    discount?: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    } | null;
    discountDetails?: {
        __typename?: 'SubscriptionPreviewDiscount';
        name?: string | null;
        type: DiscountType;
        value: number;
        durationType: DiscountDurationType;
        durationInMonths?: number | null;
    } | null;
    credits?: {
        __typename?: 'SubscriptionPreviewCredits';
        initial: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        used: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        remaining: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
    } | null;
    lines: Array<{
        __typename?: 'SubscriptionInvoicePreviewLineItem';
        type: InvoiceLineItemType;
        description: string;
        costDescription: string;
        quantity?: number | null;
        proration: boolean;
        usageLimit?: number | null;
        hasSoftLimit?: boolean | null;
        amount: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        unitPrice?: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        } | null;
        price?: ({
            __typename?: 'Price';
        } & PriceFragment) | null;
        period: {
            __typename?: 'SubscriptionInvoicePreviewLineItemPeriod';
            start: any;
            end: any;
        };
        lines?: Array<{
            __typename?: 'SubscriptionInvoicePreviewLineItemData';
            type: InvoiceLineItemType;
            description: string;
            costDescription: string;
            quantity?: number | null;
            proration: boolean;
            usageLimit?: number | null;
            hasSoftLimit?: boolean | null;
        }> | null;
    }>;
};
export declare type FeatureFragment = {
    __typename: 'EntitlementFeature';
    featureType: FeatureType;
    meterType?: MeterType | null;
    featureUnits?: string | null;
    featureUnitsPlural?: string | null;
    description?: string | null;
    displayName: string;
    refId: string;
    unitTransformation?: {
        __typename?: 'UnitTransformation';
        divide: number;
        round: UnitTransformationRound;
    } | null;
};
declare type ResetPeriodConfigurationFragment_MonthlyResetPeriodConfig_ = {
    __typename: 'MonthlyResetPeriodConfig';
    monthlyAccordingTo?: MonthlyAccordingTo | null;
};
declare type ResetPeriodConfigurationFragment_WeeklyResetPeriodConfig_ = {
    __typename: 'WeeklyResetPeriodConfig';
    weeklyAccordingTo?: WeeklyAccordingTo | null;
};
declare type ResetPeriodConfigurationFragment_YearlyResetPeriodConfig_ = {
    __typename: 'YearlyResetPeriodConfig';
    yearlyAccordingTo?: YearlyAccordingTo | null;
};
export declare type ResetPeriodConfigurationFragment = ResetPeriodConfigurationFragment_MonthlyResetPeriodConfig_ | ResetPeriodConfigurationFragment_WeeklyResetPeriodConfig_ | ResetPeriodConfigurationFragment_YearlyResetPeriodConfig_;
export declare type UsageUpdatedFragment = {
    __typename?: 'UsageMeasurementUpdated';
    customerId: string;
    resourceId?: string | null;
    featureId: string;
    currentUsage: number;
    usagePeriodStart?: number | null;
    usagePeriodEnd?: number | null;
    nextResetDate?: number | null;
};
export declare type EntitlementFragment = {
    __typename: 'Entitlement';
    isGranted: boolean;
    accessDeniedReason?: AccessDeniedReason | null;
    customerId?: string | null;
    resourceId?: string | null;
    usageLimit?: number | null;
    hasUnlimitedUsage: boolean;
    hasSoftLimit?: boolean | null;
    currentUsage?: number | null;
    requestedUsage?: number | null;
    requestedValues?: Array<string> | null;
    enumValues?: Array<string> | null;
    entitlementUpdatedAt?: any | null;
    usageUpdatedAt?: any | null;
    usagePeriodAnchor?: any | null;
    usagePeriodStart?: any | null;
    usagePeriodEnd?: any | null;
    nextResetDate?: any | null;
    resetPeriod?: EntitlementResetPeriod | null;
    resetPeriodConfiguration?: ({
        __typename?: 'MonthlyResetPeriodConfig';
    } & ResetPeriodConfigurationFragment_MonthlyResetPeriodConfig_) | ({
        __typename?: 'WeeklyResetPeriodConfig';
    } & ResetPeriodConfigurationFragment_WeeklyResetPeriodConfig_) | ({
        __typename?: 'YearlyResetPeriodConfig';
    } & ResetPeriodConfigurationFragment_YearlyResetPeriodConfig_) | null;
    feature?: ({
        __typename?: 'EntitlementFeature';
    } & FeatureFragment) | null;
};
export declare type TypographyConfigurationFragment = {
    __typename?: 'TypographyConfiguration';
    fontFamily?: string | null;
    h1?: ({
        __typename?: 'FontVariant';
    } & FontVariantFragment) | null;
    h2?: ({
        __typename?: 'FontVariant';
    } & FontVariantFragment) | null;
    h3?: ({
        __typename?: 'FontVariant';
    } & FontVariantFragment) | null;
    body?: ({
        __typename?: 'FontVariant';
    } & FontVariantFragment) | null;
};
export declare type FontVariantFragment = {
    __typename?: 'FontVariant';
    fontSize?: number | null;
    fontWeight?: FontWeight | null;
};
export declare type LayoutConfigurationFragment = {
    __typename?: 'PaywallLayoutConfiguration';
    alignment?: Alignment | null;
    planWidth?: number | null;
    planMargin?: number | null;
    planPadding?: number | null;
};
export declare type PaywallConfigurationFragment = {
    __typename?: 'PaywallConfiguration';
    customCss?: string | null;
    palette?: {
        __typename?: 'PaywallColorsPalette';
        primary?: string | null;
        textColor?: string | null;
        backgroundColor?: string | null;
        borderColor?: string | null;
        currentPlanBackground?: string | null;
    } | null;
    typography?: ({
        __typename?: 'TypographyConfiguration';
    } & TypographyConfigurationFragment) | null;
    layout?: ({
        __typename?: 'PaywallLayoutConfiguration';
    } & LayoutConfigurationFragment) | null;
};
export declare type PaywallCurrencyFragment = {
    __typename?: 'PaywallCurrency';
    code: Currency;
    symbol: string;
};
export declare type ProductFragment = {
    __typename?: 'Product';
    refId: string;
    displayName?: string | null;
    description?: string | null;
    additionalMetaData?: any | null;
    productSettings: {
        __typename?: 'ProductSettings';
        downgradePlan?: {
            __typename?: 'Plan';
            refId: string;
            displayName: string;
        } | null;
    };
};
export declare type EntitlementsUpdatedPayloadFragment = {
    __typename?: 'EntitlementsUpdated';
    customerId: string;
    resourceId?: string | null;
    entitlements: Array<({
        __typename?: 'Entitlement';
    } & EntitlementFragment)>;
};
export declare type EntitlementUsageUpdatedFragment = {
    __typename?: 'UsageUpdated';
    usage: ({
        __typename?: 'UsageMeasurementUpdated';
    } & UsageUpdatedFragment);
    entitlement: ({
        __typename?: 'Entitlement';
    } & EntitlementFragment);
};
export declare type PackagePublishedPayloadFragment = {
    __typename?: 'PackagePublished';
    accountId: string;
    environmentId: string;
    packageType: string;
    packageRefId: string;
    packageVersion: number;
    migrationType: PublishMigrationType;
};
export declare type CustomerPortalFragment = {
    __typename?: 'CustomerPortal';
    showWatermark: boolean;
    billingPortalUrl?: string | null;
    canUpgradeSubscription: boolean;
    subscriptions: Array<({
        __typename?: 'CustomerPortalSubscription';
    } & CustomerPortalSubscriptionFragment)>;
    entitlements: Array<({
        __typename?: 'Entitlement';
    } & CustomerPortalEntitlementFragment)>;
    promotionalEntitlements: Array<({
        __typename?: 'CustomerPortalPromotionalEntitlement';
    } & CustomerPortalPromotionalEntitlementFragment)>;
    billingInformation: ({
        __typename?: 'CustomerPortalBillingInformation';
    } & CustomerPortalBillingInformationFragment);
    configuration?: ({
        __typename?: 'CustomerPortalConfiguration';
    } & CustomerPortalConfigurationFragment) | null;
    resource?: ({
        __typename?: 'CustomerResource';
    } & CustomerResourceFragment) | null;
};
export declare type CheckoutStateFragment = {
    __typename?: 'CheckoutState';
    setupSecret: string;
    configuration?: ({
        __typename?: 'CheckoutConfiguration';
    } & CheckoutConfigurationFragment) | null;
    customer: ({
        __typename?: 'Customer';
    } & CustomerFragment);
    activeSubscription?: ({
        __typename?: 'CustomerSubscription';
    } & SubscriptionFragment) | null;
    resource?: ({
        __typename?: 'CustomerResource';
    } & CustomerResourceFragment) | null;
    plan: ({
        __typename?: 'Plan';
    } & PlanFragment);
    billingIntegration: {
        __typename?: 'CheckoutBillingIntegration';
        billingIdentifier: BillingVendorIdentifier;
        credentials: {
            __typename?: 'CheckoutCredentials';
            accountId: string;
            publicKey: string;
        };
    };
};
export declare type CheckoutConfigurationFragment = {
    __typename: 'CheckoutConfiguration';
    customCss?: string | null;
    palette?: {
        __typename: 'CheckoutColorPalette';
        primary?: string | null;
        textColor?: string | null;
        backgroundColor?: string | null;
        borderColor?: string | null;
        summaryBackgroundColor?: string | null;
    } | null;
    typography?: ({
        __typename: 'TypographyConfiguration';
    } & TypographyConfigurationFragment) | null;
    content?: {
        __typename?: 'CheckoutContent';
        collectPhoneNumber?: boolean | null;
    } | null;
};
export declare type CustomerPortalConfigurationFragment = {
    __typename?: 'CustomerPortalConfiguration';
    customCss?: string | null;
    palette?: {
        __typename?: 'CustomerPortalColorsPalette';
        primary?: string | null;
        textColor?: string | null;
        backgroundColor?: string | null;
        borderColor?: string | null;
        currentPlanBackground?: string | null;
        iconsColor?: string | null;
        paywallBackgroundColor?: string | null;
    } | null;
    typography?: ({
        __typename?: 'TypographyConfiguration';
    } & TypographyConfigurationFragment) | null;
};
export declare type CustomerPortalSubscriptionPriceFragment = {
    __typename?: 'CustomerPortalSubscriptionPrice';
    billingPeriod?: BillingPeriod | null;
    billingModel?: BillingModel | null;
    blockSize?: number | null;
    price?: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    } | null;
    creditRate?: {
        __typename?: 'CreditRate';
        amount: number;
        customCurrencyId: any;
    } | null;
    feature?: {
        __typename?: 'CustomerPortalPricingFeature';
        id: any;
        refId: string;
        displayName: string;
        featureUnits?: string | null;
        featureUnitsPlural?: string | null;
    } | null;
};
export declare type CustomerPortalSubscriptionFragment = {
    __typename?: 'CustomerPortalSubscription';
    subscriptionId: string;
    planId: string;
    planName: string;
    pricingType: PricingType;
    status: SubscriptionStatus;
    trialRemainingDays?: number | null;
    prices: Array<({
        __typename?: 'CustomerPortalSubscriptionPrice';
    } & CustomerPortalSubscriptionPriceFragment)>;
    pricing: {
        __typename?: 'CustomerPortalSubscriptionPricing';
        unitQuantity?: number | null;
        billingPeriod?: BillingPeriod | null;
        billingModel?: BillingModel | null;
        pricingType: PricingType;
        usageBasedEstimatedBill?: number | null;
        price?: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        } | null;
        creditRate?: {
            __typename?: 'CreditRate';
            amount: number;
            customCurrencyId: any;
        } | null;
        feature?: {
            __typename?: 'CustomerPortalPricingFeature';
            featureUnits?: string | null;
            featureUnitsPlural?: string | null;
            displayName: string;
        } | null;
    };
    billingPeriodRange?: {
        __typename?: 'DateRange';
        start?: any | null;
        end?: any | null;
    } | null;
    totalPrice?: {
        __typename?: 'CustomerSubscriptionTotalPrice';
        subTotal: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        total: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
        addonsTotal: {
            __typename?: 'Money';
            amount: number;
            currency: Currency;
        };
    } | null;
    addons: Array<({
        __typename?: 'CustomerPortalAddon';
    } & CustomerPortalSubscriptionAddonFragment)>;
    scheduledUpdates?: Array<({
        __typename?: 'SubscriptionScheduledUpdate';
    } & CustomerPortalSubscriptionScheduledUpdateDataFragment)> | null;
};
export declare type CustomerPortalSubscriptionAddonFragment = {
    __typename?: 'CustomerPortalAddon';
    addonId: string;
    description?: string | null;
    displayName: string;
    quantity: number;
};
export declare type CustomerPortalSubscriptionScheduledUpdateDataFragment = {
    __typename?: 'SubscriptionScheduledUpdate';
    subscriptionScheduleType: SubscriptionScheduleType;
    scheduleStatus: SubscriptionScheduleStatus;
    scheduledExecutionTime: any;
    targetPackage?: {
        __typename?: 'PackageDTO';
        id: any;
        refId: string;
        displayName: string;
        pricingType?: PricingType | null;
    } | null;
    scheduleVariables?: ({
        __typename?: 'AddonChangeVariables';
    } & ScheduleVariablesFragment_AddonChangeVariables_) | ({
        __typename?: 'AddonPriceOverrideChangeVariables';
    } & ScheduleVariablesFragment_AddonPriceOverrideChangeVariables_) | ({
        __typename?: 'BillingPeriodChangeVariables';
    } & ScheduleVariablesFragment_BillingPeriodChangeVariables_) | ({
        __typename?: 'CouponChangeVariables';
    } & ScheduleVariablesFragment_CouponChangeVariables_) | ({
        __typename?: 'DowngradeChangeVariables';
    } & ScheduleVariablesFragment_DowngradeChangeVariables_) | ({
        __typename?: 'PlanChangeVariables';
    } & ScheduleVariablesFragment_PlanChangeVariables_) | ({
        __typename?: 'PlanPriceOverrideChangeVariables';
    } & ScheduleVariablesFragment_PlanPriceOverrideChangeVariables_) | ({
        __typename?: 'UnitAmountChangeVariables';
    } & ScheduleVariablesFragment_UnitAmountChangeVariables_) | null;
};
export declare type CustomerPortalEntitlementFragment = {
    __typename?: 'Entitlement';
    isGranted: boolean;
    usageLimit?: number | null;
    currentUsage?: number | null;
    hasUnlimitedUsage: boolean;
    hasSoftLimit?: boolean | null;
    usagePeriodStart?: any | null;
    usagePeriodEnd?: any | null;
    nextResetDate?: any | null;
    resetPeriod?: EntitlementResetPeriod | null;
    resetPeriodConfiguration?: ({
        __typename?: 'MonthlyResetPeriodConfig';
    } & ResetPeriodConfigurationFragment_MonthlyResetPeriodConfig_) | ({
        __typename?: 'WeeklyResetPeriodConfig';
    } & ResetPeriodConfigurationFragment_WeeklyResetPeriodConfig_) | ({
        __typename?: 'YearlyResetPeriodConfig';
    } & ResetPeriodConfigurationFragment_YearlyResetPeriodConfig_) | null;
    feature?: ({
        __typename?: 'EntitlementFeature';
    } & FeatureFragment) | null;
};
export declare type CustomerPortalPromotionalEntitlementFragment = {
    __typename?: 'CustomerPortalPromotionalEntitlement';
    displayName: string;
    hasUnlimitedUsage?: boolean | null;
    hasSoftLimit?: boolean | null;
    usageLimit?: number | null;
    period: PromotionalEntitlementPeriod;
    startDate: any;
    endDate?: any | null;
};
export declare type CustomerPortalBillingInformationFragment = {
    __typename?: 'CustomerPortalBillingInformation';
    email?: string | null;
    name?: string | null;
    defaultPaymentMethodLast4Digits?: string | null;
    defaultPaymentMethodId?: string | null;
    defaultPaymentExpirationMonth?: number | null;
    defaultPaymentExpirationYear?: number | null;
    defaultPaymentMethodType?: PaymentMethodType | null;
};
export declare type MockPaywallPlanFragment = {
    __typename?: 'PaywallPlan';
    refId: string;
    description?: string | null;
    displayName: string;
    billingId?: string | null;
    additionalMetaData?: any | null;
    pricingType?: PricingType | null;
    product: {
        __typename?: 'PaywallProduct';
        refId: string;
        displayName?: string | null;
        description?: string | null;
        additionalMetaData?: any | null;
    };
    basePlan?: {
        __typename?: 'PaywallBasePlan';
        refId: string;
        displayName: string;
    } | null;
    entitlements?: Array<({
        __typename?: 'Entitlement';
    } & MockPaywallPackageEntitlementFragment)> | null;
    inheritedEntitlements?: Array<({
        __typename?: 'Entitlement';
    } & MockPaywallPackageEntitlementFragment)> | null;
    prices: Array<({
        __typename?: 'PaywallPrice';
    } & MockPaywallPriceFragment)>;
    defaultTrialConfig?: {
        __typename?: 'DefaultTrialConfig';
        duration: number;
        units: TrialPeriodUnits;
        trialEndBehavior?: TrialEndBehavior | null;
        budget?: {
            __typename?: 'BudgetConfiguration';
            limit: number;
        } | null;
    } | null;
    compatibleAddons?: Array<({
        __typename?: 'PaywallAddon';
    } & MockPaywallAddonFragment)> | null;
    compatiblePackageGroups?: Array<({
        __typename?: 'PaywallPlanCompatiblePackageGroup';
    } & MockPaywallPlanCompatiblePackageGroupsFragment)> | null;
};
export declare type MockPaywallPackageEntitlementFragment = {
    __typename?: 'Entitlement';
    usageLimit?: number | null;
    hasUnlimitedUsage: boolean;
    hasSoftLimit?: boolean | null;
    resetPeriod?: EntitlementResetPeriod | null;
    hiddenFromWidgets?: Array<WidgetType> | null;
    displayNameOverride?: string | null;
    enumValues?: Array<string> | null;
    isGranted: boolean;
    feature?: {
        __typename?: 'EntitlementFeature';
        featureType: FeatureType;
        meterType?: MeterType | null;
        featureUnits?: string | null;
        featureUnitsPlural?: string | null;
        displayName: string;
        description?: string | null;
        refId: string;
        additionalMetaData?: any | null;
    } | null;
};
export declare type MockPaywallPriceFragment = {
    __typename?: 'PaywallPrice';
    billingModel: BillingModel;
    billingPeriod: BillingPeriod;
    billingId?: string | null;
    minUnitQuantity?: number | null;
    maxUnitQuantity?: number | null;
    billingCountryCode?: string | null;
    tiersMode?: TiersMode | null;
    blockSize?: number | null;
    price?: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    } | null;
    creditRate?: {
        __typename?: 'CreditRate';
        amount: number;
        customCurrencyId: any;
    } | null;
    tiers?: Array<({
        __typename?: 'PriceTier';
    } & PriceTierFragment)> | null;
    feature?: {
        __typename?: 'EntitlementFeature';
        refId: string;
        featureUnits?: string | null;
        featureUnitsPlural?: string | null;
        displayName: string;
    } | null;
};
export declare type PaywallCalculatedPricePointsFragment = {
    __typename?: 'PaywallPricePoint';
    planId: string;
    additionalChargesMayApply?: boolean | null;
    billingPeriod: BillingPeriod;
    amount: number;
    currency: Currency;
    billingCountryCode?: string | null;
    feature?: {
        __typename?: 'Feature';
        refId: string;
        featureUnits?: string | null;
        featureUnitsPlural?: string | null;
        displayName: string;
        description?: string | null;
    } | null;
};
export declare type MockPaywallPlanCompatiblePackageGroupsFragment = {
    __typename?: 'PaywallPlanCompatiblePackageGroup';
    packageGroupId: string;
    displayName: string;
    description?: string | null;
    addons?: Array<({
        __typename?: 'PaywallAddon';
    } & MockPaywallAddonFragment)> | null;
    options: {
        __typename?: 'PaywallPlanCompatiblePackageGroupOptions';
        minItems?: number | null;
        freeItems?: number | null;
    };
};
export declare type MockPaywallAddonDependencyFragment = {
    __typename?: 'PaywallAddon';
    refId: string;
    displayName: string;
    description?: string | null;
};
export declare type MockPaywallAddonFragment = {
    __typename?: 'PaywallAddon';
    refId: string;
    displayName: string;
    description?: string | null;
    additionalMetaData?: any | null;
    billingId?: string | null;
    maxQuantity?: number | null;
    hiddenFromWidgets?: Array<WidgetType> | null;
    pricingType?: PricingType | null;
    dependencies?: Array<({
        __typename?: 'PaywallAddon';
    } & MockPaywallAddonDependencyFragment)> | null;
    entitlements: Array<({
        __typename?: 'Entitlement';
    } & MockPaywallPackageEntitlementFragment)>;
    prices: Array<({
        __typename?: 'PaywallPrice';
    } & MockPaywallPriceFragment)>;
};
export declare type PaywallFragment = {
    __typename?: 'Paywall';
    plans: Array<({
        __typename?: 'Plan';
    } & PlanFragment)>;
    currency: ({
        __typename?: 'PaywallCurrency';
    } & PaywallCurrencyFragment);
    configuration?: ({
        __typename?: 'PaywallConfiguration';
    } & PaywallConfigurationFragment) | null;
    customer?: ({
        __typename?: 'Customer';
    } & CustomerFragment) | null;
    activeSubscriptions?: Array<({
        __typename?: 'CustomerSubscription';
    } & SubscriptionFragment)> | null;
    resource?: ({
        __typename?: 'CustomerResource';
    } & CustomerResourceFragment) | null;
    paywallCalculatedPricePoints?: Array<({
        __typename?: 'PaywallPricePoint';
    } & PaywallCalculatedPricePointsFragment)> | null;
};
export declare type UsageHistoryFragment = {
    __typename?: 'UsageHistory';
    startDate: any;
    endDate?: any | null;
    markers: Array<{
        __typename?: 'UsageMarker';
        type: UsageMarkerType;
        timestamp: any;
    }>;
    usageMeasurements: Array<{
        __typename?: 'UsageMeasurementPoint';
        date: any;
        value: number;
        isResetPoint: boolean;
    }>;
    groups?: Array<{
        __typename?: 'GroupUsageHistory';
        groupInfo: Array<{
            __typename?: 'GroupInfo';
            key: string;
            value: string;
        }>;
        usageMeasurements: Array<{
            __typename?: 'UsageMeasurementPoint';
            date: any;
            value: number;
            isResetPoint: boolean;
        }>;
    }> | null;
};
export declare type UsageHistoryV2Fragment = {
    __typename?: 'UsageHistoryV2';
    markers: Array<{
        __typename?: 'UsageMarker';
        type: UsageMarkerType;
        timestamp: any;
    }>;
    series: Array<{
        __typename?: 'UsageHistorySeries';
        tags: Array<{
            __typename?: 'UsageHistorySeriesTag';
            key: string;
            value: string;
        }>;
        points: Array<{
            __typename?: 'UsageHistoryPoint';
            timestamp: any;
            value: number;
            isResetPoint: boolean;
        }>;
    }>;
};
export declare type ProvisionCustomerFragment = {
    __typename?: 'ProvisionedCustomer';
    subscriptionDecisionStrategy: SubscriptionDecisionStrategy;
    customer: ({
        __typename?: 'Customer';
    } & SlimCustomerFragment);
    subscription?: ({
        __typename?: 'CustomerSubscription';
    } & SlimSubscriptionFragment) | null;
    entitlements?: Array<({
        __typename?: 'Entitlement';
    } & EntitlementFragment)> | null;
};
export declare type ApplySubscriptionFragment = {
    __typename?: 'ApplySubscription';
    subscription?: ({
        __typename?: 'CustomerSubscription';
    } & SubscriptionFragment) | null;
    entitlements?: Array<({
        __typename?: 'Entitlement';
    } & EntitlementFragment)> | null;
};
export declare type ProvisionSubscriptionFragment = {
    __typename?: 'ProvisionSubscriptionResult';
    status: ProvisionSubscriptionStatus;
    checkoutUrl?: string | null;
    checkoutBillingId?: string | null;
    subscription?: ({
        __typename?: 'CustomerSubscription';
    } & SlimSubscriptionFragment) | null;
    entitlements?: Array<({
        __typename?: 'Entitlement';
    } & EntitlementFragment)> | null;
};
export declare type ReportUsageFragment = {
    __typename?: 'UsageMeasurementWithCurrentUsage';
    id: any;
    featureId: string;
    customerId: string;
    resourceId?: string | null;
    currentUsage?: number | null;
    usagePeriodStart?: any | null;
    usagePeriodEnd?: any | null;
    nextResetDate?: any | null;
    timestamp: any;
};
declare type ScheduleVariablesFragment_AddonChangeVariables_ = {
    __typename: 'AddonChangeVariables';
    addonRefId: string;
    newQuantity: number;
};
declare type ScheduleVariablesFragment_AddonPriceOverrideChangeVariables_ = {
    __typename: 'AddonPriceOverrideChangeVariables';
    addonRefId: string;
    featureId?: string | null;
};
declare type ScheduleVariablesFragment_BillingPeriodChangeVariables_ = {
    __typename: 'BillingPeriodChangeVariables';
    billingPeriod?: BillingPeriod | null;
};
declare type ScheduleVariablesFragment_CouponChangeVariables_ = {
    __typename: 'CouponChangeVariables';
};
declare type ScheduleVariablesFragment_DowngradeChangeVariables_ = {
    __typename: 'DowngradeChangeVariables';
    downgradePlanRefId: string;
    billingPeriod?: BillingPeriod | null;
    billableFeatures?: Array<{
        __typename?: 'BillableFeature';
        featureId: string;
        quantity: number;
    }> | null;
    addons?: Array<{
        __typename?: 'PlanChangeAddon';
        addonRefId: string;
        quantity: number;
    }> | null;
    priceOverrides?: Array<{
        __typename?: 'PriceOverrideChangeVariables';
        planRefId?: string | null;
        addonRefId?: string | null;
        featureId?: string | null;
    }> | null;
};
declare type ScheduleVariablesFragment_PlanChangeVariables_ = {
    __typename: 'PlanChangeVariables';
    planRefId: string;
    changeType: PlanChangeType;
    billingPeriod?: BillingPeriod | null;
    billableFeatures?: Array<{
        __typename?: 'BillableFeature';
        featureId: string;
        quantity: number;
    }> | null;
    addons?: Array<{
        __typename?: 'PlanChangeAddon';
        addonRefId: string;
        quantity: number;
    }> | null;
    priceOverrides?: Array<{
        __typename?: 'PriceOverrideChangeVariables';
        planRefId?: string | null;
        addonRefId?: string | null;
        featureId?: string | null;
    }> | null;
};
declare type ScheduleVariablesFragment_PlanPriceOverrideChangeVariables_ = {
    __typename: 'PlanPriceOverrideChangeVariables';
    planRefId: string;
    featureId?: string | null;
};
declare type ScheduleVariablesFragment_UnitAmountChangeVariables_ = {
    __typename: 'UnitAmountChangeVariables';
    newUnitAmount?: number | null;
    featureId?: string | null;
};
export declare type ScheduleVariablesFragment = ScheduleVariablesFragment_AddonChangeVariables_ | ScheduleVariablesFragment_AddonPriceOverrideChangeVariables_ | ScheduleVariablesFragment_BillingPeriodChangeVariables_ | ScheduleVariablesFragment_CouponChangeVariables_ | ScheduleVariablesFragment_DowngradeChangeVariables_ | ScheduleVariablesFragment_PlanChangeVariables_ | ScheduleVariablesFragment_PlanPriceOverrideChangeVariables_ | ScheduleVariablesFragment_UnitAmountChangeVariables_;
export declare type CreditGrantFragment = {
    __typename?: 'CreditGrant';
    grantId: string;
    amount: number;
    comment?: string | null;
    currencyId: string;
    customerId: string;
    displayName: string;
    effectiveAt: any;
    expireAt?: any | null;
    grantType: CreditGrantType;
    priority: number;
    consumedAmount: number;
    createdAt: any;
    updatedAt: any;
    resourceId?: string | null;
    additionalMetaData?: any | null;
    cost: {
        __typename?: 'Money';
        amount: number;
        currency: Currency;
    };
};
export declare type CreditsBalanceSummaryFragment = {
    __typename?: 'CreditBalanceSummary';
    customerId: string;
    balances: Array<{
        __typename?: 'CreditBalance';
        currentBalance: number;
        totalConsumed: number;
        totalGranted: number;
        currency: {
            __typename?: 'SlimCustomCurrency';
            currencyId: string;
            displayName: string;
            symbol?: string | null;
        };
    }>;
};
export declare type ProvisionCustomerMutationVariables = Exact<{
    input: ProvisionCustomerInput;
}>;
export declare type ProvisionCustomerMutation = {
    __typename?: 'Mutation';
    provisionCustomer: ({
        __typename?: 'ProvisionedCustomer';
    } & ProvisionCustomerFragment);
};
export declare type ImportCustomerBulkMutationVariables = Exact<{
    input: ImportCustomerBulkInput;
}>;
export declare type ImportCustomerBulkMutation = {
    __typename?: 'Mutation';
    importCustomersBulk?: string | null;
};
export declare type ImportCustomerMutationVariables = Exact<{
    input: ImportCustomerInput;
}>;
export declare type ImportCustomerMutation = {
    __typename?: 'Mutation';
    importCustomer: ({
        __typename?: 'Customer';
    } & SlimCustomerFragment);
};
export declare type UpdateCustomerMutationVariables = Exact<{
    input: UpdateCustomerInput;
}>;
export declare type UpdateCustomerMutation = {
    __typename?: 'Mutation';
    updateCustomer: ({
        __typename?: 'Customer';
    } & SlimCustomerFragment);
};
export declare type DetachCustomerPaymentMethodMutationVariables = Exact<{
    input: DetachCustomerPaymentMethodInput;
}>;
export declare type DetachCustomerPaymentMethodMutation = {
    __typename?: 'Mutation';
    detachCustomerPaymentMethod: ({
        __typename?: 'Customer';
    } & SlimCustomerFragment);
};
export declare type GrantPromotionalEntitlementsMutationVariables = Exact<{
    input: GrantPromotionalEntitlementsInput;
}>;
export declare type GrantPromotionalEntitlementsMutation = {
    __typename?: 'Mutation';
    grantPromotionalEntitlements: Array<({
        __typename?: 'PromotionalEntitlement';
    } & PromotionalEntitlementFragment)>;
};
export declare type RevokePromotionalEntitlementMutationVariables = Exact<{
    input: RevokePromotionalEntitlementInput;
}>;
export declare type RevokePromotionalEntitlementMutation = {
    __typename?: 'Mutation';
    revokePromotionalEntitlement: {
        __typename?: 'PromotionalEntitlement';
        id: any;
    };
};
export declare type ProvisionSubscriptionMutationVariables = Exact<{
    input: ProvisionSubscriptionInput;
}>;
export declare type ProvisionSubscriptionMutation = {
    __typename?: 'Mutation';
    provisionSubscription: ({
        __typename?: 'ProvisionSubscriptionResult';
    } & ProvisionSubscriptionFragment);
};
export declare type ApplySubscriptionMutationVariables = Exact<{
    input: ApplySubscriptionInput;
}>;
export declare type ApplySubscriptionMutation = {
    __typename?: 'Mutation';
    applySubscription: ({
        __typename?: 'ApplySubscription';
    } & ApplySubscriptionFragment);
};
export declare type ImportSubscriptionsBulkMutationVariables = Exact<{
    input: ImportSubscriptionsBulkInput;
}>;
export declare type ImportSubscriptionsBulkMutation = {
    __typename?: 'Mutation';
    importSubscriptionsBulk?: string | null;
};
export declare type UpdateSubscriptionMutationVariables = Exact<{
    input: UpdateSubscriptionInput;
}>;
export declare type UpdateSubscriptionMutation = {
    __typename?: 'Mutation';
    updateSubscription: ({
        __typename?: 'CustomerSubscription';
    } & SlimSubscriptionFragment);
};
export declare type CancelSubscriptionMutationVariables = Exact<{
    input: SubscriptionCancellationInput;
}>;
export declare type CancelSubscriptionMutation = {
    __typename?: 'Mutation';
    cancelSubscription: ({
        __typename?: 'CustomerSubscription';
    } & SlimSubscriptionFragment);
};
export declare type EstimateSubscriptionMutationVariables = Exact<{
    input: EstimateSubscriptionInput;
}>;
export declare type EstimateSubscriptionMutation = {
    __typename?: 'Mutation';
    estimateSubscription: ({
        __typename?: 'SubscriptionPreview';
    } & SubscriptionPreviewFragment);
};
export declare type EstimateSubscriptionUpdateMutationVariables = Exact<{
    input: EstimateSubscriptionUpdateInput;
}>;
export declare type EstimateSubscriptionUpdateMutation = {
    __typename?: 'Mutation';
    estimateSubscriptionUpdate: ({
        __typename?: 'SubscriptionPreview';
    } & SubscriptionPreviewFragment);
};
export declare type PreviewSubscriptionMutationVariables = Exact<{
    input: PreviewSubscriptionInput;
}>;
export declare type PreviewSubscriptionMutation = {
    __typename?: 'Mutation';
    previewSubscription: ({
        __typename?: 'SubscriptionPreviewV2';
    } & SubscriptionPreviewV2Fragment);
};
export declare type PreviewNextInvoiceMutationVariables = Exact<{
    input: PreviewNextInvoiceInput;
}>;
export declare type PreviewNextInvoiceMutation = {
    __typename?: 'Mutation';
    previewNextInvoice: ({
        __typename?: 'SubscriptionInvoicePreview';
    } & SubscriptionInvoicePreviewFragment);
};
export declare type CancelSubscriptionUpdatesMutationVariables = Exact<{
    input: SubscriptionUpdateScheduleCancellationInput;
}>;
export declare type CancelSubscriptionUpdatesMutation = {
    __typename?: 'Mutation';
    cancelSchedule: string;
};
export declare type ReportUsageMutationVariables = Exact<{
    input: ReportUsageInput;
}>;
export declare type ReportUsageMutation = {
    __typename?: 'Mutation';
    reportUsage: ({
        __typename?: 'UsageMeasurementWithCurrentUsage';
    } & ReportUsageFragment);
};
export declare type ReportUsageBulkMutationVariables = Exact<{
    input: ReportUsageBulkInput;
}>;
export declare type ReportUsageBulkMutation = {
    __typename?: 'Mutation';
    reportUsageBulk: Array<({
        __typename?: 'UsageMeasurementWithCurrentUsage';
    } & ReportUsageFragment)>;
};
export declare type ReportEventMutationVariables = Exact<{
    input: UsageEventsReportInput;
}>;
export declare type ReportEventMutation = {
    __typename?: 'Mutation';
    reportEvent?: string | null;
};
export declare type ReportEntitlementCheckRequestedMutationVariables = Exact<{
    entitlementCheckRequested: EntitlementCheckRequested;
}>;
export declare type ReportEntitlementCheckRequestedMutation = {
    __typename?: 'Mutation';
    reportEntitlementCheckRequested: boolean;
};
export declare type CreateSubscriptionMutationVariables = Exact<{
    input: SubscriptionInput;
}>;
export declare type CreateSubscriptionMutation = {
    __typename?: 'Mutation';
    createSubscription: ({
        __typename?: 'CustomerSubscription';
    } & SlimSubscriptionFragment);
};
export declare type MigrateSubscriptionToLatestMutationVariables = Exact<{
    input: SubscriptionMigrationInput;
}>;
export declare type MigrateSubscriptionToLatestMutation = {
    __typename?: 'Mutation';
    migrateSubscriptionToLatest: {
        __typename?: 'CustomerSubscription';
        subscriptionId: string;
    };
};
export declare type ArchiveCustomerMutationVariables = Exact<{
    input: ArchiveCustomerInput;
}>;
export declare type ArchiveCustomerMutation = {
    __typename?: 'Mutation';
    archiveCustomer: {
        __typename?: 'Customer';
        customerId: string;
    };
};
export declare type UnarchiveCustomerMutationVariables = Exact<{
    input: UnarchiveCustomerInput;
}>;
export declare type UnarchiveCustomerMutation = {
    __typename?: 'Mutation';
    unarchiveCustomer: ({
        __typename?: 'Customer';
    } & SlimCustomerFragment);
};
export declare type TransferSubscriptionMutationVariables = Exact<{
    input: TransferSubscriptionInput;
}>;
export declare type TransferSubscriptionMutation = {
    __typename?: 'Mutation';
    transferSubscription: ({
        __typename?: 'CustomerSubscription';
    } & SlimSubscriptionFragment);
};
export declare type DelegateSubscriptionToCustomerMutationVariables = Exact<{
    input: DelegateSubscriptionToCustomerInput;
}>;
export declare type DelegateSubscriptionToCustomerMutation = {
    __typename?: 'Mutation';
    delegateSubscriptionToCustomer: ({
        __typename?: 'CustomerSubscription';
    } & SlimSubscriptionFragment);
};
export declare type TransferSubscriptionToResourceMutationVariables = Exact<{
    input: TransferSubscriptionToResourceInput;
}>;
export declare type TransferSubscriptionToResourceMutation = {
    __typename?: 'Mutation';
    transferSubscriptionToResource: ({
        __typename?: 'CustomerSubscription';
    } & SlimSubscriptionFragment);
};
export declare type GrantCreditsMutationVariables = Exact<{
    input: CreditGrantInput;
}>;
export declare type GrantCreditsMutation = {
    __typename?: 'Mutation';
    createCreditGrant: ({
        __typename?: 'CreditGrant';
    } & CreditGrantFragment);
};
export declare type GetCustomerByIdQueryVariables = Exact<{
    input: GetCustomerByRefIdInput;
}>;
export declare type GetCustomerByIdQuery = {
    __typename?: 'Query';
    getCustomerByRefId?: ({
        __typename?: 'Customer';
    } & CustomerWithSubscriptionsFragment) | null;
};
export declare type GetCustomerStatisticsQueryVariables = Exact<{
    input: GetCustomerByRefIdInput;
}>;
export declare type GetCustomerStatisticsQuery = {
    __typename?: 'Query';
    getCustomerByRefId?: ({
        __typename?: 'Customer';
    } & CustomerStatisticsFragment) | null;
};
export declare type GetActiveSubscriptionsQueryVariables = Exact<{
    input: GetActiveSubscriptionsInput;
}>;
export declare type GetActiveSubscriptionsQuery = {
    __typename?: 'Query';
    getActiveSubscriptions: Array<({
        __typename?: 'CustomerSubscription';
    } & SubscriptionFragment)>;
};
export declare type GetActiveSubscriptionsListQueryVariables = Exact<{
    input: GetActiveSubscriptionsInput;
}>;
export declare type GetActiveSubscriptionsListQuery = {
    __typename?: 'Query';
    getActiveSubscriptions: Array<({
        __typename?: 'CustomerSubscription';
    } & SlimSubscriptionFragmentV2Fragment)>;
};
export declare type GetSubscriptionsQueryVariables = Exact<{
    filter?: InputMaybe<SubscriptionQueryFilter>;
    paging?: InputMaybe<CursorPaging>;
    sorting?: InputMaybe<Array<SubscriptionQuerySort> | SubscriptionQuerySort>;
}>;
export declare type GetSubscriptionsQuery = {
    __typename?: 'Query';
    subscriptions: {
        __typename?: 'SubscriptionQueryConnection';
        edges: Array<{
            __typename?: 'SubscriptionQueryEdge';
            node: ({
                __typename?: 'SubscriptionQuery';
            } & SubscriptionQueryFragment);
        }>;
        pageInfo: ({
            __typename?: 'PageInfo';
        } & PageInfoFragment);
    };
};
export declare type GetSubscriptionQueryVariables = Exact<{
    input: GetSubscriptionInput;
}>;
export declare type GetSubscriptionQuery = {
    __typename?: 'Query';
    getSubscription: ({
        __typename?: 'CustomerSubscription';
    } & SubscriptionFragment);
};
export declare type GetCouponsQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type GetCouponsQuery = {
    __typename?: 'Query';
    coupons: {
        __typename?: 'CouponConnection';
        edges: Array<{
            __typename?: 'CouponEdge';
            node: ({
                __typename?: 'Coupon';
            } & CouponFragment);
        }>;
    };
};
export declare type GetPaywallQueryVariables = Exact<{
    input: GetPaywallInput;
}>;
export declare type GetPaywallQuery = {
    __typename?: 'Query';
    paywall: ({
        __typename?: 'Paywall';
    } & PaywallFragment);
};
export declare type GetEntitlementsQueryVariables = Exact<{
    query: FetchEntitlementsQuery;
}>;
export declare type GetEntitlementsQuery = {
    __typename?: 'Query';
    entitlements: Array<({
        __typename?: 'Entitlement';
    } & EntitlementFragment)>;
};
export declare type GetEntitlementQueryVariables = Exact<{
    query: FetchEntitlementQuery;
}>;
export declare type GetEntitlementQuery = {
    __typename?: 'Query';
    entitlement: ({
        __typename?: 'Entitlement';
    } & EntitlementFragment);
};
export declare type GetProductsQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type GetProductsQuery = {
    __typename?: 'Query';
    products: {
        __typename?: 'ProductConnection';
        edges: Array<{
            __typename?: 'ProductEdge';
            node: ({
                __typename?: 'Product';
            } & ProductFragment);
        }>;
    };
};
export declare type GetSdkConfigurationQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type GetSdkConfigurationQuery = {
    __typename?: 'Query';
    sdkConfiguration?: {
        __typename?: 'SdkConfiguration';
        sentryDsn?: string | null;
        isWidgetWatermarkEnabled?: boolean | null;
    } | null;
};
export declare type GetCustomerPortalByRefIdQueryVariables = Exact<{
    input: CustomerPortalInput;
}>;
export declare type GetCustomerPortalByRefIdQuery = {
    __typename?: 'Query';
    customerPortal: ({
        __typename?: 'CustomerPortal';
    } & CustomerPortalFragment);
};
export declare type GetCheckoutStateQueryVariables = Exact<{
    input: CheckoutStateInput;
}>;
export declare type GetCheckoutStateQuery = {
    __typename?: 'Query';
    checkoutState: ({
        __typename?: 'CheckoutState';
    } & CheckoutStateFragment);
};
export declare type GetMockPaywallQueryVariables = Exact<{
    input: GetPaywallInput;
}>;
export declare type GetMockPaywallQuery = {
    __typename?: 'Query';
    mockPaywall: {
        __typename?: 'MockPaywall';
        plans: Array<({
            __typename?: 'PaywallPlan';
        } & MockPaywallPlanFragment)>;
        configuration?: ({
            __typename?: 'PaywallConfiguration';
        } & PaywallConfigurationFragment) | null;
    };
};
export declare type GetUsageHistoryQueryVariables = Exact<{
    usageHistoryInput: UsageHistoryInput;
}>;
export declare type GetUsageHistoryQuery = {
    __typename?: 'Query';
    usageHistory: ({
        __typename?: 'UsageHistory';
    } & UsageHistoryFragment);
};
export declare type GetUsageHistoryV2QueryVariables = Exact<{
    input: UsageHistoryV2Input;
}>;
export declare type GetUsageHistoryV2Query = {
    __typename?: 'Query';
    usageHistoryV2: ({
        __typename?: 'UsageHistoryV2';
    } & UsageHistoryV2Fragment);
};
export declare type GetCreditBalanceQueryVariables = Exact<{
    input: CreditBalanceSummaryInput;
}>;
export declare type GetCreditBalanceQuery = {
    __typename?: 'Query';
    creditBalanceSummary: ({
        __typename?: 'CreditBalanceSummary';
    } & CreditsBalanceSummaryFragment);
};
export declare type GetCreditGrantsQueryVariables = Exact<{
    input: GetCreditGrantsInput;
}>;
export declare type GetCreditGrantsQuery = {
    __typename?: 'Query';
    creditGrants: Array<({
        __typename?: 'CreditGrant';
    } & CreditGrantFragment)>;
};
export declare type OnEntitlementsUpdatedSubscriptionVariables = Exact<{
    [key: string]: never;
}>;
export declare type OnEntitlementsUpdatedSubscription = {
    __typename?: 'Subscription';
    entitlementsUpdated: ({
        __typename?: 'EntitlementsUpdated';
    } & EntitlementsUpdatedPayloadFragment);
};
export declare type OnUsageUpdatedSubscriptionVariables = Exact<{
    [key: string]: never;
}>;
export declare type OnUsageUpdatedSubscription = {
    __typename?: 'Subscription';
    usageUpdated: ({
        __typename?: 'UsageUpdated';
    } & EntitlementUsageUpdatedFragment);
};
export declare type OnPackagePublishedSubscriptionVariables = Exact<{
    [key: string]: never;
}>;
export declare type OnPackagePublishedSubscription = {
    __typename?: 'Subscription';
    packagePublished: ({
        __typename?: 'PackagePublished';
    } & PackagePublishedPayloadFragment);
};
export declare const PageInfoFragmentDoc: import("graphql").DocumentNode;
export declare const SubscriptionQueryFragmentDoc: import("graphql").DocumentNode;
export declare const SlimSubscriptionFragmentV2FragmentDoc: import("graphql").DocumentNode;
export declare const SlimCustomerFragmentDoc: import("graphql").DocumentNode;
export declare const CouponFragmentDoc: import("graphql").DocumentNode;
export declare const PromotionalEntitlementFragmentDoc: import("graphql").DocumentNode;
export declare const CustomerFragmentDoc: import("graphql").DocumentNode;
export declare const SubscriptionInvoiceFragmentDoc: import("graphql").DocumentNode;
export declare const CustomerResourceFragmentDoc: import("graphql").DocumentNode;
export declare const PriceTierFragmentDoc: import("graphql").DocumentNode;
export declare const PriceFragmentDoc: import("graphql").DocumentNode;
export declare const TotalPriceFragmentDoc: import("graphql").DocumentNode;
export declare const ProductFragmentDoc: import("graphql").DocumentNode;
export declare const PackageEntitlementFragmentDoc: import("graphql").DocumentNode;
export declare const OveragePriceFragmentDoc: import("graphql").DocumentNode;
export declare const AddonDependencyFragmentDoc: import("graphql").DocumentNode;
export declare const AddonFragmentDoc: import("graphql").DocumentNode;
export declare const PlanCompatiblePackageGroupsFragmentDoc: import("graphql").DocumentNode;
export declare const PlanFragmentDoc: import("graphql").DocumentNode;
export declare const ScheduleVariablesFragmentDoc: import("graphql").DocumentNode;
export declare const SubscriptionScheduledUpdateDataFragmentDoc: import("graphql").DocumentNode;
export declare const SubscriptionFutureUpdateDataFragmentDoc: import("graphql").DocumentNode;
export declare const SubscriptionTrialConfigurationFragmentDoc: import("graphql").DocumentNode;
export declare const SubscriptionFragmentDoc: import("graphql").DocumentNode;
export declare const CustomerWithSubscriptionsFragmentDoc: import("graphql").DocumentNode;
export declare const CustomerStatisticsFragmentDoc: import("graphql").DocumentNode;
export declare const SubscriptionPreviewFragmentDoc: import("graphql").DocumentNode;
export declare const ImmediateSubscriptionPreviewInvoiceFragmentDoc: import("graphql").DocumentNode;
export declare const SubscriptionPreviewInvoiceFragmentDoc: import("graphql").DocumentNode;
export declare const SubscriptionPreviewV2FragmentDoc: import("graphql").DocumentNode;
export declare const SubscriptionInvoicePreviewFragmentDoc: import("graphql").DocumentNode;
export declare const ResetPeriodConfigurationFragmentDoc: import("graphql").DocumentNode;
export declare const FeatureFragmentDoc: import("graphql").DocumentNode;
export declare const EntitlementFragmentDoc: import("graphql").DocumentNode;
export declare const EntitlementsUpdatedPayloadFragmentDoc: import("graphql").DocumentNode;
export declare const UsageUpdatedFragmentDoc: import("graphql").DocumentNode;
export declare const EntitlementUsageUpdatedFragmentDoc: import("graphql").DocumentNode;
export declare const PackagePublishedPayloadFragmentDoc: import("graphql").DocumentNode;
export declare const CustomerPortalSubscriptionPriceFragmentDoc: import("graphql").DocumentNode;
export declare const CustomerPortalSubscriptionAddonFragmentDoc: import("graphql").DocumentNode;
export declare const CustomerPortalSubscriptionScheduledUpdateDataFragmentDoc: import("graphql").DocumentNode;
export declare const CustomerPortalSubscriptionFragmentDoc: import("graphql").DocumentNode;
export declare const CustomerPortalEntitlementFragmentDoc: import("graphql").DocumentNode;
export declare const CustomerPortalPromotionalEntitlementFragmentDoc: import("graphql").DocumentNode;
export declare const CustomerPortalBillingInformationFragmentDoc: import("graphql").DocumentNode;
export declare const FontVariantFragmentDoc: import("graphql").DocumentNode;
export declare const TypographyConfigurationFragmentDoc: import("graphql").DocumentNode;
export declare const CustomerPortalConfigurationFragmentDoc: import("graphql").DocumentNode;
export declare const CustomerPortalFragmentDoc: import("graphql").DocumentNode;
export declare const CheckoutConfigurationFragmentDoc: import("graphql").DocumentNode;
export declare const CheckoutStateFragmentDoc: import("graphql").DocumentNode;
export declare const MockPaywallPackageEntitlementFragmentDoc: import("graphql").DocumentNode;
export declare const MockPaywallPriceFragmentDoc: import("graphql").DocumentNode;
export declare const MockPaywallAddonDependencyFragmentDoc: import("graphql").DocumentNode;
export declare const MockPaywallAddonFragmentDoc: import("graphql").DocumentNode;
export declare const MockPaywallPlanCompatiblePackageGroupsFragmentDoc: import("graphql").DocumentNode;
export declare const MockPaywallPlanFragmentDoc: import("graphql").DocumentNode;
export declare const PaywallCurrencyFragmentDoc: import("graphql").DocumentNode;
export declare const LayoutConfigurationFragmentDoc: import("graphql").DocumentNode;
export declare const PaywallConfigurationFragmentDoc: import("graphql").DocumentNode;
export declare const PaywallCalculatedPricePointsFragmentDoc: import("graphql").DocumentNode;
export declare const PaywallFragmentDoc: import("graphql").DocumentNode;
export declare const UsageHistoryFragmentDoc: import("graphql").DocumentNode;
export declare const UsageHistoryV2FragmentDoc: import("graphql").DocumentNode;
export declare const SlimSubscriptionFragmentDoc: import("graphql").DocumentNode;
export declare const ProvisionCustomerFragmentDoc: import("graphql").DocumentNode;
export declare const ApplySubscriptionFragmentDoc: import("graphql").DocumentNode;
export declare const ProvisionSubscriptionFragmentDoc: import("graphql").DocumentNode;
export declare const ReportUsageFragmentDoc: import("graphql").DocumentNode;
export declare const CreditGrantFragmentDoc: import("graphql").DocumentNode;
export declare const CreditsBalanceSummaryFragmentDoc: import("graphql").DocumentNode;
export declare const ProvisionCustomerDocument: import("graphql").DocumentNode;
export declare const ImportCustomerBulkDocument: import("graphql").DocumentNode;
export declare const ImportCustomerDocument: import("graphql").DocumentNode;
export declare const UpdateCustomerDocument: import("graphql").DocumentNode;
export declare const DetachCustomerPaymentMethodDocument: import("graphql").DocumentNode;
export declare const GrantPromotionalEntitlementsDocument: import("graphql").DocumentNode;
export declare const RevokePromotionalEntitlementDocument: import("graphql").DocumentNode;
export declare const ProvisionSubscriptionDocument: import("graphql").DocumentNode;
export declare const ApplySubscriptionDocument: import("graphql").DocumentNode;
export declare const ImportSubscriptionsBulkDocument: import("graphql").DocumentNode;
export declare const UpdateSubscriptionDocument: import("graphql").DocumentNode;
export declare const CancelSubscriptionDocument: import("graphql").DocumentNode;
export declare const EstimateSubscriptionDocument: import("graphql").DocumentNode;
export declare const EstimateSubscriptionUpdateDocument: import("graphql").DocumentNode;
export declare const PreviewSubscriptionDocument: import("graphql").DocumentNode;
export declare const PreviewNextInvoiceDocument: import("graphql").DocumentNode;
export declare const CancelSubscriptionUpdatesDocument: import("graphql").DocumentNode;
export declare const ReportUsageDocument: import("graphql").DocumentNode;
export declare const ReportUsageBulkDocument: import("graphql").DocumentNode;
export declare const ReportEventDocument: import("graphql").DocumentNode;
export declare const ReportEntitlementCheckRequestedDocument: import("graphql").DocumentNode;
export declare const CreateSubscriptionDocument: import("graphql").DocumentNode;
export declare const MigrateSubscriptionToLatestDocument: import("graphql").DocumentNode;
export declare const ArchiveCustomerDocument: import("graphql").DocumentNode;
export declare const UnarchiveCustomerDocument: import("graphql").DocumentNode;
export declare const TransferSubscriptionDocument: import("graphql").DocumentNode;
export declare const DelegateSubscriptionToCustomerDocument: import("graphql").DocumentNode;
export declare const TransferSubscriptionToResourceDocument: import("graphql").DocumentNode;
export declare const GrantCreditsDocument: import("graphql").DocumentNode;
export declare const GetCustomerByIdDocument: import("graphql").DocumentNode;
export declare const GetCustomerStatisticsDocument: import("graphql").DocumentNode;
export declare const GetActiveSubscriptionsDocument: import("graphql").DocumentNode;
export declare const GetActiveSubscriptionsListDocument: import("graphql").DocumentNode;
export declare const GetSubscriptionsDocument: import("graphql").DocumentNode;
export declare const GetSubscriptionDocument: import("graphql").DocumentNode;
export declare const GetCouponsDocument: import("graphql").DocumentNode;
export declare const GetPaywallDocument: import("graphql").DocumentNode;
export declare const GetEntitlementsDocument: import("graphql").DocumentNode;
export declare const GetEntitlementDocument: import("graphql").DocumentNode;
export declare const GetProductsDocument: import("graphql").DocumentNode;
export declare const GetSdkConfigurationDocument: import("graphql").DocumentNode;
export declare const GetCustomerPortalByRefIdDocument: import("graphql").DocumentNode;
export declare const GetCheckoutStateDocument: import("graphql").DocumentNode;
export declare const GetMockPaywallDocument: import("graphql").DocumentNode;
export declare const GetUsageHistoryDocument: import("graphql").DocumentNode;
export declare const GetUsageHistoryV2Document: import("graphql").DocumentNode;
export declare const GetCreditBalanceDocument: import("graphql").DocumentNode;
export declare const GetCreditGrantsDocument: import("graphql").DocumentNode;
export declare const OnEntitlementsUpdatedDocument: import("graphql").DocumentNode;
export declare const OnUsageUpdatedDocument: import("graphql").DocumentNode;
export declare const OnPackagePublishedDocument: import("graphql").DocumentNode;
export declare type SdkFunctionWrapper = <T>(action: (requestHeaders?: Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;
export declare function getSdk(client: GraphQLClient, withWrapper?: SdkFunctionWrapper): {
    ProvisionCustomer(variables: ProvisionCustomerMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<ProvisionCustomerMutation>;
    ImportCustomerBulk(variables: ImportCustomerBulkMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<ImportCustomerBulkMutation>;
    ImportCustomer(variables: ImportCustomerMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<ImportCustomerMutation>;
    UpdateCustomer(variables: UpdateCustomerMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<UpdateCustomerMutation>;
    DetachCustomerPaymentMethod(variables: DetachCustomerPaymentMethodMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<DetachCustomerPaymentMethodMutation>;
    GrantPromotionalEntitlements(variables: GrantPromotionalEntitlementsMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GrantPromotionalEntitlementsMutation>;
    RevokePromotionalEntitlement(variables: RevokePromotionalEntitlementMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<RevokePromotionalEntitlementMutation>;
    ProvisionSubscription(variables: ProvisionSubscriptionMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<ProvisionSubscriptionMutation>;
    ApplySubscription(variables: ApplySubscriptionMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<ApplySubscriptionMutation>;
    ImportSubscriptionsBulk(variables: ImportSubscriptionsBulkMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<ImportSubscriptionsBulkMutation>;
    UpdateSubscription(variables: UpdateSubscriptionMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<UpdateSubscriptionMutation>;
    CancelSubscription(variables: CancelSubscriptionMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<CancelSubscriptionMutation>;
    EstimateSubscription(variables: EstimateSubscriptionMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<EstimateSubscriptionMutation>;
    EstimateSubscriptionUpdate(variables: EstimateSubscriptionUpdateMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<EstimateSubscriptionUpdateMutation>;
    PreviewSubscription(variables: PreviewSubscriptionMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<PreviewSubscriptionMutation>;
    PreviewNextInvoice(variables: PreviewNextInvoiceMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<PreviewNextInvoiceMutation>;
    CancelSubscriptionUpdates(variables: CancelSubscriptionUpdatesMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<CancelSubscriptionUpdatesMutation>;
    ReportUsage(variables: ReportUsageMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<ReportUsageMutation>;
    ReportUsageBulk(variables: ReportUsageBulkMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<ReportUsageBulkMutation>;
    ReportEvent(variables: ReportEventMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<ReportEventMutation>;
    ReportEntitlementCheckRequested(variables: ReportEntitlementCheckRequestedMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<ReportEntitlementCheckRequestedMutation>;
    CreateSubscription(variables: CreateSubscriptionMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<CreateSubscriptionMutation>;
    MigrateSubscriptionToLatest(variables: MigrateSubscriptionToLatestMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<MigrateSubscriptionToLatestMutation>;
    ArchiveCustomer(variables: ArchiveCustomerMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<ArchiveCustomerMutation>;
    UnarchiveCustomer(variables: UnarchiveCustomerMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<UnarchiveCustomerMutation>;
    TransferSubscription(variables: TransferSubscriptionMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<TransferSubscriptionMutation>;
    DelegateSubscriptionToCustomer(variables: DelegateSubscriptionToCustomerMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<DelegateSubscriptionToCustomerMutation>;
    TransferSubscriptionToResource(variables: TransferSubscriptionToResourceMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<TransferSubscriptionToResourceMutation>;
    GrantCredits(variables: GrantCreditsMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GrantCreditsMutation>;
    GetCustomerById(variables: GetCustomerByIdQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetCustomerByIdQuery>;
    GetCustomerStatistics(variables: GetCustomerStatisticsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetCustomerStatisticsQuery>;
    GetActiveSubscriptions(variables: GetActiveSubscriptionsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetActiveSubscriptionsQuery>;
    GetActiveSubscriptionsList(variables: GetActiveSubscriptionsListQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetActiveSubscriptionsListQuery>;
    GetSubscriptions(variables?: GetSubscriptionsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetSubscriptionsQuery>;
    GetSubscription(variables: GetSubscriptionQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetSubscriptionQuery>;
    GetCoupons(variables?: GetCouponsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetCouponsQuery>;
    GetPaywall(variables: GetPaywallQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetPaywallQuery>;
    GetEntitlements(variables: GetEntitlementsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetEntitlementsQuery>;
    GetEntitlement(variables: GetEntitlementQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetEntitlementQuery>;
    GetProducts(variables?: GetProductsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetProductsQuery>;
    GetSdkConfiguration(variables?: GetSdkConfigurationQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetSdkConfigurationQuery>;
    GetCustomerPortalByRefId(variables: GetCustomerPortalByRefIdQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetCustomerPortalByRefIdQuery>;
    GetCheckoutState(variables: GetCheckoutStateQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetCheckoutStateQuery>;
    GetMockPaywall(variables: GetMockPaywallQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetMockPaywallQuery>;
    GetUsageHistory(variables: GetUsageHistoryQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetUsageHistoryQuery>;
    GetUsageHistoryV2(variables: GetUsageHistoryV2QueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetUsageHistoryV2Query>;
    GetCreditBalance(variables: GetCreditBalanceQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetCreditBalanceQuery>;
    GetCreditGrants(variables: GetCreditGrantsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetCreditGrantsQuery>;
    OnEntitlementsUpdated(variables?: OnEntitlementsUpdatedSubscriptionVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<OnEntitlementsUpdatedSubscription>;
    OnUsageUpdated(variables?: OnUsageUpdatedSubscriptionVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<OnUsageUpdatedSubscription>;
    OnPackagePublished(variables?: OnPackagePublishedSubscriptionVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<OnPackagePublishedSubscription>;
};
export declare type Sdk = ReturnType<typeof getSdk>;
export {};
